# compiler: R8
# compiler_version: 1.6.82
# min_api: 24
# pg_map_id: c49eff6
# common_typos_disable
android.support.v4.media.MediaBrowserCompat$CustomActionCallback -> android.support.v4.media.do:
    void onError(java.lang.String,android.os.Bundle,android.os.Bundle) -> do
    void onResult(java.lang.String,android.os.Bundle,android.os.Bundle) -> for
    void onProgressUpdate(java.lang.String,android.os.Bundle,android.os.Bundle) -> if
android.support.v4.media.MediaBrowserCompat$CustomActionResultReceiver -> android.support.v4.media.MediaBrowserCompat$CustomActionResultReceiver:
    java.lang.String mAction -> int
    android.os.Bundle mExtras -> new
    android.support.v4.media.MediaBrowserCompat$CustomActionCallback mCallback -> try
    void onReceiveResult(int,android.os.Bundle) -> do
android.support.v4.media.MediaBrowserCompat$ItemCallback -> android.support.v4.media.if:
    void onError(java.lang.String) -> do
    void onItemLoaded(android.support.v4.media.MediaBrowserCompat$MediaItem) -> do
android.support.v4.media.MediaBrowserCompat$ItemReceiver -> android.support.v4.media.MediaBrowserCompat$ItemReceiver:
    java.lang.String mMediaId -> int
    android.support.v4.media.MediaBrowserCompat$ItemCallback mCallback -> new
    void onReceiveResult(int,android.os.Bundle) -> do
android.support.v4.media.MediaBrowserCompat$MediaItem -> android.support.v4.media.MediaBrowserCompat$MediaItem:
    int mFlags -> if
    android.support.v4.media.MediaDescriptionCompat mDescription -> for
android.support.v4.media.MediaBrowserCompat$MediaItem$1 -> android.support.v4.media.MediaBrowserCompat$MediaItem$do:
android.support.v4.media.MediaBrowserCompat$SearchCallback -> android.support.v4.media.for:
    void onError(java.lang.String,android.os.Bundle) -> do
    void onSearchResult(java.lang.String,android.os.Bundle,java.util.List) -> do
android.support.v4.media.MediaBrowserCompat$SearchResultReceiver -> android.support.v4.media.MediaBrowserCompat$SearchResultReceiver:
    android.support.v4.media.MediaBrowserCompat$SearchCallback mCallback -> try
    java.lang.String mQuery -> int
    android.os.Bundle mExtras -> new
    void onReceiveResult(int,android.os.Bundle) -> do
android.support.v4.media.MediaDescriptionCompat -> android.support.v4.media.MediaDescriptionCompat:
    java.lang.Object mDescriptionObj -> else
    android.os.Bundle mExtras -> case
    android.graphics.Bitmap mIcon -> try
    android.net.Uri mIconUri -> byte
    java.lang.String mMediaId -> if
    java.lang.CharSequence mDescription -> new
    java.lang.CharSequence mSubtitle -> int
    java.lang.CharSequence mTitle -> for
    android.net.Uri mMediaUri -> char
    android.support.v4.media.MediaDescriptionCompat fromMediaDescription(java.lang.Object) -> do
    java.lang.Object getMediaDescription() -> int
android.support.v4.media.MediaDescriptionCompat$1 -> android.support.v4.media.MediaDescriptionCompat$do:
android.support.v4.media.MediaDescriptionCompat$Builder -> android.support.v4.media.MediaDescriptionCompat$if:
    java.lang.String mMediaId -> do
    android.os.Bundle mExtras -> byte
    android.net.Uri mMediaUri -> case
    android.graphics.Bitmap mIcon -> new
    android.net.Uri mIconUri -> try
    java.lang.CharSequence mDescription -> int
    java.lang.CharSequence mSubtitle -> for
    java.lang.CharSequence mTitle -> if
    android.support.v4.media.MediaDescriptionCompat build() -> do
    android.support.v4.media.MediaDescriptionCompat$Builder setDescription(java.lang.CharSequence) -> do
    android.support.v4.media.MediaDescriptionCompat$Builder setExtras(android.os.Bundle) -> do
    android.support.v4.media.MediaDescriptionCompat$Builder setIconBitmap(android.graphics.Bitmap) -> do
    android.support.v4.media.MediaDescriptionCompat$Builder setIconUri(android.net.Uri) -> do
    android.support.v4.media.MediaDescriptionCompat$Builder setMediaId(java.lang.String) -> do
    android.support.v4.media.MediaDescriptionCompat$Builder setTitle(java.lang.CharSequence) -> for
    android.support.v4.media.MediaDescriptionCompat$Builder setMediaUri(android.net.Uri) -> if
    android.support.v4.media.MediaDescriptionCompat$Builder setSubtitle(java.lang.CharSequence) -> if
android.support.v4.media.MediaDescriptionCompatApi21 -> android.support.v4.media.int:
    java.lang.CharSequence getTitle(java.lang.Object) -> byte
    java.lang.Object fromParcel(android.os.Parcel) -> do
    java.lang.CharSequence getDescription(java.lang.Object) -> do
    void writeToParcel(java.lang.Object,android.os.Parcel,int) -> do
    android.graphics.Bitmap getIconBitmap(java.lang.Object) -> for
    android.os.Bundle getExtras(java.lang.Object) -> if
    android.net.Uri getIconUri(java.lang.Object) -> int
    java.lang.String getMediaId(java.lang.Object) -> new
    java.lang.CharSequence getSubtitle(java.lang.Object) -> try
android.support.v4.media.MediaDescriptionCompatApi21$Builder -> android.support.v4.media.int$do:
    java.lang.Object build(java.lang.Object) -> do
    java.lang.Object newInstance() -> do
    void setDescription(java.lang.Object,java.lang.CharSequence) -> do
    void setExtras(java.lang.Object,android.os.Bundle) -> do
    void setIconBitmap(java.lang.Object,android.graphics.Bitmap) -> do
    void setIconUri(java.lang.Object,android.net.Uri) -> do
    void setMediaId(java.lang.Object,java.lang.String) -> do
    void setTitle(java.lang.Object,java.lang.CharSequence) -> for
    void setSubtitle(java.lang.Object,java.lang.CharSequence) -> if
android.support.v4.media.MediaDescriptionCompatApi23 -> android.support.v4.media.new:
    android.net.Uri getMediaUri(java.lang.Object) -> do
android.support.v4.media.MediaDescriptionCompatApi23$Builder -> android.support.v4.media.new$do:
    void setMediaUri(java.lang.Object,android.net.Uri) -> do
android.support.v4.media.MediaMetadataCompat -> android.support.v4.media.MediaMetadataCompat:
    android.os.Bundle mBundle -> if
    java.lang.Object mMetadataObj -> for
    androidx.collection.ArrayMap METADATA_KEYS_TYPE -> int
    android.support.v4.media.MediaMetadataCompat fromMediaMetadata(java.lang.Object) -> do
android.support.v4.media.MediaMetadataCompat$1 -> android.support.v4.media.MediaMetadataCompat$do:
android.support.v4.media.MediaMetadataCompatApi21 -> android.support.v4.media.try:
    void writeToParcel(java.lang.Object,android.os.Parcel,int) -> do
android.support.v4.media.RatingCompat -> android.support.v4.media.RatingCompat:
    int mRatingStyle -> if
    float mRatingValue -> for
android.support.v4.media.RatingCompat$1 -> android.support.v4.media.RatingCompat$do:
android.support.v4.media.session.IMediaControllerCallback -> android.support.v4.media.session.do:
    void onEvent(java.lang.String,android.os.Bundle) -> do
    void onExtrasChanged(android.os.Bundle) -> do
    void onMetadataChanged(android.support.v4.media.MediaMetadataCompat) -> do
    void onPlaybackStateChanged(android.support.v4.media.session.PlaybackStateCompat) -> do
    void onQueueChanged(java.util.List) -> do
    void onQueueTitleChanged(java.lang.CharSequence) -> do
    void onSessionDestroyed() -> do
    void onShuffleModeChanged(int) -> do
    void onShuffleModeChangedRemoved(boolean) -> do
    void onVolumeInfoChanged(android.support.v4.media.session.ParcelableVolumeInfo) -> do
    void onCaptioningEnabledChanged(boolean) -> if
    void onRepeatModeChanged(int) -> if
    void onSessionReady() -> if
android.support.v4.media.session.IMediaControllerCallback$Stub -> android.support.v4.media.session.do$do:
android.support.v4.media.session.IMediaSession -> android.support.v4.media.session.if:
    void registerCallbackListener(android.support.v4.media.session.IMediaControllerCallback) -> do
android.support.v4.media.session.IMediaSession$Stub -> android.support.v4.media.session.if$do:
    android.support.v4.media.session.IMediaSession asInterface(android.os.IBinder) -> do
android.support.v4.media.session.IMediaSession$Stub$Proxy -> android.support.v4.media.session.if$do$do:
    android.os.IBinder mRemote -> do
    void registerCallbackListener(android.support.v4.media.session.IMediaControllerCallback) -> do
android.support.v4.media.session.MediaControllerCompat$Callback -> android.support.v4.media.session.for:
    android.support.v4.media.session.IMediaControllerCallback mIControllerCallback -> if
    android.support.v4.media.session.MediaControllerCompat$Callback$MessageHandler mHandler -> do
    void onAudioInfoChanged(android.support.v4.media.session.MediaControllerCompat$PlaybackInfo) -> do
    void onExtrasChanged(android.os.Bundle) -> do
    void onMetadataChanged(android.support.v4.media.MediaMetadataCompat) -> do
    void onPlaybackStateChanged(android.support.v4.media.session.PlaybackStateCompat) -> do
    void onQueueChanged(java.util.List) -> do
    void onQueueTitleChanged(java.lang.CharSequence) -> do
    void onSessionDestroyed() -> do
    void onSessionEvent(java.lang.String,android.os.Bundle) -> do
    void postToHandler(int,java.lang.Object,android.os.Bundle) -> do
android.support.v4.media.session.MediaControllerCompat$Callback$MessageHandler -> android.support.v4.media.session.for$do:
android.support.v4.media.session.MediaControllerCompat$Callback$StubApi21 -> android.support.v4.media.session.for$if:
    java.lang.ref.WeakReference mCallback -> do
    void onAudioInfoChanged(int,int,int,int,int) -> do
    void onExtrasChanged(android.os.Bundle) -> do
    void onPlaybackStateChanged(java.lang.Object) -> do
    void onQueueChanged(java.util.List) -> do
    void onQueueTitleChanged(java.lang.CharSequence) -> do
    void onSessionDestroyed() -> do
    void onSessionEvent(java.lang.String,android.os.Bundle) -> do
    void onMetadataChanged(java.lang.Object) -> if
android.support.v4.media.session.MediaControllerCompat$Callback$StubCompat -> android.support.v4.media.session.for$for:
    java.lang.ref.WeakReference mCallback -> do
    void onEvent(java.lang.String,android.os.Bundle) -> do
    void onExtrasChanged(android.os.Bundle) -> do
    void onMetadataChanged(android.support.v4.media.MediaMetadataCompat) -> do
    void onPlaybackStateChanged(android.support.v4.media.session.PlaybackStateCompat) -> do
    void onQueueChanged(java.util.List) -> do
    void onQueueTitleChanged(java.lang.CharSequence) -> do
    void onSessionDestroyed() -> do
    void onShuffleModeChanged(int) -> do
    void onShuffleModeChangedRemoved(boolean) -> do
    void onVolumeInfoChanged(android.support.v4.media.session.ParcelableVolumeInfo) -> do
    void onCaptioningEnabledChanged(boolean) -> if
    void onRepeatModeChanged(int) -> if
    void onSessionReady() -> if
android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21 -> android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21:
    java.util.HashMap mCallbackMap -> for
    java.lang.Object mLock -> do
    java.util.List mPendingCallbacks -> if
    android.support.v4.media.session.MediaSessionCompat$Token mSessionToken -> int
    void processPendingCallbacksLocked() -> do
android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21$ExtraBinderRequestResultReceiver -> android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21$ExtraBinderRequestResultReceiver:
    java.lang.ref.WeakReference mMediaControllerImpl -> if
android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21$ExtraCallback -> android.support.v4.media.session.MediaControllerCompat$MediaControllerImplApi21$do:
    void onExtrasChanged(android.os.Bundle) -> do
    void onMetadataChanged(android.support.v4.media.MediaMetadataCompat) -> do
    void onQueueChanged(java.util.List) -> do
    void onQueueTitleChanged(java.lang.CharSequence) -> do
    void onSessionDestroyed() -> do
    void onVolumeInfoChanged(android.support.v4.media.session.ParcelableVolumeInfo) -> do
android.support.v4.media.session.MediaControllerCompat$PlaybackInfo -> android.support.v4.media.session.int:
android.support.v4.media.session.MediaControllerCompatApi21 -> android.support.v4.media.session.new:
    java.lang.Object createCallback(android.support.v4.media.session.MediaControllerCompatApi21$Callback) -> do
android.support.v4.media.session.MediaControllerCompatApi21$Callback -> android.support.v4.media.session.new$do:
    void onAudioInfoChanged(int,int,int,int,int) -> do
    void onExtrasChanged(android.os.Bundle) -> do
    void onPlaybackStateChanged(java.lang.Object) -> do
    void onQueueChanged(java.util.List) -> do
    void onQueueTitleChanged(java.lang.CharSequence) -> do
    void onSessionDestroyed() -> do
    void onSessionEvent(java.lang.String,android.os.Bundle) -> do
    void onMetadataChanged(java.lang.Object) -> if
android.support.v4.media.session.MediaControllerCompatApi21$CallbackProxy -> android.support.v4.media.session.new$if:
    android.support.v4.media.session.MediaControllerCompatApi21$Callback mCallback -> do
android.support.v4.media.session.MediaControllerCompatApi21$PlaybackInfo -> android.support.v4.media.session.new$for:
    android.media.AudioAttributes getAudioAttributes(java.lang.Object) -> do
    int toLegacyStreamType(android.media.AudioAttributes) -> do
    int getLegacyAudioStream(java.lang.Object) -> if
android.support.v4.media.session.MediaSessionCompat -> android.support.v4.media.session.MediaSessionCompat:
    void ensureClassLoader(android.os.Bundle) -> do
android.support.v4.media.session.MediaSessionCompat$QueueItem -> android.support.v4.media.session.MediaSessionCompat$QueueItem:
    long mId -> for
    android.support.v4.media.MediaDescriptionCompat mDescription -> if
    android.support.v4.media.session.MediaSessionCompat$QueueItem fromQueueItem(java.lang.Object) -> do
    java.util.List fromQueueItemList(java.util.List) -> do
android.support.v4.media.session.MediaSessionCompat$QueueItem$1 -> android.support.v4.media.session.MediaSessionCompat$QueueItem$do:
android.support.v4.media.session.MediaSessionCompat$ResultReceiverWrapper -> android.support.v4.media.session.MediaSessionCompat$ResultReceiverWrapper:
    android.os.ResultReceiver mResultReceiver -> if
android.support.v4.media.session.MediaSessionCompat$ResultReceiverWrapper$1 -> android.support.v4.media.session.MediaSessionCompat$ResultReceiverWrapper$do:
android.support.v4.media.session.MediaSessionCompat$Token -> android.support.v4.media.session.MediaSessionCompat$Token:
    android.support.v4.media.session.IMediaSession mExtraBinder -> for
    java.lang.Object mInner -> if
    void setExtraBinder(android.support.v4.media.session.IMediaSession) -> do
    void setSessionToken2Bundle(android.os.Bundle) -> do
    android.support.v4.media.session.IMediaSession getExtraBinder() -> int
android.support.v4.media.session.MediaSessionCompat$Token$1 -> android.support.v4.media.session.MediaSessionCompat$Token$do:
android.support.v4.media.session.MediaSessionCompatApi21$QueueItem -> android.support.v4.media.session.try:
    java.lang.Object getDescription(java.lang.Object) -> do
    long getQueueId(java.lang.Object) -> if
android.support.v4.media.session.ParcelableVolumeInfo -> android.support.v4.media.session.ParcelableVolumeInfo:
    int volumeType -> if
    int controlType -> int
    int audioStream -> for
    int maxVolume -> new
    int currentVolume -> try
android.support.v4.media.session.ParcelableVolumeInfo$1 -> android.support.v4.media.session.ParcelableVolumeInfo$do:
android.support.v4.media.session.PlaybackStateCompat -> android.support.v4.media.session.PlaybackStateCompat:
    long mUpdateTime -> char
    int mState -> if
    long mPosition -> for
    android.os.Bundle mExtras -> long
    long mActions -> try
    int mErrorCode -> byte
    long mBufferedPosition -> int
    java.lang.CharSequence mErrorMessage -> case
    java.util.List mCustomActions -> else
    long mActiveItemId -> goto
    float mSpeed -> new
    android.support.v4.media.session.PlaybackStateCompat fromPlaybackState(java.lang.Object) -> do
android.support.v4.media.session.PlaybackStateCompat$1 -> android.support.v4.media.session.PlaybackStateCompat$do:
android.support.v4.media.session.PlaybackStateCompat$CustomAction -> android.support.v4.media.session.PlaybackStateCompat$CustomAction:
    int mIcon -> int
    java.lang.String mAction -> if
    java.lang.CharSequence mName -> for
    android.os.Bundle mExtras -> new
    android.support.v4.media.session.PlaybackStateCompat$CustomAction fromCustomAction(java.lang.Object) -> do
android.support.v4.media.session.PlaybackStateCompat$CustomAction$1 -> android.support.v4.media.session.PlaybackStateCompat$CustomAction$do:
android.support.v4.media.session.PlaybackStateCompatApi21 -> android.support.v4.media.session.byte:
    float getPlaybackSpeed(java.lang.Object) -> byte
    long getPosition(java.lang.Object) -> case
    int getState(java.lang.Object) -> char
    long getActions(java.lang.Object) -> do
    long getBufferedPosition(java.lang.Object) -> for
    long getActiveQueueItemId(java.lang.Object) -> if
    java.util.List getCustomActions(java.lang.Object) -> int
    java.lang.CharSequence getErrorMessage(java.lang.Object) -> new
    long getLastPositionUpdateTime(java.lang.Object) -> try
android.support.v4.media.session.PlaybackStateCompatApi21$CustomAction -> android.support.v4.media.session.byte$do:
    java.lang.String getAction(java.lang.Object) -> do
    int getIcon(java.lang.Object) -> for
    android.os.Bundle getExtras(java.lang.Object) -> if
    java.lang.CharSequence getName(java.lang.Object) -> int
android.support.v4.media.session.PlaybackStateCompatApi22 -> android.support.v4.media.session.case:
    android.os.Bundle getExtras(java.lang.Object) -> do
android.support.v4.os.IResultReceiver -> do.do.do.do.do:
    void send(int,android.os.Bundle) -> do
android.support.v4.os.IResultReceiver$Stub -> do.do.do.do.do$do:
    android.support.v4.os.IResultReceiver asInterface(android.os.IBinder) -> do
android.support.v4.os.IResultReceiver$Stub$Proxy -> do.do.do.do.do$do$do:
    android.os.IBinder mRemote -> do
    void send(int,android.os.Bundle) -> do
android.support.v4.os.ResultReceiver -> do.do.do.do.if:
    android.os.Handler mHandler -> if
    android.support.v4.os.IResultReceiver mReceiver -> for
    void onReceiveResult(int,android.os.Bundle) -> do
android.support.v4.os.ResultReceiver$1 -> do.do.do.do.if$do:
android.support.v4.os.ResultReceiver$MyResultReceiver -> do.do.do.do.if$if:
    android.support.v4.os.ResultReceiver this$0 -> do
    void send(int,android.os.Bundle) -> do
android.support.v4.os.ResultReceiver$MyRunnable -> do.do.do.do.if$for:
    int mResultCode -> if
    android.support.v4.os.ResultReceiver this$0 -> int
    android.os.Bundle mResultData -> for
androidx.activity.Cancellable -> androidx.activity.do:
androidx.activity.ComponentActivity -> androidx.activity.ComponentActivity:
    androidx.savedstate.SavedStateRegistryController mSavedStateRegistryController -> int
    androidx.lifecycle.LifecycleRegistry mLifecycleRegistry -> for
    int mContentLayoutId -> byte
    androidx.activity.OnBackPressedDispatcher mOnBackPressedDispatcher -> try
    androidx.lifecycle.ViewModelStore mViewModelStore -> new
    java.lang.Object onRetainCustomNonConfigurationInstance() -> byte
    void access$001(androidx.activity.ComponentActivity) -> do
    androidx.lifecycle.Lifecycle getLifecycle() -> do
    androidx.savedstate.SavedStateRegistry getSavedStateRegistry() -> for
    androidx.activity.OnBackPressedDispatcher getOnBackPressedDispatcher() -> if
    androidx.lifecycle.ViewModelStore getViewModelStore() -> new
androidx.activity.ComponentActivity$1 -> androidx.activity.ComponentActivity$do:
    androidx.activity.ComponentActivity this$0 -> if
androidx.activity.ComponentActivity$2 -> androidx.activity.ComponentActivity$2:
    androidx.activity.ComponentActivity this$0 -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.activity.ComponentActivity$3 -> androidx.activity.ComponentActivity$3:
    androidx.activity.ComponentActivity this$0 -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.activity.ComponentActivity$NonConfigurationInstances -> androidx.activity.ComponentActivity$if:
    androidx.lifecycle.ViewModelStore viewModelStore -> do
androidx.activity.ImmLeaksCleaner -> androidx.activity.ImmLeaksCleaner:
    int sReflectedFieldsInitialized -> if
    java.lang.reflect.Field sHField -> for
    java.lang.reflect.Field sNextServedViewField -> new
    android.app.Activity mActivity -> do
    java.lang.reflect.Field sServedViewField -> int
    void initializeReflectiveFields() -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.activity.OnBackPressedCallback -> androidx.activity.if:
    boolean mEnabled -> do
    java.util.concurrent.CopyOnWriteArrayList mCancellables -> if
    void addCancellable(androidx.activity.Cancellable) -> do
    void handleOnBackPressed() -> do
    void setEnabled(boolean) -> do
    void remove() -> for
    boolean isEnabled() -> if
    void removeCancellable(androidx.activity.Cancellable) -> if
androidx.activity.OnBackPressedDispatcher -> androidx.activity.OnBackPressedDispatcher:
    java.util.ArrayDeque mOnBackPressedCallbacks -> if
    java.lang.Runnable mFallbackOnBackPressed -> do
    void addCallback(androidx.lifecycle.LifecycleOwner,androidx.activity.OnBackPressedCallback) -> do
    androidx.activity.Cancellable addCancellableCallback(androidx.activity.OnBackPressedCallback) -> do
    void onBackPressed() -> do
androidx.activity.OnBackPressedDispatcher$LifecycleOnBackPressedCancellable -> androidx.activity.OnBackPressedDispatcher$LifecycleOnBackPressedCancellable:
    androidx.lifecycle.Lifecycle mLifecycle -> do
    androidx.activity.OnBackPressedDispatcher this$0 -> int
    androidx.activity.OnBackPressedCallback mOnBackPressedCallback -> if
    androidx.activity.Cancellable mCurrentCancellable -> for
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.activity.OnBackPressedDispatcher$OnBackPressedCancellable -> androidx.activity.OnBackPressedDispatcher$do:
    androidx.activity.OnBackPressedCallback mOnBackPressedCallback -> do
    androidx.activity.OnBackPressedDispatcher this$0 -> if
androidx.activity.OnBackPressedDispatcherOwner -> androidx.activity.for:
    androidx.activity.OnBackPressedDispatcher getOnBackPressedDispatcher() -> if
androidx.appcompat.R$attr -> if.do.do:
androidx.appcompat.R$bool -> if.do.if:
androidx.appcompat.R$color -> if.do.for:
androidx.appcompat.R$dimen -> if.do.int:
androidx.appcompat.R$drawable -> if.do.new:
androidx.appcompat.R$id -> if.do.try:
androidx.appcompat.R$layout -> if.do.byte:
androidx.appcompat.R$string -> if.do.case:
androidx.appcompat.R$style -> if.do.char:
androidx.appcompat.R$styleable -> if.do.else:
androidx.appcompat.app.ActionBar -> androidx.appcompat.app.do:
    int getDisplayOptions() -> byte
    android.content.Context getThemedContext() -> case
    boolean invalidateOptionsMenu() -> char
    void onConfigurationChanged(android.content.res.Configuration) -> do
    boolean onKeyShortcut(int,android.view.KeyEvent) -> do
    boolean onMenuKeyEvent(android.view.KeyEvent) -> do
    void setHomeAsUpIndicator(android.graphics.drawable.Drawable) -> do
    void setWindowTitle(java.lang.CharSequence) -> do
    androidx.appcompat.view.ActionMode startActionMode(androidx.appcompat.view.ActionMode$Callback) -> do
    void onDestroy() -> else
    void setDefaultDisplayHomeAsUpEnabled(boolean) -> for
    boolean openOptionsMenu() -> goto
    void dispatchMenuVisibilityChanged(boolean) -> if
    void setHomeActionContentDescription(int) -> if
    void setHomeButtonEnabled(boolean) -> int
    boolean closeOptionsMenu() -> new
    void setShowHideAnimationEnabled(boolean) -> new
    boolean collapseActionView() -> try
androidx.appcompat.app.ActionBar$LayoutParams -> androidx.appcompat.app.do$do:
    int gravity -> do
androidx.appcompat.app.ActionBar$OnMenuVisibilityListener -> androidx.appcompat.app.do$if:
    void onMenuVisibilityChanged(boolean) -> do
androidx.appcompat.app.ActionBar$Tab -> androidx.appcompat.app.do$for:
    java.lang.CharSequence getContentDescription() -> do
    android.graphics.drawable.Drawable getIcon() -> for
    android.view.View getCustomView() -> if
    java.lang.CharSequence getText() -> int
    void select() -> new
androidx.appcompat.app.ActionBarDrawerToggle -> androidx.appcompat.app.if:
    androidx.appcompat.app.ActionBarDrawerToggle$Delegate mActivityImpl -> do
    boolean mDrawerSlideAnimationEnabled -> int
    boolean mDrawerIndicatorEnabled -> new
    android.view.View$OnClickListener mToolbarNavigationClickListener -> case
    androidx.appcompat.graphics.drawable.DrawerArrowDrawable mSlider -> for
    int mCloseDrawerContentDescRes -> byte
    androidx.drawerlayout.widget.DrawerLayout mDrawerLayout -> if
    int mOpenDrawerContentDescRes -> try
    boolean mWarnedForDisplayHomeAsUp -> char
    android.graphics.drawable.Drawable getThemeUpIndicator() -> do
    void onDrawerOpened(android.view.View) -> do
    void onDrawerSlide(android.view.View,float) -> do
    void onDrawerStateChanged(int) -> do
    void setActionBarUpIndicator(android.graphics.drawable.Drawable,int) -> do
    void setPosition(float) -> do
    void toggle() -> for
    void onDrawerClosed(android.view.View) -> if
    void setActionBarDescription(int) -> if
    void syncState() -> if
androidx.appcompat.app.ActionBarDrawerToggle$1 -> androidx.appcompat.app.if$do:
    androidx.appcompat.app.ActionBarDrawerToggle this$0 -> if
androidx.appcompat.app.ActionBarDrawerToggle$Delegate -> androidx.appcompat.app.if$if:
    boolean isNavigationVisible() -> do
    void setActionBarDescription(int) -> do
    void setActionBarUpIndicator(android.graphics.drawable.Drawable,int) -> do
    android.graphics.drawable.Drawable getThemeUpIndicator() -> for
    android.content.Context getActionBarThemedContext() -> if
androidx.appcompat.app.ActionBarDrawerToggle$DelegateProvider -> androidx.appcompat.app.if$for:
    androidx.appcompat.app.ActionBarDrawerToggle$Delegate getDrawerToggleDelegate() -> int
androidx.appcompat.app.ActionBarDrawerToggle$FrameworkActionBarDelegate -> androidx.appcompat.app.if$int:
    android.app.Activity mActivity -> do
    androidx.appcompat.app.ActionBarDrawerToggleHoneycomb$SetIndicatorInfo mSetIndicatorInfo -> if
    boolean isNavigationVisible() -> do
    void setActionBarDescription(int) -> do
    void setActionBarUpIndicator(android.graphics.drawable.Drawable,int) -> do
    android.graphics.drawable.Drawable getThemeUpIndicator() -> for
    android.content.Context getActionBarThemedContext() -> if
androidx.appcompat.app.ActionBarDrawerToggle$ToolbarCompatDelegate -> androidx.appcompat.app.if$new:
    android.graphics.drawable.Drawable mDefaultUpIndicator -> if
    androidx.appcompat.widget.Toolbar mToolbar -> do
    java.lang.CharSequence mDefaultContentDescription -> for
    boolean isNavigationVisible() -> do
    void setActionBarDescription(int) -> do
    void setActionBarUpIndicator(android.graphics.drawable.Drawable,int) -> do
    android.graphics.drawable.Drawable getThemeUpIndicator() -> for
    android.content.Context getActionBarThemedContext() -> if
androidx.appcompat.app.ActionBarDrawerToggleHoneycomb -> androidx.appcompat.app.for:
    int[] THEME_ATTRS -> do
    android.graphics.drawable.Drawable getThemeUpIndicator(android.app.Activity) -> do
    androidx.appcompat.app.ActionBarDrawerToggleHoneycomb$SetIndicatorInfo setActionBarDescription(androidx.appcompat.app.ActionBarDrawerToggleHoneycomb$SetIndicatorInfo,android.app.Activity,int) -> do
    androidx.appcompat.app.ActionBarDrawerToggleHoneycomb$SetIndicatorInfo setActionBarUpIndicator(android.app.Activity,android.graphics.drawable.Drawable,int) -> do
androidx.appcompat.app.ActionBarDrawerToggleHoneycomb$SetIndicatorInfo -> androidx.appcompat.app.for$do:
    android.widget.ImageView upIndicatorView -> for
    java.lang.reflect.Method setHomeActionContentDescription -> if
    java.lang.reflect.Method setHomeAsUpIndicator -> do
androidx.appcompat.app.AlertController -> androidx.appcompat.app.AlertController:
    android.widget.TextView mTitleView -> switch
    android.graphics.drawable.Drawable mButtonPositiveIcon -> const
    android.widget.TextView mMessageView -> throws
    int mViewSpacingBottom -> this
    androidx.appcompat.app.AppCompatDialog mDialog -> if
    android.graphics.drawable.Drawable mButtonNegativeIcon -> super
    androidx.core.widget.NestedScrollView mScrollView -> native
    java.lang.CharSequence mTitle -> new
    boolean mShowTitle -> volatile
    android.widget.Button mButtonPositive -> break
    android.os.Message mButtonNeutralMessage -> double
    java.lang.CharSequence mButtonNegativeText -> float
    int mViewSpacingTop -> goto
    android.view.View mCustomTitleView -> boolean
    int mCheckedItem -> extends
    java.lang.CharSequence mButtonNeutralText -> while
    android.graphics.drawable.Drawable mButtonNeutralIcon -> import
    int mButtonIconDimen -> int
    android.widget.Button mButtonNeutral -> throw
    android.os.Message mButtonPositiveMessage -> class
    int mViewSpacingRight -> long
    java.lang.CharSequence mMessage -> try
    android.widget.ListView mListView -> byte
    int mViewSpacingLeft -> else
    int mListItemLayout -> strictfp
    boolean mViewSpacingSpecified -> void
    android.graphics.drawable.Drawable mIcon -> return
    java.lang.CharSequence mButtonPositiveText -> catch
    int mIconId -> public
    int mSingleChoiceItemLayout -> continue
    android.view.Window mWindow -> for
    android.view.View mView -> case
    int mListLayout -> private
    android.widget.Button mButtonNegative -> final
    int mAlertDialogLayout -> finally
    android.os.Handler mHandler -> protected
    int mButtonPanelSideLayout -> package
    android.content.Context mContext -> do
    android.widget.ImageView mIconView -> static
    int mButtonPanelLayoutHint -> interface
    android.os.Message mButtonNegativeMessage -> short
    int mMultiChoiceItemLayout -> abstract
    int mViewLayoutResId -> char
    android.view.View$OnClickListener mButtonHandler -> transient
    android.widget.ListAdapter mAdapter -> default
    void centerButton(android.widget.Button) -> do
    int getIconAttributeResId(int) -> do
    android.widget.ListView getListView() -> do
    void manageScrollIndicators(android.view.View,android.view.View,android.view.View) -> do
    boolean onKeyDown(int,android.view.KeyEvent) -> do
    android.view.ViewGroup resolvePanel(android.view.View,android.view.View) -> do
    void setButton(int,java.lang.CharSequence,android.content.DialogInterface$OnClickListener,android.os.Message,android.graphics.drawable.Drawable) -> do
    void setCustomTitle(android.view.View) -> do
    void setIcon(android.graphics.drawable.Drawable) -> do
    void setMessage(java.lang.CharSequence) -> do
    void setScrollIndicators(android.view.ViewGroup,android.view.View,int,int) -> do
    void setView(android.view.View,int,int,int,int) -> do
    void setupButtons(android.view.ViewGroup) -> do
    boolean shouldCenterSingleButton(android.content.Context) -> do
    boolean canTextInput(android.view.View) -> for
    int selectContentView() -> for
    void setView(int) -> for
    void setupCustomContent(android.view.ViewGroup) -> for
    void installContent() -> if
    boolean onKeyUp(int,android.view.KeyEvent) -> if
    void setIcon(int) -> if
    void setTitle(java.lang.CharSequence) -> if
    void setView(android.view.View) -> if
    void setupContent(android.view.ViewGroup) -> if
    void setupTitle(android.view.ViewGroup) -> int
    void setupView() -> int
androidx.appcompat.app.AlertController$1 -> androidx.appcompat.app.AlertController$do:
    androidx.appcompat.app.AlertController this$0 -> if
androidx.appcompat.app.AlertController$2 -> androidx.appcompat.app.AlertController$if:
    android.view.View val$top -> do
    android.view.View val$bottom -> if
    void onScrollChange(androidx.core.widget.NestedScrollView,int,int,int,int) -> do
androidx.appcompat.app.AlertController$3 -> androidx.appcompat.app.AlertController$for:
    android.view.View val$bottom -> for
    android.view.View val$top -> if
    androidx.appcompat.app.AlertController this$0 -> int
androidx.appcompat.app.AlertController$4 -> androidx.appcompat.app.AlertController$int:
    android.view.View val$top -> do
    android.view.View val$bottom -> if
androidx.appcompat.app.AlertController$5 -> androidx.appcompat.app.AlertController$new:
    android.view.View val$bottom -> for
    android.view.View val$top -> if
    androidx.appcompat.app.AlertController this$0 -> int
androidx.appcompat.app.AlertController$AlertParams -> androidx.appcompat.app.AlertController$try:
    android.graphics.drawable.Drawable mIcon -> int
    android.widget.AdapterView$OnItemSelectedListener mOnItemSelectedListener -> continue
    android.content.DialogInterface$OnKeyListener mOnKeyListener -> short
    int mViewSpacingRight -> return
    android.content.DialogInterface$OnDismissListener mOnDismissListener -> float
    boolean mIsSingleChoice -> default
    int mViewLayoutResId -> double
    android.content.DialogInterface$OnClickListener mNegativeButtonListener -> void
    java.lang.CharSequence mMessage -> case
    java.lang.CharSequence mNeutralButtonText -> break
    int mCheckedItem -> extends
    android.database.Cursor mCursor -> package
    java.lang.CharSequence mTitle -> try
    android.content.DialogInterface$OnClickListener mOnClickListener -> while
    android.view.LayoutInflater mInflater -> if
    java.lang.CharSequence mNegativeButtonText -> long
    int mViewSpacingTop -> public
    boolean mViewSpacingSpecified -> switch
    java.lang.String mLabelColumn -> private
    android.content.DialogInterface$OnClickListener mPositiveButtonListener -> goto
    java.lang.CharSequence mPositiveButtonText -> char
    java.lang.CharSequence[] mItems -> super
    android.view.View mView -> import
    android.content.DialogInterface$OnMultiChoiceClickListener mOnCheckboxClickListener -> finally
    android.graphics.drawable.Drawable mNeutralButtonIcon -> catch
    boolean[] mCheckedItems -> throws
    android.content.Context mContext -> do
    int mViewSpacingBottom -> static
    boolean mIsMultiChoice -> boolean
    androidx.appcompat.app.AlertController$AlertParams$OnPrepareListViewListener mOnPrepareListViewListener -> strictfp
    int mViewSpacingLeft -> native
    java.lang.String mIsCheckedColumn -> abstract
    android.view.View mCustomTitleView -> byte
    android.widget.ListAdapter mAdapter -> throw
    android.content.DialogInterface$OnCancelListener mOnCancelListener -> final
    android.graphics.drawable.Drawable mNegativeButtonIcon -> this
    int mIconId -> for
    android.graphics.drawable.Drawable mPositiveButtonIcon -> else
    android.content.DialogInterface$OnClickListener mNeutralButtonListener -> class
    int mIconAttrId -> new
    boolean mCancelable -> const
    void apply(androidx.appcompat.app.AlertController) -> do
    void createListView(androidx.appcompat.app.AlertController) -> if
androidx.appcompat.app.AlertController$AlertParams$1 -> androidx.appcompat.app.AlertController$try$do:
    androidx.appcompat.app.AlertController$RecycleListView val$listView -> if
    androidx.appcompat.app.AlertController$AlertParams this$0 -> for
androidx.appcompat.app.AlertController$AlertParams$2 -> androidx.appcompat.app.AlertController$try$if:
    int mLabelIndex -> if
    androidx.appcompat.app.AlertController$AlertParams this$0 -> try
    int mIsCheckedIndex -> for
    androidx.appcompat.app.AlertController val$dialog -> new
    androidx.appcompat.app.AlertController$RecycleListView val$listView -> int
androidx.appcompat.app.AlertController$AlertParams$3 -> androidx.appcompat.app.AlertController$try$for:
    androidx.appcompat.app.AlertController val$dialog -> if
    androidx.appcompat.app.AlertController$AlertParams this$0 -> for
androidx.appcompat.app.AlertController$AlertParams$4 -> androidx.appcompat.app.AlertController$try$int:
    androidx.appcompat.app.AlertController$RecycleListView val$listView -> if
    androidx.appcompat.app.AlertController val$dialog -> for
    androidx.appcompat.app.AlertController$AlertParams this$0 -> int
androidx.appcompat.app.AlertController$AlertParams$OnPrepareListViewListener -> androidx.appcompat.app.AlertController$try$new:
    void onPrepareListView(android.widget.ListView) -> do
androidx.appcompat.app.AlertController$ButtonHandler -> androidx.appcompat.app.AlertController$byte:
    java.lang.ref.WeakReference mDialog -> do
androidx.appcompat.app.AlertController$CheckedItemAdapter -> androidx.appcompat.app.AlertController$case:
androidx.appcompat.app.AlertController$RecycleListView -> androidx.appcompat.app.AlertController$RecycleListView:
    int mPaddingTopNoTitle -> if
    int mPaddingBottomNoButtons -> for
    void setHasDecor(boolean,boolean) -> do
androidx.appcompat.app.AlertDialog -> androidx.appcompat.app.int:
    androidx.appcompat.app.AlertController mAlert -> int
    android.widget.ListView getListView() -> if
    int resolveDialogTheme(android.content.Context,int) -> if
androidx.appcompat.app.AlertDialog$Builder -> androidx.appcompat.app.int$do:
    int mTheme -> if
    androidx.appcompat.app.AlertController$AlertParams P -> do
    androidx.appcompat.app.AlertDialog create() -> do
    androidx.appcompat.app.AlertDialog$Builder setAdapter(android.widget.ListAdapter,android.content.DialogInterface$OnClickListener) -> do
    androidx.appcompat.app.AlertDialog$Builder setCustomTitle(android.view.View) -> do
    androidx.appcompat.app.AlertDialog$Builder setIcon(android.graphics.drawable.Drawable) -> do
    androidx.appcompat.app.AlertDialog$Builder setOnKeyListener(android.content.DialogInterface$OnKeyListener) -> do
    androidx.appcompat.app.AlertDialog$Builder setSingleChoiceItems(android.widget.ListAdapter,int,android.content.DialogInterface$OnClickListener) -> do
    androidx.appcompat.app.AlertDialog$Builder setTitle(java.lang.CharSequence) -> do
    android.content.Context getContext() -> if
androidx.appcompat.app.AppCompatActivity -> androidx.appcompat.app.new:
    androidx.appcompat.app.AppCompatDelegate mDelegate -> class
    android.content.res.Resources mResources -> const
    boolean onSupportNavigateUp() -> break
    void onCreateSupportNavigateUpTaskStack(androidx.core.app.TaskStackBuilder) -> do
    void onSupportActionModeStarted(androidx.appcompat.view.ActionMode) -> do
    androidx.appcompat.view.ActionMode onWindowStartingSupportActionMode(androidx.appcompat.view.ActionMode$Callback) -> do
    boolean performMenuItemShortcut(int,android.view.KeyEvent) -> do
    void setSupportActionBar(androidx.appcompat.widget.Toolbar) -> do
    void supportNavigateUpTo(android.content.Intent) -> do
    void supportInvalidateOptionsMenu() -> else
    void onNightModeChanged(int) -> if
    void onPrepareSupportNavigateUpTaskStack(androidx.core.app.TaskStackBuilder) -> if
    void onSupportActionModeFinished(androidx.appcompat.view.ActionMode) -> if
    boolean supportShouldUpRecreateTask(android.content.Intent) -> if
    androidx.appcompat.app.ActionBarDrawerToggle$Delegate getDrawerToggleDelegate() -> int
    androidx.appcompat.app.AppCompatDelegate getDelegate() -> long
    androidx.appcompat.app.ActionBar getSupportActionBar() -> this
    android.content.Intent getSupportParentActivityIntent() -> try
    void onSupportContentChanged() -> void
androidx.appcompat.app.AppCompatCallback -> androidx.appcompat.app.try:
    void onSupportActionModeStarted(androidx.appcompat.view.ActionMode) -> do
    androidx.appcompat.view.ActionMode onWindowStartingSupportActionMode(androidx.appcompat.view.ActionMode$Callback) -> do
    void onSupportActionModeFinished(androidx.appcompat.view.ActionMode) -> if
androidx.appcompat.app.AppCompatDelegate -> androidx.appcompat.app.byte:
    int sDefaultNightMode -> if
    androidx.collection.ArraySet sActiveDelegates -> for
    java.lang.Object sActiveDelegatesLock -> int
    void onDestroy() -> byte
    void onPostResume() -> case
    void onStart() -> char
    void addContentView(android.view.View,android.view.ViewGroup$LayoutParams) -> do
    void attachBaseContext(android.content.Context) -> do
    androidx.appcompat.app.AppCompatDelegate create(android.app.Activity,androidx.appcompat.app.AppCompatCallback) -> do
    androidx.appcompat.app.AppCompatDelegate create(android.app.Dialog,androidx.appcompat.app.AppCompatCallback) -> do
    android.view.View findViewById(int) -> do
    androidx.appcompat.app.ActionBarDrawerToggle$Delegate getDrawerToggleDelegate() -> do
    void markStarted(androidx.appcompat.app.AppCompatDelegate) -> do
    void onConfigurationChanged(android.content.res.Configuration) -> do
    void onCreate(android.os.Bundle) -> do
    void setContentView(android.view.View) -> do
    void setSupportActionBar(androidx.appcompat.widget.Toolbar) -> do
    void setTitle(java.lang.CharSequence) -> do
    void onStop() -> else
    android.view.MenuInflater getMenuInflater() -> for
    void onSaveInstanceState(android.os.Bundle) -> for
    void removeDelegateFromActives(androidx.appcompat.app.AppCompatDelegate) -> for
    void setContentView(int) -> for
    int getDefaultNightMode() -> goto
    int getLocalNightMode() -> if
    void markStopped(androidx.appcompat.app.AppCompatDelegate) -> if
    void onPostCreate(android.os.Bundle) -> if
    boolean requestWindowFeature(int) -> if
    void setContentView(android.view.View,android.view.ViewGroup$LayoutParams) -> if
    androidx.appcompat.app.ActionBar getSupportActionBar() -> int
    void setTheme(int) -> int
    void installViewFactory() -> new
    void invalidateOptionsMenu() -> try
androidx.appcompat.app.AppCompatDelegateImpl -> androidx.appcompat.app.case:
    android.graphics.Rect mTempRect2 -> ʾ
    boolean mStarted -> abstract
    boolean mFeatureProgress -> import
    boolean mHasActionBar -> public
    androidx.appcompat.view.ActionMode mActionMode -> catch
    androidx.appcompat.widget.DecorContentParent mDecorContentParent -> this
    boolean mFeatureIndeterminateProgress -> native
    int[] sWindowBackgroundStyleable -> ˉ
    androidx.appcompat.widget.ActionBarContextView mActionModeView -> class
    android.view.Window mWindow -> byte
    androidx.appcompat.app.AppCompatCallback mAppCompatCallback -> char
    androidx.appcompat.app.AppCompatDelegateImpl$PanelMenuPresenterCallback mPanelMenuPresenterCallback -> break
    java.util.Map sLocalNightModes -> ˆ
    boolean mActivityHandlesUiMode -> interface
    boolean mIsFloating -> switch
    androidx.appcompat.app.AppCompatDelegateImpl$ActionMenuPresenterCallback mActionMenuPresenterCallback -> void
    android.widget.TextView mTitleView -> while
    boolean mHandleNativeActionModes -> short
    boolean mOverlayActionBar -> return
    boolean mIsDestroyed -> continue
    boolean mSubDecorInstalled -> super
    android.view.MenuInflater mMenuInflater -> goto
    androidx.appcompat.app.ActionBar mActionBar -> else
    androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState mPreparedPanel -> extends
    boolean mEnableDefaultActionBarUp -> ʼ
    android.widget.PopupWindow mActionModePopup -> const
    int mThemeResId -> volatile
    boolean IS_PRE_LOLLIPOP -> ˈ
    boolean mCreated -> private
    boolean mOverlayActionMode -> static
    java.lang.Runnable mShowActionModePopup -> final
    boolean mBaseContextAttached -> package
    boolean sInstalledExceptionHandler -> ˊ
    boolean mLongPressBackDown -> finally
    int mInvalidatePanelMenuFeatures -> synchronized
    androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState[] mPanels -> default
    android.view.View mStatusGuard -> double
    android.content.Context mContext -> try
    boolean mActivityHandlesUiModeChecked -> protected
    androidx.appcompat.app.AppCompatViewInflater mAppCompatViewInflater -> ʿ
    int mLocalNightMode -> strictfp
    java.lang.CharSequence mTitle -> long
    boolean mWindowNoTitle -> throws
    android.graphics.Rect mTempRect1 -> ʽ
    androidx.core.view.ViewPropertyAnimatorCompat mFadeAnim -> float
    boolean sAlwaysOverrideConfiguration -> ˋ
    androidx.appcompat.app.AppCompatDelegateImpl$AppCompatWindowCallback mAppCompatWindowCallback -> case
    java.lang.Runnable mInvalidatePanelMenuRunnable -> ʻ
    androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager mAutoBatteryNightModeManager -> implements
    boolean mClosingActionMenu -> boolean
    boolean mInvalidatePanelMenuPosted -> instanceof
    java.lang.Object mHost -> new
    androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager mAutoTimeNightModeManager -> transient
    android.view.ViewGroup mSubDecor -> throw
    androidx.appcompat.app.AppCompatActivity tryUnwrapContext() -> boolean
    android.content.Context getActionBarThemedContext() -> break
    int mapNightMode(int) -> byte
    void onDestroy() -> byte
    void onMenuOpened(int) -> case
    void onPostResume() -> case
    androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager getAutoTimeNightModeManager() -> catch
    void onPanelClosed(int) -> char
    void onStart() -> char
    java.lang.CharSequence getTitle() -> class
    android.view.Window$Callback getWindowCallback() -> const
    void addContentView(android.view.View,android.view.ViewGroup$LayoutParams) -> do
    boolean applyDayNight(boolean) -> do
    void attachBaseContext(android.content.Context) -> do
    void attachToWindow(android.view.Window) -> do
    void callOnPanelClosed(int,androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState,android.view.Menu) -> do
    void closePanel(androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState,boolean) -> do
    android.view.View createView(android.view.View,java.lang.String,android.content.Context,android.util.AttributeSet) -> do
    boolean dispatchKeyEvent(android.view.KeyEvent) -> do
    androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState findMenuPanel(android.view.Menu) -> do
    android.view.View findViewById(int) -> do
    androidx.appcompat.app.ActionBarDrawerToggle$Delegate getDrawerToggleDelegate() -> do
    androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState getPanelState(int,boolean) -> do
    boolean initializePanelContent(androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState) -> do
    void onConfigurationChanged(android.content.res.Configuration) -> do
    void onCreate(android.os.Bundle) -> do
    boolean onKeyDown(int,android.view.KeyEvent) -> do
    boolean onMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onMenuModeChange(androidx.appcompat.view.menu.MenuBuilder) -> do
    void onSubDecorInstalled(android.view.ViewGroup) -> do
    void openPanel(androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState,android.view.KeyEvent) -> do
    boolean performPanelShortcut(androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState,int,android.view.KeyEvent,int) -> do
    void reopenMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    void setContentView(android.view.View) -> do
    void setSupportActionBar(androidx.appcompat.widget.Toolbar) -> do
    void setTitle(java.lang.CharSequence) -> do
    boolean shouldInheritContext(android.view.ViewParent) -> do
    androidx.appcompat.view.ActionMode startSupportActionMode(androidx.appcompat.view.ActionMode$Callback) -> do
    void cleanupAutoManagers() -> double
    void onStop() -> else
    int updateStatusGuard(int) -> else
    boolean isHandleNativeActionModesEnabled() -> final
    boolean onBackPressed() -> float
    android.view.MenuInflater getMenuInflater() -> for
    boolean initializePanelMenu(androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState) -> for
    boolean onKeyUp(int,android.view.KeyEvent) -> for
    void onSaveInstanceState(android.os.Bundle) -> for
    void setContentView(int) -> for
    void updateResourcesConfigurationForNightMode(int,boolean) -> for
    void invalidatePanelMenu(int) -> goto
    void checkCloseActionMenu(androidx.appcompat.view.menu.MenuBuilder) -> if
    int getLocalNightMode() -> if
    boolean initializePanelDecor(androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState) -> if
    boolean onKeyShortcut(int,android.view.KeyEvent) -> if
    void onPostCreate(android.os.Bundle) -> if
    boolean preparePanel(androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState,android.view.KeyEvent) -> if
    boolean requestWindowFeature(int) -> if
    void setContentView(android.view.View,android.view.ViewGroup$LayoutParams) -> if
    androidx.appcompat.view.ActionMode startSupportActionModeFromWindow(androidx.appcompat.view.ActionMode$Callback) -> if
    boolean updateForNightMode(int,boolean) -> if
    android.view.ViewGroup createSubDecor() -> import
    androidx.appcompat.app.ActionBar getSupportActionBar() -> int
    boolean onKeyDownPanel(int,android.view.KeyEvent) -> int
    void setTheme(int) -> int
    boolean applyDayNight() -> long
    int sanitizeWindowFeatureId(int) -> long
    void ensureSubDecor() -> native
    void closePanel(int) -> new
    void installViewFactory() -> new
    boolean onKeyUpPanel(int,android.view.KeyEvent) -> new
    void ensureWindow() -> public
    androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager getAutoBatteryNightModeManager() -> return
    androidx.appcompat.app.ActionBar peekSupportActionBar() -> short
    void initWindowDecorActionBar() -> static
    boolean shouldAnimateActionModeView() -> super
    boolean isActivityManifestHandlingUiMode() -> switch
    void dismissPopups() -> this
    void applyFixedSizeWindow() -> throw
    void throwFeatureRequestIfSubDecorInstalled() -> throws
    void doInvalidatePanelMenu(int) -> try
    void invalidateOptionsMenu() -> try
    void endOnGoingFadeAnimation() -> void
    int calculateNightMode() -> while
androidx.appcompat.app.AppCompatDelegateImpl$1 -> androidx.appcompat.app.case$do:
    java.lang.Thread$UncaughtExceptionHandler val$defHandler -> do
    boolean shouldWrapException(java.lang.Throwable) -> do
androidx.appcompat.app.AppCompatDelegateImpl$2 -> androidx.appcompat.app.case$if:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> if
androidx.appcompat.app.AppCompatDelegateImpl$3 -> androidx.appcompat.app.case$for:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> do
    androidx.core.view.WindowInsetsCompat onApplyWindowInsets(android.view.View,androidx.core.view.WindowInsetsCompat) -> do
androidx.appcompat.app.AppCompatDelegateImpl$4 -> androidx.appcompat.app.case$int:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> do
    void onFitSystemWindows(android.graphics.Rect) -> do
androidx.appcompat.app.AppCompatDelegateImpl$5 -> androidx.appcompat.app.case$new:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> do
    void onAttachedFromWindow() -> do
androidx.appcompat.app.AppCompatDelegateImpl$6 -> androidx.appcompat.app.case$try:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> if
androidx.appcompat.app.AppCompatDelegateImpl$6$1 -> androidx.appcompat.app.case$try$do:
    androidx.appcompat.app.AppCompatDelegateImpl$6 this$1 -> do
    void onAnimationEnd(android.view.View) -> do
    void onAnimationStart(android.view.View) -> if
androidx.appcompat.app.AppCompatDelegateImpl$7 -> androidx.appcompat.app.case$byte:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> do
    void onAnimationEnd(android.view.View) -> do
    void onAnimationStart(android.view.View) -> if
androidx.appcompat.app.AppCompatDelegateImpl$ActionBarDrawableToggleImpl -> androidx.appcompat.app.case$case:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> do
    boolean isNavigationVisible() -> do
    void setActionBarDescription(int) -> do
    void setActionBarUpIndicator(android.graphics.drawable.Drawable,int) -> do
    android.graphics.drawable.Drawable getThemeUpIndicator() -> for
    android.content.Context getActionBarThemedContext() -> if
androidx.appcompat.app.AppCompatDelegateImpl$ActionMenuPresenterCallback -> androidx.appcompat.app.case$char:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> if
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    boolean onOpenSubMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.app.AppCompatDelegateImpl$ActionModeCallbackWrapperV9 -> androidx.appcompat.app.case$else:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> if
    androidx.appcompat.view.ActionMode$Callback mWrapped -> do
    boolean onActionItemClicked(androidx.appcompat.view.ActionMode,android.view.MenuItem) -> do
    void onDestroyActionMode(androidx.appcompat.view.ActionMode) -> do
    boolean onPrepareActionMode(androidx.appcompat.view.ActionMode,android.view.Menu) -> do
    boolean onCreateActionMode(androidx.appcompat.view.ActionMode,android.view.Menu) -> if
androidx.appcompat.app.AppCompatDelegateImpl$ActionModeCallbackWrapperV9$1 -> androidx.appcompat.app.case$else$do:
    androidx.appcompat.app.AppCompatDelegateImpl$ActionModeCallbackWrapperV9 this$1 -> do
    void onAnimationEnd(android.view.View) -> do
androidx.appcompat.app.AppCompatDelegateImpl$AppCompatWindowCallback -> androidx.appcompat.app.case$goto:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> for
    android.view.ActionMode startAsSupportActionMode(android.view.ActionMode$Callback) -> do
androidx.appcompat.app.AppCompatDelegateImpl$AutoBatteryNightModeManager -> androidx.appcompat.app.case$long:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> int
    android.os.PowerManager mPowerManager -> for
    int getApplyableNightMode() -> for
    android.content.IntentFilter createIntentFilterForBroadcastReceiver() -> if
    void onChange() -> int
androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager -> androidx.appcompat.app.case$this:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> if
    android.content.BroadcastReceiver mReceiver -> do
    void cleanup() -> do
    int getApplyableNightMode() -> for
    android.content.IntentFilter createIntentFilterForBroadcastReceiver() -> if
    void onChange() -> int
    void setup() -> new
androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager$1 -> androidx.appcompat.app.case$this$do:
    androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager this$1 -> do
androidx.appcompat.app.AppCompatDelegateImpl$AutoTimeNightModeManager -> androidx.appcompat.app.case$void:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> int
    androidx.appcompat.app.TwilightManager mTwilightManager -> for
    int getApplyableNightMode() -> for
    android.content.IntentFilter createIntentFilterForBroadcastReceiver() -> if
    void onChange() -> int
androidx.appcompat.app.AppCompatDelegateImpl$ListMenuDecorView -> androidx.appcompat.app.case$break:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> else
    boolean isOutOfBounds(int,int) -> do
androidx.appcompat.app.AppCompatDelegateImpl$PanelFeatureState -> androidx.appcompat.app.case$catch:
    android.view.View createdPanelView -> char
    boolean isPrepared -> this
    boolean isOpen -> break
    int featureId -> do
    android.view.View shownPanelView -> case
    androidx.appcompat.view.menu.MenuBuilder menu -> else
    int windowAnimations -> try
    android.os.Bundle frozenActionViewState -> final
    int background -> if
    int x -> int
    android.view.ViewGroup decorView -> byte
    androidx.appcompat.view.menu.ListMenuPresenter listMenuPresenter -> goto
    boolean qwertyMode -> catch
    int gravity -> for
    int y -> new
    boolean isHandled -> void
    boolean refreshDecorView -> class
    boolean refreshMenuContent -> const
    android.content.Context listPresenterContext -> long
    androidx.appcompat.view.menu.MenuView getListMenuView(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    boolean hasPanelItems() -> do
    void setMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
    void setStyle(android.content.Context) -> do
androidx.appcompat.app.AppCompatDelegateImpl$PanelMenuPresenterCallback -> androidx.appcompat.app.case$class:
    androidx.appcompat.app.AppCompatDelegateImpl this$0 -> if
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    boolean onOpenSubMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.app.AppCompatDialog -> androidx.appcompat.app.char:
    androidx.core.view.KeyEventDispatcher$Component mKeyDispatcher -> for
    androidx.appcompat.app.AppCompatDelegate mDelegate -> if
    androidx.appcompat.app.AppCompatDelegate getDelegate() -> do
    int getThemeResId(android.content.Context,int) -> do
    void onSupportActionModeStarted(androidx.appcompat.view.ActionMode) -> do
    androidx.appcompat.view.ActionMode onWindowStartingSupportActionMode(androidx.appcompat.view.ActionMode$Callback) -> do
    boolean superDispatchKeyEvent(android.view.KeyEvent) -> do
    boolean supportRequestWindowFeature(int) -> do
    void onSupportActionModeFinished(androidx.appcompat.view.ActionMode) -> if
androidx.appcompat.app.AppCompatDialog$1 -> androidx.appcompat.app.char$do:
    androidx.appcompat.app.AppCompatDialog this$0 -> if
    boolean superDispatchKeyEvent(android.view.KeyEvent) -> do
androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener -> androidx.appcompat.app.AppCompatViewInflater$do:
    java.lang.String mMethodName -> for
    android.view.View mHostView -> if
    android.content.Context mResolvedContext -> new
    java.lang.reflect.Method mResolvedMethod -> int
    void resolveMethod(android.content.Context,java.lang.String) -> do
androidx.appcompat.app.ResourcesFlusher -> androidx.appcompat.app.else:
    java.lang.reflect.Field sDrawableCacheField -> do
    boolean sResourcesImplFieldFetched -> case
    java.lang.Class sThemedResourceCacheClazz -> for
    boolean sThemedResourceCacheClazzFetched -> int
    boolean sDrawableCacheFieldFetched -> if
    java.lang.reflect.Field sThemedResourceCache_mUnthemedEntriesField -> new
    java.lang.reflect.Field sResourcesImplField -> byte
    boolean sThemedResourceCache_mUnthemedEntriesFieldFetched -> try
    void flush(android.content.res.Resources) -> do
    void flushThemedResourcesCache(java.lang.Object) -> do
    void flushMarshmallows(android.content.res.Resources) -> for
    void flushLollipops(android.content.res.Resources) -> if
    void flushNougats(android.content.res.Resources) -> int
androidx.appcompat.app.ToolbarActionBar -> androidx.appcompat.app.goto:
    androidx.appcompat.widget.Toolbar$OnMenuItemClickListener mMenuClicker -> case
    java.util.ArrayList mMenuVisibilityListeners -> try
    java.lang.Runnable mMenuInvalidator -> byte
    boolean mMenuCallbackSet -> int
    androidx.appcompat.widget.DecorToolbar mDecorToolbar -> do
    boolean mToolbarMenuPrepared -> if
    android.view.Window$Callback mWindowCallback -> for
    boolean mLastMenuVisibility -> new
    int getDisplayOptions() -> byte
    android.content.Context getThemedContext() -> case
    boolean invalidateOptionsMenu() -> char
    void onConfigurationChanged(android.content.res.Configuration) -> do
    boolean onKeyShortcut(int,android.view.KeyEvent) -> do
    boolean onMenuKeyEvent(android.view.KeyEvent) -> do
    void setHomeAsUpIndicator(android.graphics.drawable.Drawable) -> do
    void setWindowTitle(java.lang.CharSequence) -> do
    void onDestroy() -> else
    void setDefaultDisplayHomeAsUpEnabled(boolean) -> for
    boolean openOptionsMenu() -> goto
    void dispatchMenuVisibilityChanged(boolean) -> if
    void setHomeActionContentDescription(int) -> if
    void setHomeButtonEnabled(boolean) -> int
    android.view.Window$Callback getWrappedWindowCallback() -> long
    boolean closeOptionsMenu() -> new
    void setShowHideAnimationEnabled(boolean) -> new
    void populateOptionsMenu() -> this
    boolean collapseActionView() -> try
    android.view.Menu getMenu() -> void
androidx.appcompat.app.ToolbarActionBar$1 -> androidx.appcompat.app.goto$do:
    androidx.appcompat.app.ToolbarActionBar this$0 -> if
androidx.appcompat.app.ToolbarActionBar$2 -> androidx.appcompat.app.goto$if:
    androidx.appcompat.app.ToolbarActionBar this$0 -> do
androidx.appcompat.app.ToolbarActionBar$ActionMenuPresenterCallback -> androidx.appcompat.app.goto$for:
    boolean mClosingActionMenu -> if
    androidx.appcompat.app.ToolbarActionBar this$0 -> for
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    boolean onOpenSubMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.app.ToolbarActionBar$MenuBuilderCallback -> androidx.appcompat.app.goto$int:
    androidx.appcompat.app.ToolbarActionBar this$0 -> if
    boolean onMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onMenuModeChange(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.app.ToolbarActionBar$ToolbarCallbackWrapper -> androidx.appcompat.app.goto$new:
    androidx.appcompat.app.ToolbarActionBar this$0 -> for
androidx.appcompat.app.TwilightCalculator -> androidx.appcompat.app.long:
    androidx.appcompat.app.TwilightCalculator sInstance -> int
    long sunset -> do
    int state -> for
    long sunrise -> if
    void calculateTwilight(long,double,double) -> do
    androidx.appcompat.app.TwilightCalculator getInstance() -> do
androidx.appcompat.app.TwilightManager -> androidx.appcompat.app.this:
    android.location.LocationManager mLocationManager -> if
    androidx.appcompat.app.TwilightManager$TwilightState mTwilightState -> for
    android.content.Context mContext -> do
    androidx.appcompat.app.TwilightManager sInstance -> int
    androidx.appcompat.app.TwilightManager getInstance(android.content.Context) -> do
    android.location.Location getLastKnownLocationForProvider(java.lang.String) -> do
    boolean isNight() -> do
    void updateState(android.location.Location) -> do
    boolean isStateValid() -> for
    android.location.Location getLastKnownLocation() -> if
androidx.appcompat.app.TwilightManager$TwilightState -> androidx.appcompat.app.this$do:
    boolean isNight -> do
    long todaySunrise -> for
    long nextUpdate -> try
    long todaySunset -> int
    long tomorrowSunrise -> new
    long yesterdaySunset -> if
androidx.appcompat.app.WindowDecorActionBar -> androidx.appcompat.app.void:
    androidx.appcompat.widget.ActionBarContextView mContextView -> try
    boolean mHideOnContentScroll -> while
    android.content.Context mThemedContext -> if
    boolean mShowingForMode -> float
    boolean mHasEmbeddedTabs -> break
    java.util.ArrayList mMenuVisibilityListeners -> void
    androidx.appcompat.widget.ActionBarOverlayLayout mOverlayLayout -> for
    androidx.appcompat.view.ViewPropertyAnimatorCompatSet mCurrentShowAnim -> super
    androidx.appcompat.view.ActionMode mDeferredDestroyActionMode -> goto
    androidx.core.view.ViewPropertyAnimatorUpdateListener mUpdateListener -> native
    androidx.appcompat.widget.DecorToolbar mDecorToolbar -> new
    boolean mHiddenBySystem -> final
    boolean mContentAnimations -> class
    androidx.appcompat.widget.ScrollingTabContainerView mTabScrollView -> case
    android.view.animation.Interpolator sShowInterpolator -> return
    android.view.animation.Interpolator sHideInterpolator -> public
    boolean mLastMenuVisibility -> this
    int mCurWindowVisibility -> catch
    boolean mNowShowing -> short
    androidx.core.view.ViewPropertyAnimatorListener mShowListener -> import
    android.content.Context mContext -> do
    androidx.core.view.ViewPropertyAnimatorListener mHideListener -> double
    boolean mDisplayHomeAsUpSet -> char
    android.view.View mContentView -> byte
    androidx.appcompat.app.WindowDecorActionBar$ActionModeImpl mActionMode -> else
    androidx.appcompat.widget.ActionBarContainer mContainerView -> int
    androidx.appcompat.view.ActionMode$Callback mDeferredModeDestroyCallback -> long
    boolean mHiddenByApp -> const
    boolean mShowHideAnimationEnabled -> throw
    boolean shouldAnimateContextView() -> break
    void doHide(boolean) -> byte
    int getDisplayOptions() -> byte
    void doShow(boolean) -> case
    android.content.Context getThemedContext() -> case
    void showForActionMode() -> catch
    void setDisplayHomeAsUpEnabled(boolean) -> char
    boolean checkShowingFlags(boolean,boolean,boolean) -> do
    void enableContentAnimations(boolean) -> do
    androidx.appcompat.widget.DecorToolbar getDecorToolbar(android.view.View) -> do
    void onConfigurationChanged(android.content.res.Configuration) -> do
    void onContentScrollStarted() -> do
    boolean onKeyShortcut(int,android.view.KeyEvent) -> do
    void onWindowVisibilityChanged(int) -> do
    void setDisplayOptions(int,int) -> do
    void setElevation(float) -> do
    void setHomeAsUpIndicator(android.graphics.drawable.Drawable) -> do
    void setWindowTitle(java.lang.CharSequence) -> do
    androidx.appcompat.view.ActionMode startActionMode(androidx.appcompat.view.ActionMode$Callback) -> do
    void setHideOnContentScrollEnabled(boolean) -> else
    void setDefaultDisplayHomeAsUpEnabled(boolean) -> for
    void showForSystem() -> for
    void setHasEmbeddedTabs(boolean) -> goto
    void dispatchMenuVisibilityChanged(boolean) -> if
    void hideForSystem() -> if
    void init(android.view.View) -> if
    void setHomeActionContentDescription(int) -> if
    void onContentScrollStopped() -> int
    void setHomeButtonEnabled(boolean) -> int
    void completeDeferredDestroyActionMode() -> long
    void updateVisibility(boolean) -> long
    void setShowHideAnimationEnabled(boolean) -> new
    int getNavigationMode() -> this
    void animateToMode(boolean) -> try
    boolean collapseActionView() -> try
    void hideForActionMode() -> void
androidx.appcompat.app.WindowDecorActionBar$1 -> androidx.appcompat.app.void$do:
    androidx.appcompat.app.WindowDecorActionBar this$0 -> do
    void onAnimationEnd(android.view.View) -> do
androidx.appcompat.app.WindowDecorActionBar$2 -> androidx.appcompat.app.void$if:
    androidx.appcompat.app.WindowDecorActionBar this$0 -> do
    void onAnimationEnd(android.view.View) -> do
androidx.appcompat.app.WindowDecorActionBar$3 -> androidx.appcompat.app.void$for:
    androidx.appcompat.app.WindowDecorActionBar this$0 -> do
    void onAnimationUpdate(android.view.View) -> do
androidx.appcompat.app.WindowDecorActionBar$ActionModeImpl -> androidx.appcompat.app.void$int:
    android.content.Context mActionModeContext -> int
    androidx.appcompat.view.menu.MenuBuilder mMenu -> new
    androidx.appcompat.app.WindowDecorActionBar this$0 -> case
    java.lang.ref.WeakReference mCustomView -> byte
    androidx.appcompat.view.ActionMode$Callback mCallback -> try
    java.lang.CharSequence getTitle() -> byte
    void invalidate() -> char
    void finish() -> do
    boolean onMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onMenuModeChange(androidx.appcompat.view.menu.MenuBuilder) -> do
    void setCustomView(android.view.View) -> do
    void setSubtitle(int) -> do
    void setSubtitle(java.lang.CharSequence) -> do
    void setTitleOptionalHint(boolean) -> do
    boolean isTitleOptional() -> else
    android.view.Menu getMenu() -> for
    boolean dispatchOnCreate() -> goto
    android.view.View getCustomView() -> if
    void setTitle(int) -> if
    void setTitle(java.lang.CharSequence) -> if
    android.view.MenuInflater getMenuInflater() -> int
    java.lang.CharSequence getSubtitle() -> new
androidx.appcompat.content.res.AppCompatResources -> if.do.goto.do.do:
    java.util.WeakHashMap sColorStateCaches -> if
    java.lang.ThreadLocal TL_TYPED_VALUE -> do
    java.lang.Object sColorStateCacheLock -> for
    void addColorStateListToCache(android.content.Context,int,android.content.res.ColorStateList) -> do
    android.content.res.ColorStateList getCachedColorStateList(android.content.Context,int) -> do
    android.util.TypedValue getTypedValue() -> do
    android.graphics.drawable.Drawable getDrawable(android.content.Context,int) -> for
    android.content.res.ColorStateList getColorStateList(android.content.Context,int) -> if
    android.content.res.ColorStateList inflateColorStateList(android.content.Context,int) -> int
    boolean isColorInt(android.content.Context,int) -> new
androidx.appcompat.content.res.AppCompatResources$ColorStateListCacheEntry -> if.do.goto.do.do$do:
    android.content.res.Configuration configuration -> if
    android.content.res.ColorStateList value -> do
androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat -> if.do.long.do.do:
    androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$AnimatedStateListState mState -> catch
    androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$Transition mTransition -> class
    int mTransitionFromIndex -> final
    boolean mMutated -> float
    int mTransitionToIndex -> const
    androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$AnimatedStateListState cloneConstantState() -> do
    androidx.appcompat.graphics.drawable.DrawableContainer$DrawableContainerState cloneConstantState() -> do
    androidx.appcompat.graphics.drawable.StateListDrawable$StateListState cloneConstantState() -> do
    void inflate(android.content.Context,android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
    void setConstantState(androidx.appcompat.graphics.drawable.DrawableContainer$DrawableContainerState) -> do
    void updateStateFromTypedArray(android.content.res.TypedArray) -> do
    void inflateChildElements(android.content.Context,android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> for
    androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat createFromXmlInner(android.content.Context,android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> if
    boolean selectTransition(int) -> if
    void init() -> int
    int parseItem(android.content.Context,android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> int
    int parseTransition(android.content.Context,android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> new
androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$1 -> if.do.long.do.do$do:
androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$AnimatableTransition -> if.do.long.do.do$if:
    android.graphics.drawable.Animatable mA -> do
    void start() -> for
    void stop() -> int
androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$AnimatedStateListState -> if.do.long.do.do$for:
    androidx.collection.SparseArrayCompat mStateIds -> private
    androidx.collection.LongSparseArray mTransitions -> package
    int addStateSet(int[],android.graphics.drawable.Drawable,int) -> do
    int addTransition(int,int,android.graphics.drawable.Drawable,boolean) -> do
    int indexOfTransition(int,int) -> for
    int indexOfKeyframe(int[]) -> if
    int getKeyframeIdAt(int) -> int
    boolean isTransitionReversed(int,int) -> int
    boolean transitionHasReversibleFlag(int,int) -> new
    void mutate() -> this
    long generateTransitionKey(int,int) -> try
androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$AnimatedVectorDrawableTransition -> if.do.long.do.do$int:
    androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat mAvd -> do
    void start() -> for
    void stop() -> int
androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$AnimationDrawableTransition -> if.do.long.do.do$new:
    boolean mHasReversibleFlag -> if
    android.animation.ObjectAnimator mAnim -> do
    boolean canReverse() -> do
    void start() -> for
    void reverse() -> if
    void stop() -> int
androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$FrameInterpolator -> if.do.long.do.do$try:
    int mFrames -> if
    int mTotalDuration -> for
    int[] mFrameTimes -> do
    int getTotalDuration() -> do
    int updateFrames(android.graphics.drawable.AnimationDrawable,boolean) -> do
androidx.appcompat.graphics.drawable.AnimatedStateListDrawableCompat$Transition -> if.do.long.do.do$byte:
    boolean canReverse() -> do
    void start() -> for
    void reverse() -> if
    void stop() -> int
androidx.appcompat.graphics.drawable.DrawableContainer -> if.do.long.do.if:
    android.graphics.drawable.Drawable mLastDrawable -> new
    androidx.appcompat.graphics.drawable.DrawableContainer$BlockInvalidateCallback mBlockInvalidateCallback -> this
    androidx.appcompat.graphics.drawable.DrawableContainer$DrawableContainerState mDrawableContainerState -> if
    android.graphics.drawable.Drawable mCurrDrawable -> int
    android.graphics.Rect mHotspotBounds -> for
    java.lang.Runnable mAnimationRunnable -> else
    long mExitAnimationEnd -> long
    boolean mHasAlpha -> byte
    long mEnterAnimationEnd -> goto
    int mAlpha -> try
    int mCurIndex -> case
    boolean mMutated -> char
    void animate(boolean) -> do
    androidx.appcompat.graphics.drawable.DrawableContainer$DrawableContainerState cloneConstantState() -> do
    void initializeDrawableForDisplay(android.graphics.drawable.Drawable) -> do
    int resolveDensity(android.content.res.Resources,int) -> do
    boolean selectDrawable(int) -> do
    void setConstantState(androidx.appcompat.graphics.drawable.DrawableContainer$DrawableContainerState) -> do
    void updateDensity(android.content.res.Resources) -> do
    boolean needsMirroring() -> for
    int getCurrentIndex() -> if
androidx.appcompat.graphics.drawable.DrawableContainer$1 -> if.do.long.do.if$do:
    androidx.appcompat.graphics.drawable.DrawableContainer this$0 -> if
androidx.appcompat.graphics.drawable.DrawableContainer$BlockInvalidateCallback -> if.do.long.do.if$if:
    android.graphics.drawable.Drawable$Callback mCallback -> if
    android.graphics.drawable.Drawable$Callback unwrap() -> do
    androidx.appcompat.graphics.drawable.DrawableContainer$BlockInvalidateCallback wrap(android.graphics.drawable.Drawable$Callback) -> do
androidx.appcompat.graphics.drawable.DrawableContainer$DrawableContainerState -> if.do.long.do.if$for:
    boolean mDither -> while
    android.util.SparseArray mDrawableFutures -> try
    android.content.res.ColorStateList mTintList -> throws
    boolean mCheckedStateful -> float
    boolean mHasTintList -> default
    android.graphics.drawable.Drawable[] mDrawables -> byte
    android.graphics.ColorFilter mColorFilter -> static
    androidx.appcompat.graphics.drawable.DrawableContainer mOwner -> do
    int mChangingConfigurations -> int
    boolean mCheckedPadding -> else
    int mExitFadeDuration -> public
    int mNumChildren -> case
    android.graphics.PorterDuff$Mode mTintMode -> boolean
    int mConstantHeight -> break
    boolean mHasColorFilter -> switch
    boolean mCheckedConstantSize -> this
    boolean mMutated -> double
    int mLayoutDirection -> import
    int mConstantMinimumHeight -> class
    int mConstantMinimumWidth -> catch
    boolean mStateful -> short
    boolean mAutoMirrored -> return
    boolean mVariablePadding -> char
    android.graphics.Rect mConstantPadding -> goto
    boolean mConstantSize -> long
    int mConstantWidth -> void
    boolean mCheckedConstantState -> super
    int mEnterFadeDuration -> native
    int mOpacity -> final
    int mDensity -> for
    android.content.res.Resources mSourceRes -> if
    int mChildrenChangingConfigurations -> new
    boolean mHasTintMode -> extends
    boolean mCheckedOpacity -> const
    boolean mCanConstantState -> throw
    int getConstantMinimumWidth() -> byte
    android.graphics.Rect getConstantPadding() -> case
    int getConstantWidth() -> char
    int addChild(android.graphics.drawable.Drawable) -> do
    void applyTheme(android.content.res.Resources$Theme) -> do
    boolean canConstantState() -> do
    android.graphics.drawable.Drawable getChild(int) -> do
    void growArray(int,int) -> do
    void setConstantSize(boolean) -> do
    void updateDensity(android.content.res.Resources) -> do
    int getOpacity() -> else
    int getCapacity() -> for
    void setExitFadeDuration(int) -> for
    void invalidateCache() -> goto
    void computeConstantSize() -> if
    android.graphics.drawable.Drawable prepareDrawable(android.graphics.drawable.Drawable) -> if
    void setEnterFadeDuration(int) -> if
    boolean setLayoutDirection(int,int) -> if
    void setVariablePadding(boolean) -> if
    int getChildCount() -> int
    boolean isConstantSize() -> long
    int getConstantHeight() -> new
    void mutate() -> this
    int getConstantMinimumHeight() -> try
    void createAllFutures() -> void
androidx.appcompat.graphics.drawable.DrawableWrapper -> if.do.long.do.for:
    android.graphics.drawable.Drawable mDrawable -> if
    android.graphics.drawable.Drawable getWrappedDrawable() -> do
    void setWrappedDrawable(android.graphics.drawable.Drawable) -> do
androidx.appcompat.graphics.drawable.DrawerArrowDrawable -> if.do.long.do.int:
    android.graphics.Path mPath -> byte
    float mArrowShaftLength -> int
    android.graphics.Paint mPaint -> do
    boolean mVerticalMirror -> char
    float mArrowHeadLength -> if
    float mProgress -> else
    float mBarLength -> for
    int mDirection -> long
    float mMaxCutForBarSize -> goto
    boolean mSpin -> try
    float ARROW_HEAD_ANGLE -> this
    int mSize -> case
    float mBarGap -> new
    float lerp(float,float,float) -> do
    void setBarThickness(float) -> do
    void setColor(int) -> do
    void setSpinEnabled(boolean) -> do
    void setProgress(float) -> for
    void setGapSize(float) -> if
    void setVerticalMirror(boolean) -> if
androidx.appcompat.graphics.drawable.StateListDrawable -> if.do.long.do.new:
    boolean mMutated -> break
    androidx.appcompat.graphics.drawable.StateListDrawable$StateListState mStateListState -> void
    androidx.appcompat.graphics.drawable.DrawableContainer$DrawableContainerState cloneConstantState() -> do
    androidx.appcompat.graphics.drawable.StateListDrawable$StateListState cloneConstantState() -> do
    int[] extractStateSet(android.util.AttributeSet) -> do
    void setConstantState(androidx.appcompat.graphics.drawable.DrawableContainer$DrawableContainerState) -> do
androidx.appcompat.graphics.drawable.StateListDrawable$StateListState -> if.do.long.do.new$do:
    int[][] mStateSets -> finally
    int addStateSet(int[],android.graphics.drawable.Drawable) -> do
    void growArray(int,int) -> do
    int indexOfStateSet(int[]) -> do
    void mutate() -> this
androidx.appcompat.resources.R$drawable -> if.do.this.do:
androidx.appcompat.resources.R$styleable -> if.do.this.if:
androidx.appcompat.view.ActionBarPolicy -> if.do.void.do:
    android.content.Context mContext -> do
    boolean showsOverflowMenuButton() -> byte
    boolean enableHomeButtonByDefault() -> do
    androidx.appcompat.view.ActionBarPolicy get(android.content.Context) -> do
    int getMaxActionButtons() -> for
    int getEmbeddedMenuWidthLimit() -> if
    int getStackedTabMaxWidth() -> int
    int getTabContainerHeight() -> new
    boolean hasEmbeddedTabs() -> try
androidx.appcompat.view.ActionMode -> if.do.void.if:
    boolean mTitleOptionalHint -> for
    java.lang.Object mTag -> if
    java.lang.CharSequence getTitle() -> byte
    boolean getTitleOptionalHint() -> case
    void invalidate() -> char
    void finish() -> do
    void setCustomView(android.view.View) -> do
    void setSubtitle(int) -> do
    void setSubtitle(java.lang.CharSequence) -> do
    void setTag(java.lang.Object) -> do
    void setTitleOptionalHint(boolean) -> do
    boolean isTitleOptional() -> else
    android.view.Menu getMenu() -> for
    android.view.View getCustomView() -> if
    void setTitle(int) -> if
    void setTitle(java.lang.CharSequence) -> if
    android.view.MenuInflater getMenuInflater() -> int
    java.lang.CharSequence getSubtitle() -> new
    java.lang.Object getTag() -> try
androidx.appcompat.view.ActionMode$Callback -> if.do.void.if$do:
    boolean onActionItemClicked(androidx.appcompat.view.ActionMode,android.view.MenuItem) -> do
    void onDestroyActionMode(androidx.appcompat.view.ActionMode) -> do
    boolean onPrepareActionMode(androidx.appcompat.view.ActionMode,android.view.Menu) -> do
    boolean onCreateActionMode(androidx.appcompat.view.ActionMode,android.view.Menu) -> if
androidx.appcompat.view.CollapsibleActionView -> if.do.void.for:
    void onActionViewExpanded() -> do
    void onActionViewCollapsed() -> if
androidx.appcompat.view.ContextThemeWrapper -> if.do.void.int:
    android.content.res.Configuration mOverrideConfiguration -> int
    android.content.res.Resources mResources -> new
    int mThemeResource -> do
    android.content.res.Resources$Theme mTheme -> if
    android.view.LayoutInflater mInflater -> for
    int getThemeResId() -> do
    void onApplyThemeResource(android.content.res.Resources$Theme,int,boolean) -> do
    void initializeTheme() -> for
    android.content.res.Resources getResourcesInternal() -> if
androidx.appcompat.view.StandaloneActionMode -> if.do.void.new:
    android.content.Context mContext -> int
    androidx.appcompat.widget.ActionBarContextView mContextView -> new
    boolean mFinished -> case
    androidx.appcompat.view.menu.MenuBuilder mMenu -> char
    java.lang.ref.WeakReference mCustomView -> byte
    androidx.appcompat.view.ActionMode$Callback mCallback -> try
    java.lang.CharSequence getTitle() -> byte
    void invalidate() -> char
    void finish() -> do
    boolean onMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onMenuModeChange(androidx.appcompat.view.menu.MenuBuilder) -> do
    void setCustomView(android.view.View) -> do
    void setSubtitle(int) -> do
    void setSubtitle(java.lang.CharSequence) -> do
    void setTitleOptionalHint(boolean) -> do
    boolean isTitleOptional() -> else
    android.view.Menu getMenu() -> for
    android.view.View getCustomView() -> if
    void setTitle(int) -> if
    void setTitle(java.lang.CharSequence) -> if
    android.view.MenuInflater getMenuInflater() -> int
    java.lang.CharSequence getSubtitle() -> new
androidx.appcompat.view.SupportActionModeWrapper -> if.do.void.try:
    androidx.appcompat.view.ActionMode mWrappedObject -> if
    android.content.Context mContext -> do
androidx.appcompat.view.SupportActionModeWrapper$CallbackWrapper -> if.do.void.try$do:
    android.view.ActionMode$Callback mWrappedCallback -> do
    androidx.collection.SimpleArrayMap mMenus -> int
    android.content.Context mContext -> if
    java.util.ArrayList mActionModes -> for
    android.view.Menu getMenuWrapper(android.view.Menu) -> do
    boolean onActionItemClicked(androidx.appcompat.view.ActionMode,android.view.MenuItem) -> do
    void onDestroyActionMode(androidx.appcompat.view.ActionMode) -> do
    boolean onPrepareActionMode(androidx.appcompat.view.ActionMode,android.view.Menu) -> do
    android.view.ActionMode getActionModeWrapper(androidx.appcompat.view.ActionMode) -> if
    boolean onCreateActionMode(androidx.appcompat.view.ActionMode,android.view.Menu) -> if
androidx.appcompat.view.SupportMenuInflater -> if.do.void.byte:
    java.lang.Class[] ACTION_VIEW_CONSTRUCTOR_SIGNATURE -> new
    java.lang.Class[] ACTION_PROVIDER_CONSTRUCTOR_SIGNATURE -> try
    java.lang.Object[] mActionViewConstructorArguments -> do
    android.content.Context mContext -> for
    java.lang.Object[] mActionProviderConstructorArguments -> if
    java.lang.Object mRealOwner -> int
    java.lang.Object findRealOwner(java.lang.Object) -> do
    java.lang.Object getRealOwner() -> do
    void parseMenu(org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.view.Menu) -> do
androidx.appcompat.view.SupportMenuInflater$InflatedOnMenuItemClickListener -> if.do.void.byte$do:
    java.lang.Object mRealOwner -> do
    java.lang.reflect.Method mMethod -> if
    java.lang.Class[] PARAM_TYPES -> for
androidx.appcompat.view.SupportMenuInflater$MenuState -> if.do.void.byte$if:
    java.lang.String itemActionProviderClassName -> double
    boolean itemVisible -> float
    boolean itemAdded -> case
    int itemIconResId -> this
    java.lang.CharSequence itemTitle -> goto
    androidx.core.view.ActionProvider itemActionProvider -> native
    android.view.Menu menu -> do
    char itemNumericShortcut -> catch
    int groupOrder -> int
    int itemCategoryOrder -> else
    boolean itemChecked -> final
    boolean groupEnabled -> byte
    java.lang.CharSequence itemTitleCondensed -> long
    boolean groupVisible -> try
    int itemAlphabeticModifiers -> break
    char itemAlphabeticShortcut -> void
    int itemNumericModifiers -> class
    boolean itemEnabled -> short
    java.lang.CharSequence itemContentDescription -> public
    android.content.res.ColorStateList itemIconTintList -> static
    int itemActionViewLayout -> throw
    java.lang.String itemListenerMethodName -> import
    int itemCheckable -> const
    java.lang.String itemActionViewClassName -> while
    int itemShowAsAction -> super
    int groupId -> if
    java.lang.CharSequence itemTooltipText -> return
    android.graphics.PorterDuff$Mode itemIconTintMode -> switch
    int groupCategory -> for
    int groupCheckable -> new
    androidx.appcompat.view.SupportMenuInflater this$0 -> throws
    int itemId -> char
    void addItem() -> do
    char getShortcut(java.lang.String) -> do
    java.lang.Object newInstance(java.lang.String,java.lang.Class[],java.lang.Object[]) -> do
    void readGroup(android.util.AttributeSet) -> do
    void setItem(android.view.MenuItem) -> do
    boolean hasAddedItem() -> for
    android.view.SubMenu addSubMenuItem() -> if
    void readItem(android.util.AttributeSet) -> if
    void resetGroup() -> int
androidx.appcompat.view.ViewPropertyAnimatorCompatSet -> if.do.void.case:
    java.util.ArrayList mAnimators -> do
    boolean mIsStarted -> new
    long mDuration -> if
    android.view.animation.Interpolator mInterpolator -> for
    androidx.core.view.ViewPropertyAnimatorListener mListener -> int
    androidx.core.view.ViewPropertyAnimatorListenerAdapter mProxyListener -> try
    void cancel() -> do
    androidx.appcompat.view.ViewPropertyAnimatorCompatSet play(androidx.core.view.ViewPropertyAnimatorCompat) -> do
    androidx.appcompat.view.ViewPropertyAnimatorCompatSet playSequentially(androidx.core.view.ViewPropertyAnimatorCompat,androidx.core.view.ViewPropertyAnimatorCompat) -> do
    androidx.appcompat.view.ViewPropertyAnimatorCompatSet setDuration(long) -> do
    androidx.appcompat.view.ViewPropertyAnimatorCompatSet setInterpolator(android.view.animation.Interpolator) -> do
    androidx.appcompat.view.ViewPropertyAnimatorCompatSet setListener(androidx.core.view.ViewPropertyAnimatorListener) -> do
    void start() -> for
    void onAnimationsEnded() -> if
androidx.appcompat.view.ViewPropertyAnimatorCompatSet$1 -> if.do.void.case$do:
    boolean mProxyStarted -> do
    int mProxyEndCount -> if
    androidx.appcompat.view.ViewPropertyAnimatorCompatSet this$0 -> for
    void onAnimationEnd(android.view.View) -> do
    void onEnd() -> do
    void onAnimationStart(android.view.View) -> if
androidx.appcompat.view.WindowCallbackWrapper -> if.do.void.char:
    android.view.Window$Callback mWrapped -> if
    android.view.Window$Callback getWrapped() -> do
androidx.appcompat.view.menu.ActionMenuItem -> androidx.appcompat.view.menu.do:
    android.graphics.drawable.Drawable mIconDrawable -> goto
    android.content.res.ColorStateList mIconTintList -> break
    char mShortcutNumericChar -> byte
    android.content.Intent mIntent -> try
    int mId -> do
    java.lang.CharSequence mTitleCondensed -> new
    java.lang.CharSequence mContentDescription -> this
    android.graphics.PorterDuff$Mode mIconTintMode -> catch
    int mGroup -> if
    char mShortcutAlphabeticChar -> char
    int mFlags -> final
    int mShortcutAlphabeticModifiers -> else
    java.lang.CharSequence mTooltipText -> void
    int mOrdering -> for
    boolean mHasIconTint -> class
    java.lang.CharSequence mTitle -> int
    int mShortcutNumericModifiers -> case
    boolean mHasIconTintMode -> const
    android.content.Context mContext -> long
    androidx.core.view.ActionProvider getSupportActionProvider() -> do
    androidx.core.internal.view.SupportMenuItem setSupportActionProvider(androidx.core.view.ActionProvider) -> do
    void applyIconTint() -> if
androidx.appcompat.view.menu.ActionMenuItemView -> androidx.appcompat.view.menu.ActionMenuItemView:
    androidx.appcompat.view.menu.MenuBuilder$ItemInvoker mItemInvoker -> char
    android.graphics.drawable.Drawable mIcon -> case
    androidx.appcompat.view.menu.ActionMenuItemView$PopupCallback mPopupCallback -> goto
    int mSavedPaddingLeft -> break
    boolean mExpandedFormat -> this
    androidx.appcompat.widget.ForwardingListener mForwardingListener -> else
    int mMaxIconSize -> catch
    boolean mAllowTextWithIcon -> long
    java.lang.CharSequence mTitle -> byte
    androidx.appcompat.view.menu.MenuItemImpl mItemData -> try
    int mMinWidth -> void
    void updateTextButtonVisibility() -> byte
    void initialize(androidx.appcompat.view.menu.MenuItemImpl,int) -> do
    boolean needsDividerBefore() -> do
    boolean prefersCondensedTitle() -> for
    boolean needsDividerAfter() -> if
    boolean hasText() -> new
    boolean shouldAllowTextWithIcon() -> try
androidx.appcompat.view.menu.ActionMenuItemView$ActionMenuItemForwardingListener -> androidx.appcompat.view.menu.ActionMenuItemView$do:
    androidx.appcompat.view.menu.ActionMenuItemView this$0 -> goto
    androidx.appcompat.view.menu.ShowableListMenu getPopup() -> do
    boolean onForwardingStarted() -> if
androidx.appcompat.view.menu.ActionMenuItemView$PopupCallback -> androidx.appcompat.view.menu.ActionMenuItemView$if:
    androidx.appcompat.view.menu.ShowableListMenu getPopup() -> do
androidx.appcompat.view.menu.BaseMenuPresenter -> androidx.appcompat.view.menu.if:
    androidx.appcompat.view.menu.MenuView mMenuView -> char
    android.content.Context mSystemContext -> if
    android.view.LayoutInflater mSystemInflater -> new
    androidx.appcompat.view.menu.MenuBuilder mMenu -> int
    int mId -> else
    androidx.appcompat.view.menu.MenuPresenter$Callback mCallback -> try
    android.content.Context mContext -> for
    int mMenuLayoutRes -> byte
    int mItemLayoutRes -> case
    void addItemView(android.view.View,int) -> do
    void bindItemView(androidx.appcompat.view.menu.MenuItemImpl,androidx.appcompat.view.menu.MenuView$ItemView) -> do
    androidx.appcompat.view.menu.MenuView$ItemView createItemView(android.view.ViewGroup) -> do
    boolean expandItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> do
    boolean filterLeftoverView(android.view.ViewGroup,int) -> do
    androidx.appcompat.view.menu.MenuPresenter$Callback getCallback() -> do
    android.view.View getItemView(androidx.appcompat.view.menu.MenuItemImpl,android.view.View,android.view.ViewGroup) -> do
    void initForMenu(android.content.Context,androidx.appcompat.view.menu.MenuBuilder) -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    boolean onSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    void setCallback(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void setId(int) -> do
    boolean shouldIncludeItem(int,androidx.appcompat.view.menu.MenuItemImpl) -> do
    void updateMenuView(boolean) -> do
    int getId() -> for
    boolean collapseItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> if
    androidx.appcompat.view.menu.MenuView getMenuView(android.view.ViewGroup) -> if
androidx.appcompat.view.menu.BaseMenuWrapper -> androidx.appcompat.view.menu.for:
    java.util.Map mMenuItems -> if
    java.util.Map mSubMenus -> for
    android.content.Context mContext -> do
    android.view.MenuItem getMenuItemWrapper(android.view.MenuItem) -> do
    android.view.SubMenu getSubMenuWrapper(android.view.SubMenu) -> do
    void internalRemoveGroup(int) -> do
    void internalClear() -> if
    void internalRemoveItem(int) -> if
androidx.appcompat.view.menu.CascadingMenuPopup -> androidx.appcompat.view.menu.int:
    boolean mShowTitle -> while
    boolean mHasYOffset -> float
    int ITEM_LAYOUT -> return
    android.os.Handler mSubMenuHoverHandler -> case
    boolean mShouldCloseImmediately -> public
    int mMenuMaxWidth -> int
    boolean mHasXOffset -> final
    java.util.List mPendingMenus -> char
    boolean mOverflowOnly -> byte
    int mXOffset -> short
    int mDropDownGravity -> break
    android.view.View mAnchorView -> catch
    java.util.List mShowingMenus -> else
    int mPopupStyleRes -> try
    android.view.View$OnAttachStateChangeListener mAttachStateChangeListener -> long
    androidx.appcompat.widget.MenuItemHoverListener mMenuItemHoverListener -> this
    int mLastPosition -> const
    int mRawDropDownGravity -> void
    android.view.ViewTreeObserver$OnGlobalLayoutListener mGlobalLayoutListener -> goto
    int mYOffset -> super
    android.view.View mShownAnchorView -> class
    android.widget.PopupWindow$OnDismissListener mOnDismissListener -> native
    android.content.Context mContext -> for
    android.view.ViewTreeObserver mTreeObserver -> import
    int mPopupStyleAttr -> new
    androidx.appcompat.view.menu.MenuPresenter$Callback mPresenterCallback -> double
    boolean mForceShowIcon -> throw
    boolean closeMenuOnSubMenuOpened() -> byte
    androidx.appcompat.widget.MenuPopupWindow createPopupWindow() -> char
    void addMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
    android.view.MenuItem findMenuItemForSubmenu(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuBuilder) -> do
    android.view.View findParentViewForSubmenu(androidx.appcompat.view.menu.CascadingMenuPopup$CascadingMenuInfo,androidx.appcompat.view.menu.MenuBuilder) -> do
    boolean isShowing() -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    boolean onSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    void setAnchorView(android.view.View) -> do
    void setCallback(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void setGravity(int) -> do
    void setOnDismissListener(android.widget.PopupWindow$OnDismissListener) -> do
    void updateMenuView(boolean) -> do
    int getInitialMenuPosition() -> else
    int findIndexOfAddedMenu(androidx.appcompat.view.menu.MenuBuilder) -> for
    void setShowTitle(boolean) -> for
    void setVerticalOffset(int) -> for
    void setForceShowIcon(boolean) -> if
    void setHorizontalOffset(int) -> if
    void show() -> if
    boolean flagActionItems() -> int
    int getNextMenuPosition(int) -> int
    void showMenu(androidx.appcompat.view.menu.MenuBuilder) -> int
    android.widget.ListView getListView() -> new
    android.os.Parcelable onSaveInstanceState() -> try
androidx.appcompat.view.menu.CascadingMenuPopup$1 -> androidx.appcompat.view.menu.int$do:
    androidx.appcompat.view.menu.CascadingMenuPopup this$0 -> if
androidx.appcompat.view.menu.CascadingMenuPopup$2 -> androidx.appcompat.view.menu.int$if:
    androidx.appcompat.view.menu.CascadingMenuPopup this$0 -> if
androidx.appcompat.view.menu.CascadingMenuPopup$3 -> androidx.appcompat.view.menu.int$for:
    androidx.appcompat.view.menu.CascadingMenuPopup this$0 -> if
    void onItemHoverEnter(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onItemHoverExit(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> if
androidx.appcompat.view.menu.CascadingMenuPopup$3$1 -> androidx.appcompat.view.menu.int$for$do:
    android.view.MenuItem val$item -> for
    androidx.appcompat.view.menu.MenuBuilder val$menu -> int
    androidx.appcompat.view.menu.CascadingMenuPopup$CascadingMenuInfo val$nextInfo -> if
    androidx.appcompat.view.menu.CascadingMenuPopup$3 this$1 -> new
androidx.appcompat.view.menu.CascadingMenuPopup$CascadingMenuInfo -> androidx.appcompat.view.menu.int$int:
    androidx.appcompat.widget.MenuPopupWindow window -> do
    int position -> for
    androidx.appcompat.view.menu.MenuBuilder menu -> if
    android.widget.ListView getListView() -> do
androidx.appcompat.view.menu.ExpandedMenuView -> androidx.appcompat.view.menu.ExpandedMenuView:
    int mAnimations -> for
    androidx.appcompat.view.menu.MenuBuilder mMenu -> if
    int[] TINT_ATTRS -> int
    void initialize(androidx.appcompat.view.menu.MenuBuilder) -> do
    boolean invokeItem(androidx.appcompat.view.menu.MenuItemImpl) -> do
androidx.appcompat.view.menu.ListMenuItemView -> androidx.appcompat.view.menu.ListMenuItemView:
    android.widget.ImageView mIconView -> for
    android.graphics.drawable.Drawable mBackground -> goto
    android.widget.CheckBox mCheckBox -> try
    androidx.appcompat.view.menu.MenuItemImpl mItemData -> if
    android.widget.RadioButton mRadioButton -> int
    android.view.LayoutInflater mInflater -> class
    android.content.Context mTextAppearanceContext -> this
    android.graphics.drawable.Drawable mSubMenuArrow -> break
    int mTextAppearance -> long
    boolean mHasListDivider -> catch
    android.widget.LinearLayout mContent -> else
    boolean mPreserveIconSpacing -> void
    android.widget.ImageView mSubMenuArrowView -> case
    android.widget.TextView mTitleView -> new
    android.widget.TextView mShortcutView -> byte
    android.widget.ImageView mGroupDivider -> char
    boolean mForceShowIcon -> const
    void addContentView(android.view.View) -> do
    void addContentView(android.view.View,int) -> do
    void initialize(androidx.appcompat.view.menu.MenuItemImpl,int) -> do
    void insertCheckBox() -> do
    void setShortcut(boolean,char) -> do
    boolean prefersCondensedTitle() -> for
    void insertIconView() -> if
    void insertRadioButton() -> int
androidx.appcompat.view.menu.ListMenuPresenter -> androidx.appcompat.view.menu.new:
    androidx.appcompat.view.menu.ListMenuPresenter$MenuAdapter mAdapter -> else
    android.content.Context mContext -> if
    androidx.appcompat.view.menu.MenuBuilder mMenu -> int
    androidx.appcompat.view.menu.ExpandedMenuView mMenuView -> new
    int mThemeRes -> byte
    androidx.appcompat.view.menu.MenuPresenter$Callback mCallback -> char
    int mItemIndexOffset -> try
    int mItemLayoutRes -> case
    int mId -> goto
    android.view.LayoutInflater mInflater -> for
    boolean expandItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> do
    android.widget.ListAdapter getAdapter() -> do
    androidx.appcompat.view.menu.MenuView getMenuView(android.view.ViewGroup) -> do
    void initForMenu(android.content.Context,androidx.appcompat.view.menu.MenuBuilder) -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    boolean onSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    void restoreHierarchyState(android.os.Bundle) -> do
    void setCallback(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void updateMenuView(boolean) -> do
    int getId() -> for
    boolean collapseItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> if
    void saveHierarchyState(android.os.Bundle) -> if
    boolean flagActionItems() -> int
    android.os.Parcelable onSaveInstanceState() -> try
androidx.appcompat.view.menu.ListMenuPresenter$MenuAdapter -> androidx.appcompat.view.menu.new$do:
    int mExpandedIndex -> if
    androidx.appcompat.view.menu.ListMenuPresenter this$0 -> for
    void findExpandedIndex() -> do
androidx.appcompat.view.menu.MenuAdapter -> androidx.appcompat.view.menu.try:
    boolean mForceShowIcon -> int
    boolean mOverflowOnly -> new
    int mExpandedIndex -> for
    int mItemLayoutRes -> byte
    androidx.appcompat.view.menu.MenuBuilder mAdapterMenu -> if
    android.view.LayoutInflater mInflater -> try
    void findExpandedIndex() -> do
    void setForceShowIcon(boolean) -> do
    androidx.appcompat.view.menu.MenuBuilder getAdapterMenu() -> if
androidx.appcompat.view.menu.MenuBuilder -> androidx.appcompat.view.menu.byte:
    java.util.concurrent.CopyOnWriteArrayList mPresenters -> throw
    boolean mOptionalIconsVisible -> float
    boolean mIsVisibleItemsStale -> case
    java.util.ArrayList mTempShortcutItemList -> super
    android.view.ContextMenu$ContextMenuInfo mCurrentMenuInfo -> this
    boolean mOverrideVisibleItems -> import
    android.graphics.drawable.Drawable mHeaderIcon -> break
    int mDefaultShowAsAction -> long
    boolean mShortcutsVisible -> int
    java.lang.CharSequence mHeaderTitle -> void
    boolean mStructureChangedWhileDispatchPrevented -> final
    int[] sCategoryToOrder -> native
    boolean mPreventDispatchingItemsChanged -> class
    boolean mIsActionItemsStale -> goto
    java.util.ArrayList mNonActionItems -> else
    boolean mGroupDividerEnabled -> double
    android.view.View mHeaderView -> catch
    boolean mIsClosing -> short
    android.content.Context mContext -> do
    androidx.appcompat.view.menu.MenuItemImpl mExpandedItem -> while
    androidx.appcompat.view.menu.MenuBuilder$Callback mCallback -> new
    java.util.ArrayList mItems -> try
    boolean mQwertyMode -> for
    android.content.res.Resources mResources -> if
    java.util.ArrayList mVisibleItems -> byte
    java.util.ArrayList mActionItems -> char
    boolean mItemsChangedWhileDispatchPrevented -> const
    boolean isGroupDividerEnabled() -> break
    android.graphics.drawable.Drawable getHeaderIcon() -> byte
    java.lang.CharSequence getHeaderTitle() -> case
    boolean isQwertyMode() -> catch
    android.view.View getHeaderView() -> char
    boolean isShortcutsVisible() -> class
    void startDispatchingItemsChanged() -> const
    android.view.MenuItem addInternal(int,int,int,java.lang.CharSequence) -> do
    void addMenuPresenter(androidx.appcompat.view.menu.MenuPresenter) -> do
    void addMenuPresenter(androidx.appcompat.view.menu.MenuPresenter,android.content.Context) -> do
    void changeMenuMode() -> do
    void close(boolean) -> do
    boolean collapseItemActionView(androidx.appcompat.view.menu.MenuItemImpl) -> do
    androidx.appcompat.view.menu.MenuItemImpl createNewMenuItem(int,int,int,int,java.lang.CharSequence,int) -> do
    boolean dispatchMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    boolean dispatchSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder,androidx.appcompat.view.menu.MenuPresenter) -> do
    int findGroupIndex(int) -> do
    int findGroupIndex(int,int) -> do
    int findInsertIndex(java.util.ArrayList,int) -> do
    androidx.appcompat.view.menu.MenuItemImpl findItemWithShortcutForKey(int,android.view.KeyEvent) -> do
    void findItemsWithShortcutForKey(java.util.List,int,android.view.KeyEvent) -> do
    boolean performItemAction(android.view.MenuItem,int) -> do
    boolean performItemAction(android.view.MenuItem,androidx.appcompat.view.menu.MenuPresenter,int) -> do
    void removeItemAtInt(int,boolean) -> do
    void restoreActionViewStates(android.os.Bundle) -> do
    void setCallback(androidx.appcompat.view.menu.MenuBuilder$Callback) -> do
    void setExclusiveItemChecked(android.view.MenuItem) -> do
    androidx.appcompat.view.menu.MenuBuilder setHeaderIconInt(android.graphics.drawable.Drawable) -> do
    void setHeaderInternal(int,java.lang.CharSequence,int,android.graphics.drawable.Drawable,android.view.View) -> do
    androidx.appcompat.view.menu.MenuBuilder setHeaderTitleInt(java.lang.CharSequence) -> do
    androidx.appcompat.view.menu.MenuBuilder setHeaderViewInt(android.view.View) -> do
    java.util.ArrayList getNonActionItems() -> else
    void stopDispatchingItemsChanged() -> final
    java.util.ArrayList getActionItems() -> for
    void onItemActionRequestChanged(androidx.appcompat.view.menu.MenuItemImpl) -> for
    void saveActionViewStates(android.os.Bundle) -> for
    androidx.appcompat.view.menu.MenuBuilder setDefaultShowAsAction(int) -> for
    void setOverrideVisibleItems(boolean) -> for
    boolean getOptionalIconsVisible() -> goto
    boolean expandItemActionView(androidx.appcompat.view.menu.MenuItemImpl) -> if
    int findItemIndex(int) -> if
    void flagActionItems() -> if
    void onItemsChanged(boolean) -> if
    void removeMenuPresenter(androidx.appcompat.view.menu.MenuPresenter) -> if
    void restorePresenterStates(android.os.Bundle) -> if
    void dispatchPresenterUpdate(boolean) -> int
    java.lang.String getActionViewStatesKey() -> int
    void onItemVisibleChanged(androidx.appcompat.view.menu.MenuItemImpl) -> int
    void savePresenterStates(android.os.Bundle) -> int
    androidx.appcompat.view.menu.MenuBuilder setHeaderIconInt(int) -> int
    android.content.res.Resources getResources() -> long
    void dispatchRestoreInstanceState(android.os.Bundle) -> new
    android.content.Context getContext() -> new
    androidx.appcompat.view.menu.MenuBuilder setHeaderTitleInt(int) -> new
    void setShortcutsVisibleInner(boolean) -> new
    androidx.appcompat.view.menu.MenuBuilder getRootMenu() -> this
    void dispatchSaveInstanceState(android.os.Bundle) -> try
    androidx.appcompat.view.menu.MenuItemImpl getExpandedItem() -> try
    int getOrdering(int) -> try
    java.util.ArrayList getVisibleItems() -> void
androidx.appcompat.view.menu.MenuBuilder$Callback -> androidx.appcompat.view.menu.byte$do:
    boolean onMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onMenuModeChange(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.view.menu.MenuBuilder$ItemInvoker -> androidx.appcompat.view.menu.byte$if:
    boolean invokeItem(androidx.appcompat.view.menu.MenuItemImpl) -> do
androidx.appcompat.view.menu.MenuDialogHelper -> androidx.appcompat.view.menu.case:
    androidx.appcompat.view.menu.MenuBuilder mMenu -> if
    androidx.appcompat.app.AlertDialog mDialog -> for
    androidx.appcompat.view.menu.ListMenuPresenter mPresenter -> int
    androidx.appcompat.view.menu.MenuPresenter$Callback mPresenterCallback -> new
    void dismiss() -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    boolean onOpenSubMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
    void show(android.os.IBinder) -> do
androidx.appcompat.view.menu.MenuItemImpl -> androidx.appcompat.view.menu.char:
    boolean mNeedToApplyIconTint -> while
    int mIconResId -> this
    android.view.View mActionView -> native
    int mId -> do
    int mFlags -> double
    java.lang.CharSequence mTitle -> new
    androidx.core.view.ActionProvider mActionProvider -> public
    char mShortcutAlphabeticChar -> else
    int mShortcutAlphabeticModifiers -> goto
    androidx.appcompat.view.menu.SubMenuBuilder mSubMenu -> break
    int mOrdering -> int
    java.lang.CharSequence mTitleCondensed -> try
    android.graphics.PorterDuff$Mode mIconTintMode -> short
    android.content.res.ColorStateList mIconTintList -> float
    android.graphics.drawable.Drawable mIconDrawable -> long
    int mShowAsAction -> import
    android.view.MenuItem$OnActionExpandListener mOnActionExpandListener -> return
    androidx.appcompat.view.menu.MenuBuilder mMenu -> void
    java.lang.CharSequence mContentDescription -> const
    char mShortcutNumericChar -> case
    java.lang.CharSequence mTooltipText -> final
    java.lang.Runnable mItemCallback -> catch
    android.content.Intent mIntent -> byte
    boolean mHasIconTint -> super
    int mGroup -> if
    android.view.ContextMenu$ContextMenuInfo mMenuInfo -> switch
    int mCategoryOrder -> for
    android.view.MenuItem$OnMenuItemClickListener mClickListener -> class
    int mShortcutNumericModifiers -> char
    boolean mIsActionViewExpanded -> static
    boolean mHasIconTintMode -> throw
    boolean invoke() -> byte
    boolean isActionButton() -> case
    boolean isExclusiveCheckable() -> char
    void appendModifier(java.lang.StringBuilder,int,int,java.lang.String) -> do
    android.graphics.drawable.Drawable applyIconTintIfNecessary(android.graphics.drawable.Drawable) -> do
    androidx.core.view.ActionProvider getSupportActionProvider() -> do
    java.lang.CharSequence getTitleForItemView(androidx.appcompat.view.menu.MenuView$ItemView) -> do
    void setActionViewExpanded(boolean) -> do
    void setMenuInfo(android.view.ContextMenu$ContextMenuInfo) -> do
    void setSubMenu(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    androidx.core.internal.view.SupportMenuItem setSupportActionProvider(androidx.core.view.ActionProvider) -> do
    boolean requestsActionButton() -> else
    int getOrdering() -> for
    void setExclusiveCheckable(boolean) -> for
    boolean requiresActionButton() -> goto
    void actionFormatChanged() -> if
    void setCheckedInt(boolean) -> if
    char getShortcut() -> int
    void setIsActionButton(boolean) -> int
    boolean shouldShowIcon() -> long
    java.lang.String getShortcutLabel() -> new
    boolean setVisibleInt(boolean) -> new
    boolean shouldShowShortcut() -> this
    boolean hasCollapsibleActionView() -> try
    boolean showsTextAsAction() -> void
androidx.appcompat.view.menu.MenuItemImpl$1 -> androidx.appcompat.view.menu.char$do:
    androidx.appcompat.view.menu.MenuItemImpl this$0 -> do
androidx.appcompat.view.menu.MenuItemWrapperICS -> androidx.appcompat.view.menu.else:
    androidx.core.internal.view.SupportMenuItem mWrappedObject -> int
    java.lang.reflect.Method mSetExclusiveCheckableMethod -> new
    void setExclusiveCheckable(boolean) -> do
androidx.appcompat.view.menu.MenuItemWrapperICS$ActionProviderWrapper -> androidx.appcompat.view.menu.else$do:
    android.view.ActionProvider mInner -> if
    androidx.appcompat.view.menu.MenuItemWrapperICS this$0 -> for
    boolean hasSubMenu() -> do
    void onPrepareSubMenu(android.view.SubMenu) -> do
    android.view.View onCreateActionView() -> for
    boolean onPerformDefaultAction() -> int
androidx.appcompat.view.menu.MenuItemWrapperICS$ActionProviderWrapperJB -> androidx.appcompat.view.menu.else$if:
    androidx.core.view.ActionProvider$VisibilityListener mListener -> int
    android.view.View onCreateActionView(android.view.MenuItem) -> do
    void setVisibilityListener(androidx.core.view.ActionProvider$VisibilityListener) -> do
    boolean isVisible() -> if
    boolean overridesItemVisibility() -> new
androidx.appcompat.view.menu.MenuItemWrapperICS$CollapsibleActionViewWrapper -> androidx.appcompat.view.menu.else$for:
    android.view.CollapsibleActionView mWrappedView -> if
    void onActionViewExpanded() -> do
    android.view.View getWrappedView() -> for
    void onActionViewCollapsed() -> if
androidx.appcompat.view.menu.MenuItemWrapperICS$OnActionExpandListenerWrapper -> androidx.appcompat.view.menu.else$int:
    android.view.MenuItem$OnActionExpandListener mObject -> do
    androidx.appcompat.view.menu.MenuItemWrapperICS this$0 -> if
androidx.appcompat.view.menu.MenuItemWrapperICS$OnMenuItemClickListenerWrapper -> androidx.appcompat.view.menu.else$new:
    android.view.MenuItem$OnMenuItemClickListener mObject -> do
    androidx.appcompat.view.menu.MenuItemWrapperICS this$0 -> if
androidx.appcompat.view.menu.MenuPopup -> androidx.appcompat.view.menu.goto:
    android.graphics.Rect mEpicenterBounds -> if
    boolean closeMenuOnSubMenuOpened() -> byte
    android.graphics.Rect getEpicenterBounds() -> case
    void addMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
    boolean expandItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> do
    void initForMenu(android.content.Context,androidx.appcompat.view.menu.MenuBuilder) -> do
    int measureIndividualMenuWidth(android.widget.ListAdapter,android.view.ViewGroup,android.content.Context,int) -> do
    void setAnchorView(android.view.View) -> do
    void setEpicenterBounds(android.graphics.Rect) -> do
    void setGravity(int) -> do
    void setOnDismissListener(android.widget.PopupWindow$OnDismissListener) -> do
    androidx.appcompat.view.menu.MenuAdapter toMenuAdapter(android.widget.ListAdapter) -> do
    int getId() -> for
    void setShowTitle(boolean) -> for
    void setVerticalOffset(int) -> for
    boolean collapseItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> if
    void setForceShowIcon(boolean) -> if
    void setHorizontalOffset(int) -> if
    boolean shouldPreserveIconSpacing(androidx.appcompat.view.menu.MenuBuilder) -> if
androidx.appcompat.view.menu.MenuPopupHelper -> androidx.appcompat.view.menu.long:
    android.widget.PopupWindow$OnDismissListener mInternalOnDismissListener -> long
    int mPopupStyleAttr -> int
    android.widget.PopupWindow$OnDismissListener mOnDismissListener -> goto
    boolean mOverflowOnly -> for
    boolean mForceShowIcon -> case
    android.view.View mAnchorView -> try
    int mDropDownGravity -> byte
    androidx.appcompat.view.menu.MenuBuilder mMenu -> if
    int mPopupStyleRes -> new
    androidx.appcompat.view.menu.MenuPresenter$Callback mPresenterCallback -> char
    androidx.appcompat.view.menu.MenuPopup mPopup -> else
    android.content.Context mContext -> do
    androidx.appcompat.view.menu.MenuPopup createPopup() -> byte
    void dismiss() -> do
    void setAnchorView(android.view.View) -> do
    void setForceShowIcon(boolean) -> do
    void setGravity(int) -> do
    void setOnDismissListener(android.widget.PopupWindow$OnDismissListener) -> do
    void setPresenterCallback(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void showPopup(int,int,boolean,boolean) -> do
    boolean tryShow(int,int) -> do
    boolean isShowing() -> for
    androidx.appcompat.view.menu.MenuPopup getPopup() -> if
    void onDismiss() -> int
    void show() -> new
    boolean tryShow() -> try
androidx.appcompat.view.menu.MenuPopupHelper$1 -> androidx.appcompat.view.menu.long$do:
    androidx.appcompat.view.menu.MenuPopupHelper this$0 -> if
androidx.appcompat.view.menu.MenuPresenter -> androidx.appcompat.view.menu.this:
    boolean expandItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> do
    void initForMenu(android.content.Context,androidx.appcompat.view.menu.MenuBuilder) -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    boolean onSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    void setCallback(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void updateMenuView(boolean) -> do
    int getId() -> for
    boolean collapseItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> if
    boolean flagActionItems() -> int
    android.os.Parcelable onSaveInstanceState() -> try
androidx.appcompat.view.menu.MenuPresenter$Callback -> androidx.appcompat.view.menu.this$do:
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    boolean onOpenSubMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.view.menu.MenuView -> androidx.appcompat.view.menu.void:
    void initialize(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.view.menu.MenuView$ItemView -> androidx.appcompat.view.menu.void$do:
    void initialize(androidx.appcompat.view.menu.MenuItemImpl,int) -> do
    boolean prefersCondensedTitle() -> for
androidx.appcompat.view.menu.MenuWrapperICS -> androidx.appcompat.view.menu.break:
    androidx.core.internal.view.SupportMenu mWrappedObject -> int
androidx.appcompat.view.menu.ShowableListMenu -> androidx.appcompat.view.menu.catch:
    boolean isShowing() -> do
    void show() -> if
    android.widget.ListView getListView() -> new
androidx.appcompat.view.menu.StandardMenuPopup -> androidx.appcompat.view.menu.class:
    android.widget.PopupWindow$OnDismissListener mOnDismissListener -> this
    android.view.ViewTreeObserver mTreeObserver -> class
    androidx.appcompat.view.menu.MenuBuilder mMenu -> int
    androidx.appcompat.view.menu.MenuAdapter mAdapter -> new
    androidx.appcompat.widget.MenuPopupWindow mPopup -> else
    int mContentWidth -> float
    int ITEM_LAYOUT -> throw
    android.view.View$OnAttachStateChangeListener mAttachStateChangeListener -> long
    android.view.ViewTreeObserver$OnGlobalLayoutListener mGlobalLayoutListener -> goto
    boolean mShowTitle -> super
    android.view.View mAnchorView -> void
    android.view.View mShownAnchorView -> break
    boolean mHasContentWidth -> final
    android.content.Context mContext -> for
    int mPopupMaxWidth -> byte
    androidx.appcompat.view.menu.MenuPresenter$Callback mPresenterCallback -> catch
    boolean mOverflowOnly -> try
    int mPopupStyleRes -> char
    int mPopupStyleAttr -> case
    boolean mWasDismissed -> const
    int mDropDownGravity -> short
    boolean tryShow() -> char
    void addMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
    boolean isShowing() -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    boolean onSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    void setAnchorView(android.view.View) -> do
    void setCallback(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void setGravity(int) -> do
    void setOnDismissListener(android.widget.PopupWindow$OnDismissListener) -> do
    void updateMenuView(boolean) -> do
    void setShowTitle(boolean) -> for
    void setVerticalOffset(int) -> for
    void setForceShowIcon(boolean) -> if
    void setHorizontalOffset(int) -> if
    void show() -> if
    boolean flagActionItems() -> int
    android.widget.ListView getListView() -> new
    android.os.Parcelable onSaveInstanceState() -> try
androidx.appcompat.view.menu.StandardMenuPopup$1 -> androidx.appcompat.view.menu.class$do:
    androidx.appcompat.view.menu.StandardMenuPopup this$0 -> if
androidx.appcompat.view.menu.StandardMenuPopup$2 -> androidx.appcompat.view.menu.class$if:
    androidx.appcompat.view.menu.StandardMenuPopup this$0 -> if
androidx.appcompat.view.menu.SubMenuBuilder -> androidx.appcompat.view.menu.const:
    androidx.appcompat.view.menu.MenuBuilder mParentMenu -> public
    androidx.appcompat.view.menu.MenuItemImpl mItem -> return
    boolean isGroupDividerEnabled() -> break
    boolean isQwertyMode() -> catch
    boolean isShortcutsVisible() -> class
    boolean collapseItemActionView(androidx.appcompat.view.menu.MenuItemImpl) -> do
    boolean dispatchMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void setCallback(androidx.appcompat.view.menu.MenuBuilder$Callback) -> do
    android.view.Menu getParentMenu() -> float
    boolean expandItemActionView(androidx.appcompat.view.menu.MenuItemImpl) -> if
    java.lang.String getActionViewStatesKey() -> int
    androidx.appcompat.view.menu.MenuBuilder getRootMenu() -> this
androidx.appcompat.view.menu.SubMenuWrapperICS -> androidx.appcompat.view.menu.final:
    androidx.core.internal.view.SupportSubMenu mSubMenu -> new
androidx.appcompat.widget.AbsActionBarView -> androidx.appcompat.widget.do:
    androidx.appcompat.widget.ActionMenuView mMenuView -> int
    androidx.core.view.ViewPropertyAnimatorCompat mVisibilityAnim -> byte
    boolean mEatingTouch -> case
    android.content.Context mPopupContext -> for
    androidx.appcompat.widget.AbsActionBarView$VisibilityAnimListener mVisAnimListener -> if
    int mContentHeight -> try
    boolean mEatingHover -> char
    androidx.appcompat.widget.ActionMenuPresenter mActionMenuPresenter -> new
    void access$001(androidx.appcompat.widget.AbsActionBarView,int) -> do
    int measureChildView(android.view.View,int,int,int) -> do
    int next(int,int,boolean) -> do
    int positionChild(android.view.View,int,int,int,boolean) -> do
    androidx.core.view.ViewPropertyAnimatorCompat setupAnimatorToVisibility(int,long) -> do
    void access$101(androidx.appcompat.widget.AbsActionBarView,int) -> if
androidx.appcompat.widget.AbsActionBarView$VisibilityAnimListener -> androidx.appcompat.widget.do$do:
    boolean mCanceled -> do
    int mFinalVisibility -> if
    androidx.appcompat.widget.AbsActionBarView this$0 -> for
    void onAnimationEnd(android.view.View) -> do
    androidx.appcompat.widget.AbsActionBarView$VisibilityAnimListener withFinalVisibility(androidx.core.view.ViewPropertyAnimatorCompat,int) -> do
    void onAnimationCancel(android.view.View) -> for
    void onAnimationStart(android.view.View) -> if
androidx.appcompat.widget.ActionBarBackgroundDrawable -> androidx.appcompat.widget.if:
    androidx.appcompat.widget.ActionBarContainer mContainer -> do
androidx.appcompat.widget.ActionBarContainer -> androidx.appcompat.widget.ActionBarContainer:
    android.view.View mTabContainer -> for
    android.graphics.drawable.Drawable mBackground -> try
    android.graphics.drawable.Drawable mSplitBackground -> case
    boolean mIsStacked -> else
    boolean mIsTransitioning -> if
    android.view.View mContextView -> new
    android.view.View mActionBarView -> int
    android.graphics.drawable.Drawable mStackedBackground -> byte
    boolean mIsSplit -> char
    int mHeight -> goto
    int getMeasuredHeightWithMargins(android.view.View) -> do
    boolean isCollapsed(android.view.View) -> if
androidx.appcompat.widget.ActionBarContextView -> androidx.appcompat.widget.ActionBarContextView:
    android.widget.TextView mTitleView -> break
    java.lang.CharSequence mTitle -> else
    int mTitleStyleRes -> class
    boolean mTitleOptional -> final
    int mCloseItemLayout -> float
    java.lang.CharSequence mSubtitle -> goto
    android.view.View mCustomView -> this
    android.widget.TextView mSubtitleView -> catch
    android.widget.LinearLayout mTitleLayout -> void
    int mSubtitleStyleRes -> const
    android.view.View mClose -> long
    void closeMode() -> do
    void initForMode(androidx.appcompat.view.ActionMode) -> do
    androidx.core.view.ViewPropertyAnimatorCompat setupAnimatorToVisibility(int,long) -> do
    void killMode() -> for
    boolean isTitleOptional() -> if
    boolean showOverflowMenu() -> int
    void initTitle() -> new
androidx.appcompat.widget.ActionBarContextView$1 -> androidx.appcompat.widget.ActionBarContextView$do:
    androidx.appcompat.view.ActionMode val$mode -> if
androidx.appcompat.widget.ActionBarOverlayLayout -> androidx.appcompat.widget.ActionBarOverlayLayout:
    android.graphics.Rect mLastBaseInnerInsets -> final
    androidx.appcompat.widget.ActionBarContainer mActionBarTop -> new
    boolean mIgnoreWindowContentOverlay -> case
    int mHideOnContentScrollReference -> this
    android.animation.AnimatorListenerAdapter mTopAnimatorListener -> double
    android.graphics.Rect mContentInsets -> class
    android.graphics.Rect mBaseInnerInsets -> const
    android.graphics.Rect mInnerInsets -> float
    androidx.appcompat.widget.DecorToolbar mDecorToolbar -> try
    boolean mHasNonEmbeddedTabs -> else
    android.graphics.Rect mBaseContentInsets -> break
    int[] ATTRS -> return
    android.view.ViewPropertyAnimator mCurrentActionBarTopAnimator -> while
    boolean mHideOnContentScroll -> goto
    androidx.core.view.NestedScrollingParentHelper mParentHelper -> public
    java.lang.Runnable mRemoveActionBarHideOffset -> import
    androidx.appcompat.widget.ContentFrameLayout mContent -> int
    android.graphics.drawable.Drawable mWindowContentOverlay -> byte
    android.widget.OverScroller mFlingEstimator -> throw
    android.graphics.Rect mLastBaseContentInsets -> catch
    boolean mOverlayMode -> char
    boolean mAnimatingForFling -> long
    androidx.appcompat.widget.ActionBarOverlayLayout$ActionBarVisibilityCallback mActionBarVisibilityCallback -> super
    int mLastSystemUiVisibility -> void
    int mActionBarHeight -> if
    int mWindowVisibility -> for
    android.graphics.Rect mLastInnerInsets -> short
    java.lang.Runnable mAddActionBarHideOffset -> native
    void dismissPopups() -> byte
    void haltActionBarHideOffsetAnimations() -> case
    boolean isInOverlayMode() -> char
    boolean applyInsets(android.view.View,android.graphics.Rect,boolean,boolean,boolean,boolean) -> do
    androidx.appcompat.widget.DecorToolbar getDecorToolbar(android.view.View) -> do
    void init(android.content.Context) -> do
    void initFeature(int) -> do
    void onNestedPreScroll(android.view.View,int,int,int[],int) -> do
    void onNestedScroll(android.view.View,int,int,int,int,int) -> do
    void onNestedScroll(android.view.View,int,int,int,int,int,int[]) -> do
    void onNestedScrollAccepted(android.view.View,android.view.View,int,int) -> do
    void onStopNestedScroll(android.view.View,int) -> do
    void setMenu(android.view.Menu,androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    boolean shouldHideActionBarOnFling(float,float) -> do
    boolean showOverflowMenu() -> do
    void pullChildren() -> else
    void setMenuPrepared() -> for
    void addActionBarHideOffset() -> goto
    boolean isOverflowMenuShowPending() -> if
    boolean onStartNestedScroll(android.view.View,android.view.View,int,int) -> if
    boolean isOverflowMenuShowing() -> int
    void postAddActionBarHideOffset() -> long
    boolean canShowOverflowMenu() -> new
    void postRemoveActionBarHideOffset() -> this
    boolean hideOverflowMenu() -> try
    void removeActionBarHideOffset() -> void
androidx.appcompat.widget.ActionBarOverlayLayout$1 -> androidx.appcompat.widget.ActionBarOverlayLayout$do:
    androidx.appcompat.widget.ActionBarOverlayLayout this$0 -> do
androidx.appcompat.widget.ActionBarOverlayLayout$2 -> androidx.appcompat.widget.ActionBarOverlayLayout$if:
    androidx.appcompat.widget.ActionBarOverlayLayout this$0 -> if
androidx.appcompat.widget.ActionBarOverlayLayout$3 -> androidx.appcompat.widget.ActionBarOverlayLayout$for:
    androidx.appcompat.widget.ActionBarOverlayLayout this$0 -> if
androidx.appcompat.widget.ActionBarOverlayLayout$ActionBarVisibilityCallback -> androidx.appcompat.widget.ActionBarOverlayLayout$int:
    void enableContentAnimations(boolean) -> do
    void onContentScrollStarted() -> do
    void onWindowVisibilityChanged(int) -> do
    void showForSystem() -> for
    void hideForSystem() -> if
    void onContentScrollStopped() -> int
androidx.appcompat.widget.ActionBarOverlayLayout$LayoutParams -> androidx.appcompat.widget.ActionBarOverlayLayout$new:
androidx.appcompat.widget.ActionMenuPresenter -> androidx.appcompat.widget.for:
    androidx.appcompat.widget.ActionMenuPresenter$OverflowMenuButton mOverflowButton -> goto
    androidx.appcompat.widget.ActionMenuPresenter$ActionButtonSubmenu mActionButtonPopup -> import
    android.graphics.drawable.Drawable mPendingOverflowIcon -> long
    boolean mStrictWidthLimit -> float
    boolean mPendingOverflowIconSet -> this
    boolean mReserveOverflowSet -> break
    android.util.SparseBooleanArray mActionButtonGroups -> while
    int mActionItemWidthLimit -> class
    androidx.appcompat.widget.ActionMenuPresenter$PopupPresenterCallback mPopupPresenterCallback -> return
    androidx.appcompat.widget.ActionMenuPresenter$OpenOverflowRunnable mPostedOpenRunnable -> native
    int mWidthLimit -> catch
    boolean mWidthLimitSet -> short
    int mMinCellSize -> throw
    int mOpenSubMenuId -> static
    int mMaxItems -> const
    androidx.appcompat.widget.ActionMenuPresenter$OverflowPopup mOverflowPopup -> double
    boolean mExpandedActionViewsExclusive -> super
    androidx.appcompat.widget.ActionMenuPresenter$ActionMenuPopupCallback mPopupCallback -> public
    boolean mMaxItemsSet -> final
    boolean mReserveOverflow -> void
    boolean hideOverflowMenu() -> byte
    boolean hideSubMenus() -> case
    boolean isOverflowMenuShowPending() -> char
    androidx.appcompat.view.menu.MenuBuilder access$000(androidx.appcompat.widget.ActionMenuPresenter) -> do
    void bindItemView(androidx.appcompat.view.menu.MenuItemImpl,androidx.appcompat.view.menu.MenuView$ItemView) -> do
    boolean filterLeftoverView(android.view.ViewGroup,int) -> do
    android.view.View findViewForItem(android.view.MenuItem) -> do
    android.view.View getItemView(androidx.appcompat.view.menu.MenuItemImpl,android.view.View,android.view.ViewGroup) -> do
    void initForMenu(android.content.Context,androidx.appcompat.view.menu.MenuBuilder) -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    void onConfigurationChanged(android.content.res.Configuration) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    boolean onSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    void setMenuView(androidx.appcompat.widget.ActionMenuView) -> do
    void setOverflowIcon(android.graphics.drawable.Drawable) -> do
    boolean shouldIncludeItem(int,androidx.appcompat.view.menu.MenuItemImpl) -> do
    void updateMenuView(boolean) -> do
    boolean isOverflowMenuShowing() -> else
    androidx.appcompat.view.menu.MenuView access$200(androidx.appcompat.widget.ActionMenuPresenter) -> for
    void setReserveOverflow(boolean) -> for
    boolean showOverflowMenu() -> goto
    androidx.appcompat.view.menu.MenuBuilder access$100(androidx.appcompat.widget.ActionMenuPresenter) -> if
    boolean dismissPopupMenus() -> if
    androidx.appcompat.view.menu.MenuView getMenuView(android.view.ViewGroup) -> if
    void setExpandedActionViewsExclusive(boolean) -> if
    androidx.appcompat.view.menu.MenuBuilder access$300(androidx.appcompat.widget.ActionMenuPresenter) -> int
    boolean flagActionItems() -> int
    androidx.appcompat.view.menu.MenuBuilder access$400(androidx.appcompat.widget.ActionMenuPresenter) -> new
    android.graphics.drawable.Drawable getOverflowIcon() -> new
    androidx.appcompat.view.menu.MenuView access$500(androidx.appcompat.widget.ActionMenuPresenter) -> try
    android.os.Parcelable onSaveInstanceState() -> try
androidx.appcompat.widget.ActionMenuPresenter$ActionButtonSubmenu -> androidx.appcompat.widget.for$do:
    androidx.appcompat.widget.ActionMenuPresenter this$0 -> this
    void onDismiss() -> int
androidx.appcompat.widget.ActionMenuPresenter$ActionMenuPopupCallback -> androidx.appcompat.widget.for$if:
    androidx.appcompat.widget.ActionMenuPresenter this$0 -> do
    androidx.appcompat.view.menu.ShowableListMenu getPopup() -> do
androidx.appcompat.widget.ActionMenuPresenter$OpenOverflowRunnable -> androidx.appcompat.widget.for$for:
    androidx.appcompat.widget.ActionMenuPresenter this$0 -> for
    androidx.appcompat.widget.ActionMenuPresenter$OverflowPopup mPopup -> if
androidx.appcompat.widget.ActionMenuPresenter$OverflowMenuButton -> androidx.appcompat.widget.for$int:
    androidx.appcompat.widget.ActionMenuPresenter this$0 -> int
    boolean needsDividerBefore() -> do
    boolean needsDividerAfter() -> if
androidx.appcompat.widget.ActionMenuPresenter$OverflowMenuButton$1 -> androidx.appcompat.widget.for$int$do:
    androidx.appcompat.widget.ActionMenuPresenter$OverflowMenuButton this$1 -> goto
    androidx.appcompat.view.menu.ShowableListMenu getPopup() -> do
    boolean onForwardingStopped() -> for
    boolean onForwardingStarted() -> if
androidx.appcompat.widget.ActionMenuPresenter$OverflowPopup -> androidx.appcompat.widget.for$new:
    androidx.appcompat.widget.ActionMenuPresenter this$0 -> this
    void onDismiss() -> int
androidx.appcompat.widget.ActionMenuPresenter$PopupPresenterCallback -> androidx.appcompat.widget.for$try:
    androidx.appcompat.widget.ActionMenuPresenter this$0 -> if
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    boolean onOpenSubMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.widget.ActionMenuPresenter$SavedState -> androidx.appcompat.widget.for$byte:
    int openSubMenuId -> if
androidx.appcompat.widget.ActionMenuPresenter$SavedState$1 -> androidx.appcompat.widget.for$byte$do:
androidx.appcompat.widget.ActionMenuView -> androidx.appcompat.widget.ActionMenuView:
    androidx.appcompat.widget.ActionMenuPresenter mPresenter -> short
    boolean mFormatItems -> while
    int mGeneratedItemPadding -> native
    android.content.Context mPopupContext -> const
    int mPopupTheme -> final
    androidx.appcompat.view.menu.MenuBuilder$Callback mMenuBuilderCallback -> throw
    boolean mReserveOverflow -> float
    androidx.appcompat.view.menu.MenuPresenter$Callback mActionMenuPresenterCallback -> super
    int mMinCellSize -> import
    int mFormatItemsWidth -> double
    androidx.appcompat.widget.ActionMenuView$OnMenuItemClickListener mOnMenuItemClickListener -> public
    androidx.appcompat.view.menu.MenuBuilder mMenu -> class
    boolean isOverflowMenuShowPending() -> byte
    boolean isOverflowMenuShowing() -> case
    boolean isOverflowReserved() -> char
    void initialize(androidx.appcompat.view.menu.MenuBuilder) -> do
    boolean invokeItem(androidx.appcompat.view.menu.MenuItemImpl) -> do
    void setMenuCallbacks(androidx.appcompat.view.menu.MenuPresenter$Callback,androidx.appcompat.view.menu.MenuBuilder$Callback) -> do
    androidx.appcompat.view.menu.MenuBuilder peekMenu() -> else
    boolean showOverflowMenu() -> goto
    int measureChildForCells(android.view.View,int,int,int,int) -> if
    void dismissPopupMenus() -> int
    boolean hasSupportDividerBeforeChildAt(int) -> int
    androidx.appcompat.widget.ActionMenuView$LayoutParams generateOverflowButtonLayoutParams() -> new
    void onMeasureExactFormat(int,int) -> new
    boolean hideOverflowMenu() -> try
androidx.appcompat.widget.ActionMenuView$ActionMenuChildView -> androidx.appcompat.widget.ActionMenuView$do:
    boolean needsDividerBefore() -> do
    boolean needsDividerAfter() -> if
androidx.appcompat.widget.ActionMenuView$ActionMenuPresenterCallback -> androidx.appcompat.widget.ActionMenuView$if:
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    boolean onOpenSubMenu(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.widget.ActionMenuView$LayoutParams -> androidx.appcompat.widget.ActionMenuView$for:
    int cellsUsed -> int
    boolean isOverflowButton -> for
    boolean expanded -> case
    boolean preventEdgeOffset -> byte
    int extraPixels -> new
    boolean expandable -> try
androidx.appcompat.widget.ActionMenuView$MenuBuilderCallback -> androidx.appcompat.widget.ActionMenuView$int:
    androidx.appcompat.widget.ActionMenuView this$0 -> if
    boolean onMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onMenuModeChange(androidx.appcompat.view.menu.MenuBuilder) -> do
androidx.appcompat.widget.ActionMenuView$OnMenuItemClickListener -> androidx.appcompat.widget.ActionMenuView$new:
androidx.appcompat.widget.ActivityChooserView$InnerLayout -> androidx.appcompat.widget.ActivityChooserView$InnerLayout:
    int[] TINT_ATTRS -> if
androidx.appcompat.widget.AlertDialogLayout -> androidx.appcompat.widget.AlertDialogLayout:
    int resolveMinimumHeight(android.view.View) -> for
    void setChildFrame(android.view.View,int,int,int,int) -> if
    void forceUniformWidth(int,int) -> new
    boolean tryOnMeasure(int,int) -> try
androidx.appcompat.widget.AppCompatAutoCompleteTextView -> androidx.appcompat.widget.int:
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> for
    int[] TINT_ATTRS -> int
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> if
androidx.appcompat.widget.AppCompatBackgroundHelper -> androidx.appcompat.widget.new:
    android.view.View mView -> do
    androidx.appcompat.widget.TintInfo mBackgroundTint -> new
    int mBackgroundResId -> for
    androidx.appcompat.widget.AppCompatDrawableManager mDrawableManager -> if
    androidx.appcompat.widget.TintInfo mInternalBackgroundTint -> int
    androidx.appcompat.widget.TintInfo mTmpInfo -> try
    void applySupportBackgroundTint() -> do
    void loadFromAttributes(android.util.AttributeSet,int) -> do
    void onSetBackgroundDrawable(android.graphics.drawable.Drawable) -> do
    void onSetBackgroundResource(int) -> do
    void setInternalBackgroundTint(android.content.res.ColorStateList) -> do
    void setSupportBackgroundTintMode(android.graphics.PorterDuff$Mode) -> do
    android.graphics.PorterDuff$Mode getSupportBackgroundTintMode() -> for
    boolean applyFrameworkTintUsingColorFilter(android.graphics.drawable.Drawable) -> if
    android.content.res.ColorStateList getSupportBackgroundTintList() -> if
    void setSupportBackgroundTintList(android.content.res.ColorStateList) -> if
    boolean shouldApplyFrameworkTintUsingColorFilter() -> int
androidx.appcompat.widget.AppCompatButton -> androidx.appcompat.widget.try:
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> for
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> if
androidx.appcompat.widget.AppCompatCheckBox -> androidx.appcompat.widget.byte:
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> for
    androidx.appcompat.widget.AppCompatCompoundButtonHelper mCompoundButtonHelper -> if
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> int
androidx.appcompat.widget.AppCompatCheckedTextView -> androidx.appcompat.widget.case:
    int[] TINT_ATTRS -> for
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> if
androidx.appcompat.widget.AppCompatCompoundButtonHelper -> androidx.appcompat.widget.char:
    android.graphics.PorterDuff$Mode mButtonTintMode -> for
    android.widget.CompoundButton mView -> do
    boolean mHasButtonTint -> int
    boolean mHasButtonTintMode -> new
    boolean mSkipNextApply -> try
    android.content.res.ColorStateList mButtonTintList -> if
    void applyButtonTint() -> do
    int getCompoundPaddingLeft(int) -> do
    void loadFromAttributes(android.util.AttributeSet,int) -> do
    void setSupportButtonTintList(android.content.res.ColorStateList) -> do
    void setSupportButtonTintMode(android.graphics.PorterDuff$Mode) -> do
    android.graphics.PorterDuff$Mode getSupportButtonTintMode() -> for
    android.content.res.ColorStateList getSupportButtonTintList() -> if
    void onSetButtonDrawable() -> int
androidx.appcompat.widget.AppCompatDrawableManager -> androidx.appcompat.widget.else:
    androidx.appcompat.widget.AppCompatDrawableManager INSTANCE -> for
    android.graphics.PorterDuff$Mode DEFAULT_MODE -> if
    androidx.appcompat.widget.ResourceManagerInternal mResourceManager -> do
    android.graphics.PorterDuff$Mode access$000() -> do
    android.graphics.drawable.Drawable getDrawable(android.content.Context,int) -> do
    android.graphics.drawable.Drawable getDrawable(android.content.Context,int,boolean) -> do
    android.graphics.PorterDuffColorFilter getPorterDuffColorFilter(int,android.graphics.PorterDuff$Mode) -> do
    void onConfigurationChanged(android.content.Context) -> do
    void tintDrawable(android.graphics.drawable.Drawable,androidx.appcompat.widget.TintInfo,int[]) -> do
    void preload() -> for
    androidx.appcompat.widget.AppCompatDrawableManager get() -> if
    android.content.res.ColorStateList getTintList(android.content.Context,int) -> if
androidx.appcompat.widget.AppCompatDrawableManager$1 -> androidx.appcompat.widget.else$do:
    int[] COLORFILTER_COLOR_CONTROL_ACTIVATED -> for
    int[] TINT_CHECKABLE_BUTTON_LIST -> try
    int[] TINT_COLOR_CONTROL_NORMAL -> if
    int[] COLORFILTER_TINT_COLOR_CONTROL_NORMAL -> do
    int[] COLORFILTER_COLOR_BACKGROUND_MULTIPLY -> int
    int[] TINT_COLOR_CONTROL_STATE_LIST -> new
    boolean arrayContains(int[],int) -> do
    android.content.res.ColorStateList createBorderlessButtonColorStateList(android.content.Context) -> do
    android.graphics.drawable.Drawable createDrawableFor(androidx.appcompat.widget.ResourceManagerInternal,android.content.Context,int) -> do
    android.content.res.ColorStateList getTintListForDrawableRes(android.content.Context,int) -> do
    android.graphics.PorterDuff$Mode getTintModeForDrawableRes(int) -> do
    void setPorterDuffColorFilter(android.graphics.drawable.Drawable,int,android.graphics.PorterDuff$Mode) -> do
    boolean tintDrawableUsingColorFilter(android.content.Context,int,android.graphics.drawable.Drawable) -> do
    android.content.res.ColorStateList createDefaultButtonColorStateList(android.content.Context) -> for
    android.content.res.ColorStateList createButtonColorStateList(android.content.Context,int) -> if
    android.content.res.ColorStateList createColoredButtonColorStateList(android.content.Context) -> if
    boolean tintDrawable(android.content.Context,int,android.graphics.drawable.Drawable) -> if
    android.content.res.ColorStateList createSwitchThumbColorStateList(android.content.Context) -> int
androidx.appcompat.widget.AppCompatEditText -> androidx.appcompat.widget.goto:
    androidx.appcompat.widget.AppCompatTextClassifierHelper mTextClassifierHelper -> int
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> for
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> if
androidx.appcompat.widget.AppCompatHintHelper -> androidx.appcompat.widget.long:
    android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.InputConnection,android.view.inputmethod.EditorInfo,android.view.View) -> do
androidx.appcompat.widget.AppCompatImageButton -> androidx.appcompat.widget.this:
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> if
    androidx.appcompat.widget.AppCompatImageHelper mImageHelper -> for
androidx.appcompat.widget.AppCompatImageHelper -> androidx.appcompat.widget.void:
    android.widget.ImageView mView -> do
    androidx.appcompat.widget.TintInfo mImageTint -> for
    androidx.appcompat.widget.TintInfo mInternalImageTint -> if
    androidx.appcompat.widget.TintInfo mTmpInfo -> int
    boolean applyFrameworkTintUsingColorFilter(android.graphics.drawable.Drawable) -> do
    void applySupportImageTint() -> do
    void loadFromAttributes(android.util.AttributeSet,int) -> do
    void setImageResource(int) -> do
    void setSupportImageTintList(android.content.res.ColorStateList) -> do
    void setSupportImageTintMode(android.graphics.PorterDuff$Mode) -> do
    android.graphics.PorterDuff$Mode getSupportImageTintMode() -> for
    android.content.res.ColorStateList getSupportImageTintList() -> if
    boolean hasOverlappingRendering() -> int
    boolean shouldApplyFrameworkTintUsingColorFilter() -> new
androidx.appcompat.widget.AppCompatImageView -> androidx.appcompat.widget.break:
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> if
    androidx.appcompat.widget.AppCompatImageHelper mImageHelper -> for
androidx.appcompat.widget.AppCompatMultiAutoCompleteTextView -> androidx.appcompat.widget.catch:
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> for
    int[] TINT_ATTRS -> int
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> if
androidx.appcompat.widget.AppCompatPopupWindow -> androidx.appcompat.widget.class:
    boolean mOverlapAnchor -> do
    boolean COMPAT_OVERLAP_ANCHOR -> if
    void init(android.content.Context,android.util.AttributeSet,int,int) -> do
    void setSupportOverlapAnchor(boolean) -> do
androidx.appcompat.widget.AppCompatProgressBarHelper -> androidx.appcompat.widget.const:
    android.graphics.Bitmap mSampleTile -> if
    int[] TINT_ATTRS -> for
    android.widget.ProgressBar mView -> do
    android.graphics.Bitmap getSampleTile() -> do
    void loadFromAttributes(android.util.AttributeSet,int) -> do
    android.graphics.drawable.Drawable tileify(android.graphics.drawable.Drawable,boolean) -> do
    android.graphics.drawable.Drawable tileifyIndeterminate(android.graphics.drawable.Drawable) -> do
    android.graphics.drawable.shapes.Shape getDrawableShape() -> if
androidx.appcompat.widget.AppCompatRadioButton -> androidx.appcompat.widget.final:
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> for
    androidx.appcompat.widget.AppCompatCompoundButtonHelper mCompoundButtonHelper -> if
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> int
androidx.appcompat.widget.AppCompatRatingBar -> androidx.appcompat.widget.float:
    androidx.appcompat.widget.AppCompatProgressBarHelper mAppCompatProgressBarHelper -> if
androidx.appcompat.widget.AppCompatSeekBar -> androidx.appcompat.widget.short:
    androidx.appcompat.widget.AppCompatSeekBarHelper mAppCompatSeekBarHelper -> if
androidx.appcompat.widget.AppCompatSeekBarHelper -> androidx.appcompat.widget.super:
    android.graphics.drawable.Drawable mTickMark -> new
    android.widget.SeekBar mView -> int
    android.graphics.PorterDuff$Mode mTickMarkTintMode -> byte
    boolean mHasTickMarkTint -> case
    android.content.res.ColorStateList mTickMarkTintList -> try
    boolean mHasTickMarkTintMode -> char
    void drawTickMarks(android.graphics.Canvas) -> do
    void loadFromAttributes(android.util.AttributeSet,int) -> do
    void drawableStateChanged() -> for
    void setTickMark(android.graphics.drawable.Drawable) -> if
    void jumpDrawablesToCurrentState() -> int
    void applyTickMarkTint() -> new
androidx.appcompat.widget.AppCompatSpinner -> androidx.appcompat.widget.throw:
    androidx.appcompat.widget.AppCompatSpinner$SpinnerPopup mPopup -> byte
    int[] ATTRS_ANDROID_SPINNERMODE -> else
    android.widget.SpinnerAdapter mTempAdapter -> new
    android.content.Context mPopupContext -> for
    boolean mPopupSet -> try
    int mDropDownWidth -> case
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> if
    androidx.appcompat.widget.ForwardingListener mForwardingListener -> int
    android.graphics.Rect mTempRect -> char
    int compatMeasureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable) -> do
    void showPopup() -> do
androidx.appcompat.widget.AppCompatSpinner$1 -> androidx.appcompat.widget.throw$do:
    androidx.appcompat.widget.AppCompatSpinner this$0 -> long
    androidx.appcompat.widget.AppCompatSpinner$DropdownPopup val$popup -> goto
    androidx.appcompat.view.menu.ShowableListMenu getPopup() -> do
    boolean onForwardingStarted() -> if
androidx.appcompat.widget.AppCompatSpinner$2 -> androidx.appcompat.widget.throw$if:
    androidx.appcompat.widget.AppCompatSpinner this$0 -> if
androidx.appcompat.widget.AppCompatSpinner$DialogPopup -> androidx.appcompat.widget.throw$for:
    androidx.appcompat.widget.AppCompatSpinner this$0 -> new
    java.lang.CharSequence mPrompt -> int
    android.widget.ListAdapter mListAdapter -> for
    androidx.appcompat.app.AlertDialog mPopup -> if
    android.graphics.drawable.Drawable getBackground() -> byte
    boolean isShowing() -> do
    void setAdapter(android.widget.ListAdapter) -> do
    void setBackgroundDrawable(android.graphics.drawable.Drawable) -> do
    void setHorizontalOffset(int) -> do
    void setPromptText(java.lang.CharSequence) -> do
    void show(int,int) -> do
    java.lang.CharSequence getHintText() -> for
    void setHorizontalOriginalOffset(int) -> for
    void setVerticalOffset(int) -> if
    int getHorizontalOffset() -> int
    int getVerticalOffset() -> try
androidx.appcompat.widget.AppCompatSpinner$DropDownAdapter -> androidx.appcompat.widget.throw$int:
    android.widget.SpinnerAdapter mAdapter -> if
    android.widget.ListAdapter mListAdapter -> for
androidx.appcompat.widget.AppCompatSpinner$DropdownPopup -> androidx.appcompat.widget.throw$new:
    android.widget.ListAdapter mAdapter -> package
    int mOriginalHorizontalOffset -> abstract
    android.graphics.Rect mVisibleRect -> private
    java.lang.CharSequence mHintText -> finally
    androidx.appcompat.widget.AppCompatSpinner this$0 -> continue
    void computeContentWidth() -> break
    int getHorizontalOriginalOffset() -> catch
    void access$001(androidx.appcompat.widget.AppCompatSpinner$DropdownPopup) -> do
    void setAdapter(android.widget.ListAdapter) -> do
    void setPromptText(java.lang.CharSequence) -> do
    void show(int,int) -> do
    java.lang.CharSequence getHintText() -> for
    void setHorizontalOriginalOffset(int) -> for
    boolean isVisibleToUser(android.view.View) -> if
androidx.appcompat.widget.AppCompatSpinner$DropdownPopup$1 -> androidx.appcompat.widget.throw$new$do:
    androidx.appcompat.widget.AppCompatSpinner$DropdownPopup this$1 -> if
androidx.appcompat.widget.AppCompatSpinner$DropdownPopup$2 -> androidx.appcompat.widget.throw$new$if:
    androidx.appcompat.widget.AppCompatSpinner$DropdownPopup this$1 -> if
androidx.appcompat.widget.AppCompatSpinner$DropdownPopup$3 -> androidx.appcompat.widget.throw$new$for:
    android.view.ViewTreeObserver$OnGlobalLayoutListener val$layoutListener -> if
    androidx.appcompat.widget.AppCompatSpinner$DropdownPopup this$1 -> for
androidx.appcompat.widget.AppCompatSpinner$SavedState -> androidx.appcompat.widget.throw$try:
    boolean mShowDropdown -> if
androidx.appcompat.widget.AppCompatSpinner$SavedState$1 -> androidx.appcompat.widget.throw$try$do:
androidx.appcompat.widget.AppCompatSpinner$SpinnerPopup -> androidx.appcompat.widget.throw$byte:
    android.graphics.drawable.Drawable getBackground() -> byte
    boolean isShowing() -> do
    void setAdapter(android.widget.ListAdapter) -> do
    void setBackgroundDrawable(android.graphics.drawable.Drawable) -> do
    void setHorizontalOffset(int) -> do
    void setPromptText(java.lang.CharSequence) -> do
    void show(int,int) -> do
    java.lang.CharSequence getHintText() -> for
    void setHorizontalOriginalOffset(int) -> for
    void setVerticalOffset(int) -> if
    int getHorizontalOffset() -> int
    int getVerticalOffset() -> try
androidx.appcompat.widget.AppCompatTextClassifierHelper -> androidx.appcompat.widget.while:
    android.view.textclassifier.TextClassifier mTextClassifier -> if
    android.widget.TextView mTextView -> do
    android.view.textclassifier.TextClassifier getTextClassifier() -> do
    void setTextClassifier(android.view.textclassifier.TextClassifier) -> do
androidx.appcompat.widget.AppCompatTextHelper -> androidx.appcompat.widget.double:
    androidx.appcompat.widget.TintInfo mDrawableBottomTint -> new
    boolean mAsyncFontPending -> this
    androidx.appcompat.widget.TintInfo mDrawableTopTint -> for
    androidx.appcompat.widget.TintInfo mDrawableLeftTint -> if
    androidx.appcompat.widget.TintInfo mDrawableRightTint -> int
    androidx.appcompat.widget.TintInfo mDrawableStartTint -> try
    int mFontWeight -> goto
    androidx.appcompat.widget.TintInfo mDrawableEndTint -> byte
    int mStyle -> else
    androidx.appcompat.widget.AppCompatTextViewAutoSizeHelper mAutoSizeTextHelper -> char
    android.widget.TextView mView -> do
    androidx.appcompat.widget.TintInfo mDrawableTint -> case
    android.graphics.Typeface mFontTypeface -> long
    int getAutoSizeTextType() -> byte
    android.content.res.ColorStateList getCompoundDrawableTintList() -> case
    android.graphics.PorterDuff$Mode getCompoundDrawableTintMode() -> char
    void applyCompoundDrawableTint(android.graphics.drawable.Drawable,androidx.appcompat.widget.TintInfo) -> do
    void applyCompoundDrawablesTints() -> do
    androidx.appcompat.widget.TintInfo createTintInfo(android.content.Context,androidx.appcompat.widget.AppCompatDrawableManager,int) -> do
    void loadFromAttributes(android.util.AttributeSet,int) -> do
    void onLayout(boolean,int,int,int,int) -> do
    void onSetTextAppearance(android.content.Context,int) -> do
    void runOnUiThread(java.lang.Runnable) -> do
    void setAllCaps(boolean) -> do
    void setAutoSizeTextTypeUniformWithConfiguration(int,int,int,int) -> do
    void setAutoSizeTextTypeUniformWithPresetSizes(int[],int) -> do
    void setAutoSizeTextTypeWithDefaults(int) -> do
    void setCompoundDrawableTintList(android.content.res.ColorStateList) -> do
    void setCompoundDrawableTintMode(android.graphics.PorterDuff$Mode) -> do
    void setCompoundDrawables(android.graphics.drawable.Drawable,android.graphics.drawable.Drawable,android.graphics.drawable.Drawable,android.graphics.drawable.Drawable,android.graphics.drawable.Drawable,android.graphics.drawable.Drawable) -> do
    void setTextSize(int,float) -> do
    void setTypefaceByCallback(android.graphics.Typeface) -> do
    void updateTypefaceAndStyle(android.content.Context,androidx.appcompat.widget.TintTypedArray) -> do
    boolean isAutoSizeEnabled() -> else
    int getAutoSizeMaxTextSize() -> for
    void onSetCompoundDrawables() -> goto
    void autoSizeText() -> if
    void setTextSizeInternal(int,float) -> if
    int getAutoSizeMinTextSize() -> int
    void setCompoundTints() -> long
    int getAutoSizeStepGranularity() -> new
    int[] getAutoSizeTextAvailableSizes() -> try
androidx.appcompat.widget.AppCompatTextHelper$ApplyTextViewCallback -> androidx.appcompat.widget.double$do:
    java.lang.ref.WeakReference mParent -> do
    int mFontWeight -> if
    int mStyle -> for
    void onFontRetrievalFailed(int) -> do
    void onFontRetrieved(android.graphics.Typeface) -> do
androidx.appcompat.widget.AppCompatTextHelper$ApplyTextViewCallback$TypefaceApplyCallback -> androidx.appcompat.widget.double$do$do:
    android.graphics.Typeface mTypeface -> for
    java.lang.ref.WeakReference mParent -> if
androidx.appcompat.widget.AppCompatTextView -> androidx.appcompat.widget.import:
    java.util.concurrent.Future mPrecomputedTextFuture -> new
    androidx.appcompat.widget.AppCompatTextClassifierHelper mTextClassifierHelper -> int
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> for
    androidx.appcompat.widget.AppCompatBackgroundHelper mBackgroundTintHelper -> if
    void consumeTextFutureAndSetBlocking() -> int
androidx.appcompat.widget.AppCompatTextViewAutoSizeHelper -> androidx.appcompat.widget.native:
    android.graphics.RectF TEMP_RECTF -> goto
    android.text.TextPaint mTempTextPaint -> case
    int mAutoSizeTextType -> do
    int[] mAutoSizeTextSizesInPx -> try
    java.util.concurrent.ConcurrentHashMap sTextViewMethodByNameCache -> long
    float mAutoSizeMinTextSizeInPx -> int
    float mAutoSizeStepGranularityInPx -> for
    android.widget.TextView mTextView -> char
    boolean mNeedsAutoSizeText -> if
    java.util.concurrent.ConcurrentHashMap sTextViewFieldByNameCache -> this
    boolean mHasPresetAutoSizeValues -> byte
    android.content.Context mContext -> else
    float mAutoSizeMaxTextSizeInPx -> new
    boolean isAutoSizeEnabled() -> byte
    void clearAutoSizeConfiguration() -> case
    boolean setupAutoSizeText() -> char
    java.lang.Object accessAndReturnWithDefault(java.lang.Object,java.lang.String,java.lang.Object) -> do
    void autoSizeText() -> do
    int[] cleanupAutoSizePresetSizes(int[]) -> do
    android.text.StaticLayout createLayout(java.lang.CharSequence,android.text.Layout$Alignment,int,int) -> do
    android.text.StaticLayout createStaticLayoutForMeasuringPre16(java.lang.CharSequence,android.text.Layout$Alignment,int) -> do
    int findLargestTextSizeWhichFits(android.graphics.RectF) -> do
    java.lang.reflect.Field getTextViewField(java.lang.String) -> do
    void initTempTextPaint(int) -> do
    void loadFromAttributes(android.util.AttributeSet,int) -> do
    void setAutoSizeTextTypeUniformWithConfiguration(int,int,int,int) -> do
    void setAutoSizeTextTypeUniformWithPresetSizes(int[],int) -> do
    void setRawTextSize(float) -> do
    void setTextSizeInternal(int,float) -> do
    void setupAutoSizeUniformPresetSizes(android.content.res.TypedArray) -> do
    boolean suggestedSizeFitsInSpace(int,android.graphics.RectF) -> do
    void validateAndSetAutoSizeTextTypeUniformConfiguration(float,float,float) -> do
    boolean setupAutoSizeUniformPresetSizesConfiguration() -> else
    int getAutoSizeMinTextSize() -> for
    boolean supportsAutoSizeText() -> goto
    android.text.StaticLayout createStaticLayoutForMeasuring(java.lang.CharSequence,android.text.Layout$Alignment,int,int) -> if
    android.text.StaticLayout createStaticLayoutForMeasuringPre23(java.lang.CharSequence,android.text.Layout$Alignment,int) -> if
    int getAutoSizeMaxTextSize() -> if
    java.lang.reflect.Method getTextViewMethod(java.lang.String) -> if
    java.lang.Object invokeAndReturnWithDefault(java.lang.Object,java.lang.String,java.lang.Object) -> if
    void setAutoSizeTextTypeWithDefaults(int) -> if
    int getAutoSizeStepGranularity() -> int
    int[] getAutoSizeTextAvailableSizes() -> new
    int getAutoSizeTextType() -> try
androidx.appcompat.widget.AppCompatToggleButton -> androidx.appcompat.widget.public:
    androidx.appcompat.widget.AppCompatTextHelper mTextHelper -> if
androidx.appcompat.widget.ButtonBarLayout -> androidx.appcompat.widget.ButtonBarLayout:
    int mMinimumHeight -> int
    boolean mAllowStacking -> if
    int mLastWidthSize -> for
    int getNextVisibleChildIndex(int) -> do
    boolean isStacked() -> do
androidx.appcompat.widget.ContentFrameLayout -> androidx.appcompat.widget.ContentFrameLayout:
    android.util.TypedValue mFixedWidthMinor -> new
    android.util.TypedValue mFixedHeightMinor -> byte
    android.graphics.Rect mDecorPadding -> case
    androidx.appcompat.widget.ContentFrameLayout$OnAttachListener mAttachListener -> char
    android.util.TypedValue mMinWidthMajor -> if
    android.util.TypedValue mFixedWidthMajor -> int
    android.util.TypedValue mMinWidthMinor -> for
    android.util.TypedValue mFixedHeightMajor -> try
    void dispatchFitSystemWindows(android.graphics.Rect) -> do
    void setDecorPadding(int,int,int,int) -> do
androidx.appcompat.widget.ContentFrameLayout$OnAttachListener -> androidx.appcompat.widget.ContentFrameLayout$do:
    void onAttachedFromWindow() -> do
androidx.appcompat.widget.DecorContentParent -> androidx.appcompat.widget.return:
    void dismissPopups() -> byte
    void initFeature(int) -> do
    void setMenu(android.view.Menu,androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    boolean showOverflowMenu() -> do
    void setMenuPrepared() -> for
    boolean isOverflowMenuShowPending() -> if
    boolean isOverflowMenuShowing() -> int
    boolean canShowOverflowMenu() -> new
    boolean hideOverflowMenu() -> try
androidx.appcompat.widget.DecorToolbar -> androidx.appcompat.widget.static:
    int getNavigationMode() -> break
    void dismissPopupMenus() -> byte
    int getDisplayOptions() -> case
    void initProgress() -> char
    void setEmbeddedTabView(androidx.appcompat.widget.ScrollingTabContainerView) -> do
    void setHomeButtonEnabled(boolean) -> do
    void setMenu(android.view.Menu,androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void setMenuCallbacks(androidx.appcompat.view.menu.MenuPresenter$Callback,androidx.appcompat.view.menu.MenuBuilder$Callback) -> do
    void setNavigationIcon(android.graphics.drawable.Drawable) -> do
    void setVisibility(int) -> do
    androidx.core.view.ViewPropertyAnimatorCompat setupAnimatorToVisibility(int,long) -> do
    boolean showOverflowMenu() -> do
    android.view.Menu getMenu() -> else
    void setMenuPrepared() -> for
    void setNavigationContentDescription(int) -> for
    boolean hasExpandedActionView() -> goto
    boolean isOverflowMenuShowPending() -> if
    void setCollapsible(boolean) -> if
    void setLogo(int) -> if
    boolean isOverflowMenuShowing() -> int
    void setDisplayOptions(int) -> int
    android.view.ViewGroup getViewGroup() -> long
    boolean canShowOverflowMenu() -> new
    void initIndeterminateProgress() -> this
    boolean hideOverflowMenu() -> try
    android.content.Context getContext() -> void
androidx.appcompat.widget.DrawableUtils -> androidx.appcompat.widget.switch:
    int[] EMPTY_STATE_SET -> if
    int[] CHECKED_STATE_SET -> do
    boolean canSafelyMutateDrawable(android.graphics.drawable.Drawable) -> do
    android.graphics.PorterDuff$Mode parseTintMode(int,android.graphics.PorterDuff$Mode) -> do
    void fixVectorDrawableTinting(android.graphics.drawable.Drawable) -> for
    void fixDrawable(android.graphics.drawable.Drawable) -> if
androidx.appcompat.widget.DropDownListView -> androidx.appcompat.widget.throws:
    androidx.core.view.ViewPropertyAnimatorCompat mClickAnimation -> this
    android.graphics.Rect mSelectorRect -> if
    int mSelectionBottomPadding -> try
    boolean mDrawsInPressedState -> long
    androidx.appcompat.widget.DropDownListView$GateKeeperDrawable mSelector -> char
    androidx.appcompat.widget.DropDownListView$ResolveHoverRunnable mResolveHoverRunnable -> break
    int mSelectionTopPadding -> int
    boolean mListSelectionHidden -> else
    int mSelectionLeftPadding -> for
    int mMotionPosition -> byte
    int mSelectionRightPadding -> new
    androidx.core.widget.ListViewAutoScrollHelper mScrollHelper -> void
    boolean mHijackFocus -> goto
    java.lang.reflect.Field mIsChildViewEnabled -> case
    void clearPressedItem() -> do
    void clickPressedItem(android.view.View,int) -> do
    void drawSelectorCompat(android.graphics.Canvas) -> do
    int measureHeightOfChildrenCompat(int,int,int,int,int) -> do
    boolean onForwardedEvent(android.view.MotionEvent,int) -> do
    void positionSelectorCompat(int,android.view.View) -> do
    void positionSelectorLikeTouchCompat(int,android.view.View,float,float) -> do
    void setPressedItem(android.view.View,int,float,float) -> do
    void updateSelectorStateCompat() -> for
    void positionSelectorLikeFocusCompat(int,android.view.View) -> if
    boolean touchModeDrawsInPressedStateCompat() -> if
androidx.appcompat.widget.DropDownListView$GateKeeperDrawable -> androidx.appcompat.widget.throws$do:
    boolean mEnabled -> for
    void setEnabled(boolean) -> do
androidx.appcompat.widget.DropDownListView$ResolveHoverRunnable -> androidx.appcompat.widget.throws$if:
    androidx.appcompat.widget.DropDownListView this$0 -> if
    void cancel() -> do
    void post() -> if
androidx.appcompat.widget.FitWindowsFrameLayout -> androidx.appcompat.widget.FitWindowsFrameLayout:
    androidx.appcompat.widget.FitWindowsViewGroup$OnFitSystemWindowsListener mListener -> if
androidx.appcompat.widget.FitWindowsLinearLayout -> androidx.appcompat.widget.FitWindowsLinearLayout:
    androidx.appcompat.widget.FitWindowsViewGroup$OnFitSystemWindowsListener mListener -> if
androidx.appcompat.widget.FitWindowsViewGroup -> androidx.appcompat.widget.boolean:
androidx.appcompat.widget.FitWindowsViewGroup$OnFitSystemWindowsListener -> androidx.appcompat.widget.boolean$do:
    void onFitSystemWindows(android.graphics.Rect) -> do
androidx.appcompat.widget.ForwardingListener -> androidx.appcompat.widget.default:
    int mLongPressTimeout -> int
    java.lang.Runnable mTriggerLongPress -> byte
    java.lang.Runnable mDisallowIntercept -> try
    boolean mForwarding -> case
    int[] mTmpLocation -> else
    android.view.View mSrc -> new
    int mTapTimeout -> for
    int mActivePointerId -> char
    float mScaledTouchSlop -> if
    androidx.appcompat.view.menu.ShowableListMenu getPopup() -> do
    boolean onTouchForwarded(android.view.MotionEvent) -> do
    boolean pointInView(android.view.View,float,float,float) -> do
    boolean toGlobalMotionEvent(android.view.View,android.view.MotionEvent) -> do
    boolean onForwardingStopped() -> for
    boolean onForwardingStarted() -> if
    boolean onTouchObserved(android.view.MotionEvent) -> if
    boolean toLocalMotionEvent(android.view.View,android.view.MotionEvent) -> if
    void onLongPress() -> int
    void clearCallbacks() -> new
androidx.appcompat.widget.ForwardingListener$DisallowIntercept -> androidx.appcompat.widget.default$do:
    androidx.appcompat.widget.ForwardingListener this$0 -> if
androidx.appcompat.widget.ForwardingListener$TriggerLongPress -> androidx.appcompat.widget.default$if:
    androidx.appcompat.widget.ForwardingListener this$0 -> if
androidx.appcompat.widget.LinearLayoutCompat -> androidx.appcompat.widget.extends:
    int mShowDividers -> break
    android.graphics.drawable.Drawable mDivider -> long
    int mDividerWidth -> this
    int[] mMaxAscent -> else
    int mDividerPadding -> catch
    int mGravity -> try
    boolean mUseLargestChild -> char
    int mDividerHeight -> void
    int mBaselineChildTop -> int
    int[] mMaxDescent -> goto
    boolean mBaselineAligned -> if
    int mBaselineAlignedChildIndex -> for
    int mTotalLength -> byte
    int mOrientation -> new
    float mWeightSum -> case
    void drawDividersHorizontal(android.graphics.Canvas) -> do
    void drawHorizontalDivider(android.graphics.Canvas,int) -> do
    int getChildrenSkipCount(android.view.View,int) -> do
    int getLocationOffset(android.view.View) -> do
    android.view.View getVirtualChildAt(int) -> do
    void layoutHorizontal(int,int,int,int) -> do
    void measureChildBeforeLayout(android.view.View,int,int,int,int,int) -> do
    void measureHorizontal(int,int) -> do
    void setChildFrame(android.view.View,int,int,int,int) -> do
    void forceUniformHeight(int,int) -> for
    int measureNullChild(int) -> for
    void drawDividersVertical(android.graphics.Canvas) -> if
    void drawVerticalDivider(android.graphics.Canvas,int) -> if
    int getNextLocationOffset(android.view.View) -> if
    boolean hasDividerBeforeChildAt(int) -> if
    void layoutVertical(int,int,int,int) -> if
    void measureVertical(int,int) -> if
    void forceUniformWidth(int,int) -> int
androidx.appcompat.widget.LinearLayoutCompat$LayoutParams -> androidx.appcompat.widget.extends$do:
    float weight -> do
    int gravity -> if
androidx.appcompat.widget.ListPopupWindow -> androidx.appcompat.widget.finally:
    android.content.Context mContext -> if
    android.widget.AdapterView$OnItemClickListener mItemClickListener -> super
    int mDropDownGravity -> this
    boolean mForceIgnoreOutsideTouch -> break
    androidx.appcompat.widget.ListPopupWindow$ListSelectorHider mHideSelector -> native
    androidx.appcompat.widget.ListPopupWindow$PopupScrollListener mScrollListener -> import
    boolean mDropDownVerticalOffsetSet -> else
    android.os.Handler mHandler -> public
    android.widget.PopupWindow mPopup -> throws
    boolean mDropDownAlwaysVisible -> void
    android.graphics.Rect mTempRect -> return
    int mDropDownVerticalOffset -> case
    androidx.appcompat.widget.DropDownListView mDropDownList -> int
    boolean mOverlapAnchor -> goto
    java.lang.reflect.Method sSetEpicenterBoundsMethod -> extends
    androidx.appcompat.widget.ListPopupWindow$PopupTouchInterceptor mTouchInterceptor -> double
    boolean mModal -> switch
    java.lang.reflect.Method sGetMaxAvailableHeightMethod -> default
    int mListItemExpandMaximum -> catch
    int mDropDownWidth -> try
    boolean mOverlapAnchorSet -> long
    int mPromptPosition -> const
    android.graphics.Rect mEpicenterBounds -> static
    android.view.View mPromptView -> class
    androidx.appcompat.widget.ListPopupWindow$ResizePopupRunnable mResizePopupRunnable -> while
    java.lang.reflect.Method sSetClipToWindowEnabledMethod -> boolean
    android.database.DataSetObserver mObserver -> final
    android.widget.AdapterView$OnItemSelectedListener mItemSelectedListener -> throw
    int mDropDownHorizontalOffset -> byte
    android.view.View mDropDownAnchorView -> float
    int mDropDownHeight -> new
    int mDropDownWindowLayoutType -> char
    android.graphics.drawable.Drawable mDropDownListHighlight -> short
    android.widget.ListAdapter mAdapter -> for
    android.graphics.drawable.Drawable getBackground() -> byte
    void setInputMethodMode(int) -> byte
    void clearListSelection() -> case
    void setPromptPosition(int) -> case
    android.view.View getAnchorView() -> char
    void setSelection(int) -> char
    androidx.appcompat.widget.DropDownListView createDropDownListView(android.content.Context,boolean) -> do
    int getMaxAvailableHeight(android.view.View,int,boolean) -> do
    boolean isShowing() -> do
    void setAdapter(android.widget.ListAdapter) -> do
    void setAnchorView(android.view.View) -> do
    void setBackgroundDrawable(android.graphics.drawable.Drawable) -> do
    void setEpicenterBounds(android.graphics.Rect) -> do
    void setHorizontalOffset(int) -> do
    void setModal(boolean) -> do
    void setOnDismissListener(android.widget.PopupWindow$OnDismissListener) -> do
    void setOnItemClickListener(android.widget.AdapterView$OnItemClickListener) -> do
    int getWidth() -> else
    void setWidth(int) -> else
    void setPopupClipToScreenEnabled(boolean) -> for
    boolean isInputMethodNotNeeded() -> goto
    void setOverlapAnchor(boolean) -> if
    void setVerticalOffset(int) -> if
    void show() -> if
    int getHorizontalOffset() -> int
    void setAnimationStyle(int) -> int
    boolean isModal() -> long
    android.widget.ListView getListView() -> new
    void setContentWidth(int) -> new
    int buildDropDown() -> this
    int getVerticalOffset() -> try
    void setDropDownGravity(int) -> try
    void removePromptView() -> void
androidx.appcompat.widget.ListPopupWindow$2 -> androidx.appcompat.widget.finally$do:
    androidx.appcompat.widget.ListPopupWindow this$0 -> if
androidx.appcompat.widget.ListPopupWindow$3 -> androidx.appcompat.widget.finally$if:
    androidx.appcompat.widget.ListPopupWindow this$0 -> if
androidx.appcompat.widget.ListPopupWindow$ListSelectorHider -> androidx.appcompat.widget.finally$for:
    androidx.appcompat.widget.ListPopupWindow this$0 -> if
androidx.appcompat.widget.ListPopupWindow$PopupDataSetObserver -> androidx.appcompat.widget.finally$int:
    androidx.appcompat.widget.ListPopupWindow this$0 -> do
androidx.appcompat.widget.ListPopupWindow$PopupScrollListener -> androidx.appcompat.widget.finally$new:
    androidx.appcompat.widget.ListPopupWindow this$0 -> do
androidx.appcompat.widget.ListPopupWindow$PopupTouchInterceptor -> androidx.appcompat.widget.finally$try:
    androidx.appcompat.widget.ListPopupWindow this$0 -> if
androidx.appcompat.widget.ListPopupWindow$ResizePopupRunnable -> androidx.appcompat.widget.finally$byte:
    androidx.appcompat.widget.ListPopupWindow this$0 -> if
androidx.appcompat.widget.MenuItemHoverListener -> androidx.appcompat.widget.package:
    void onItemHoverEnter(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onItemHoverExit(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> if
androidx.appcompat.widget.MenuPopupWindow -> androidx.appcompat.widget.private:
    java.lang.reflect.Method sSetTouchModalMethod -> package
    androidx.appcompat.widget.MenuItemHoverListener mHoverListener -> finally
    androidx.appcompat.widget.DropDownListView createDropDownListView(android.content.Context,boolean) -> do
    void onItemHoverEnter(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void setEnterTransition(java.lang.Object) -> do
    void setHoverListener(androidx.appcompat.widget.MenuItemHoverListener) -> do
    void onItemHoverExit(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> if
    void setExitTransition(java.lang.Object) -> if
    void setTouchModal(boolean) -> int
androidx.appcompat.widget.MenuPopupWindow$MenuDropDownListView -> androidx.appcompat.widget.private$do:
    int mRetreatKey -> class
    androidx.appcompat.widget.MenuItemHoverListener mHoverListener -> const
    int mAdvanceKey -> catch
    android.view.MenuItem mHoveredMenuItem -> final
    int measureHeightOfChildrenCompat(int,int,int,int,int) -> do
    boolean onForwardedEvent(android.view.MotionEvent,int) -> do
androidx.appcompat.widget.ResourceManagerInternal -> androidx.appcompat.widget.abstract:
    android.util.TypedValue mTypedValue -> new
    androidx.appcompat.widget.ResourceManagerInternal INSTANCE -> char
    java.util.WeakHashMap mTintLists -> do
    androidx.collection.ArrayMap mDelegates -> if
    androidx.appcompat.widget.ResourceManagerInternal$ColorFilterLruCache COLOR_FILTER_CACHE -> else
    androidx.appcompat.widget.ResourceManagerInternal$ResourceManagerHooks mHooks -> byte
    boolean mHasCheckedVectorDrawableSetup -> try
    androidx.collection.SparseArrayCompat mKnownDrawableIdTags -> for
    java.util.WeakHashMap mDrawableCaches -> int
    android.graphics.PorterDuff$Mode DEFAULT_MODE -> case
    void addDelegate(java.lang.String,androidx.appcompat.widget.ResourceManagerInternal$InflateDelegate) -> do
    boolean addDrawableToCache(android.content.Context,long,android.graphics.drawable.Drawable) -> do
    void addTintListToCache(android.content.Context,int,android.content.res.ColorStateList) -> do
    long createCacheKey(android.util.TypedValue) -> do
    android.graphics.PorterDuffColorFilter createTintFilter(android.content.res.ColorStateList,android.graphics.PorterDuff$Mode,int[]) -> do
    androidx.appcompat.widget.ResourceManagerInternal get() -> do
    android.graphics.drawable.Drawable getCachedDrawable(android.content.Context,long) -> do
    android.graphics.drawable.Drawable getDrawable(android.content.Context,int) -> do
    android.graphics.drawable.Drawable getDrawable(android.content.Context,int,boolean) -> do
    android.graphics.PorterDuffColorFilter getPorterDuffColorFilter(int,android.graphics.PorterDuff$Mode) -> do
    android.graphics.PorterDuff$Mode getTintMode(int) -> do
    void installDefaultInflateDelegates(androidx.appcompat.widget.ResourceManagerInternal) -> do
    boolean isVectorDrawable(android.graphics.drawable.Drawable) -> do
    void onConfigurationChanged(android.content.Context) -> do
    android.graphics.drawable.Drawable onDrawableLoadedFromResources(android.content.Context,androidx.appcompat.widget.VectorEnabledTintResources,int) -> do
    void setHooks(androidx.appcompat.widget.ResourceManagerInternal$ResourceManagerHooks) -> do
    android.graphics.drawable.Drawable tintDrawable(android.content.Context,int,boolean,android.graphics.drawable.Drawable) -> do
    void tintDrawable(android.graphics.drawable.Drawable,androidx.appcompat.widget.TintInfo,int[]) -> do
    boolean tintDrawableUsingColorFilter(android.content.Context,int,android.graphics.drawable.Drawable) -> do
    android.graphics.drawable.Drawable createDrawableIfNeeded(android.content.Context,int) -> for
    void checkVectorDrawableSetup(android.content.Context) -> if
    android.content.res.ColorStateList getTintList(android.content.Context,int) -> if
    android.content.res.ColorStateList getTintListFromCache(android.content.Context,int) -> int
    android.graphics.drawable.Drawable loadDrawableFromDelegates(android.content.Context,int) -> new
androidx.appcompat.widget.ResourceManagerInternal$AsldcInflateDelegate -> androidx.appcompat.widget.abstract$do:
    android.graphics.drawable.Drawable createFromXmlInner(android.content.Context,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
androidx.appcompat.widget.ResourceManagerInternal$AvdcInflateDelegate -> androidx.appcompat.widget.abstract$if:
    android.graphics.drawable.Drawable createFromXmlInner(android.content.Context,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
androidx.appcompat.widget.ResourceManagerInternal$ColorFilterLruCache -> androidx.appcompat.widget.abstract$for:
    android.graphics.PorterDuffColorFilter get(int,android.graphics.PorterDuff$Mode) -> do
    android.graphics.PorterDuffColorFilter put(int,android.graphics.PorterDuff$Mode,android.graphics.PorterDuffColorFilter) -> do
    int generateCacheKey(int,android.graphics.PorterDuff$Mode) -> if
androidx.appcompat.widget.ResourceManagerInternal$InflateDelegate -> androidx.appcompat.widget.abstract$int:
    android.graphics.drawable.Drawable createFromXmlInner(android.content.Context,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
androidx.appcompat.widget.ResourceManagerInternal$ResourceManagerHooks -> androidx.appcompat.widget.abstract$new:
    android.graphics.drawable.Drawable createDrawableFor(androidx.appcompat.widget.ResourceManagerInternal,android.content.Context,int) -> do
    android.content.res.ColorStateList getTintListForDrawableRes(android.content.Context,int) -> do
    android.graphics.PorterDuff$Mode getTintModeForDrawableRes(int) -> do
    boolean tintDrawableUsingColorFilter(android.content.Context,int,android.graphics.drawable.Drawable) -> do
    boolean tintDrawable(android.content.Context,int,android.graphics.drawable.Drawable) -> if
androidx.appcompat.widget.ResourceManagerInternal$VdcInflateDelegate -> androidx.appcompat.widget.abstract$try:
    android.graphics.drawable.Drawable createFromXmlInner(android.content.Context,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
androidx.appcompat.widget.ResourcesWrapper -> androidx.appcompat.widget.continue:
    android.content.res.Resources mResources -> do
androidx.appcompat.widget.RtlSpacingHelper -> androidx.appcompat.widget.strictfp:
    int mRight -> if
    int mEnd -> int
    boolean mIsRelative -> case
    int mLeft -> do
    int mStart -> for
    boolean mIsRtl -> byte
    int mExplicitLeft -> new
    int mExplicitRight -> try
    int getEnd() -> do
    void setAbsolute(int,int) -> do
    void setDirection(boolean) -> do
    int getRight() -> for
    int getLeft() -> if
    void setRelative(int,int) -> if
    int getStart() -> int
androidx.appcompat.widget.ScrollingTabContainerView -> androidx.appcompat.widget.volatile:
    androidx.appcompat.widget.ScrollingTabContainerView$TabClickListener mTabClickListener -> for
    int mSelectedTabIndex -> else
    int mMaxTabWidth -> byte
    java.lang.Runnable mTabSelector -> if
    androidx.appcompat.widget.LinearLayoutCompat mTabLayout -> int
    android.widget.Spinner mTabSpinner -> new
    boolean mAllowCollapse -> try
    int mContentHeight -> char
    int mStackedTabMaxWidth -> case
    void animateToTab(int) -> do
    android.widget.Spinner createSpinner() -> do
    androidx.appcompat.widget.ScrollingTabContainerView$TabView createTabView(androidx.appcompat.app.ActionBar$Tab,boolean) -> do
    void performCollapse() -> for
    boolean isCollapsed() -> if
    boolean performExpand() -> int
androidx.appcompat.widget.ScrollingTabContainerView$1 -> androidx.appcompat.widget.volatile$do:
    android.view.View val$tabView -> if
    androidx.appcompat.widget.ScrollingTabContainerView this$0 -> for
androidx.appcompat.widget.ScrollingTabContainerView$TabAdapter -> androidx.appcompat.widget.volatile$if:
    androidx.appcompat.widget.ScrollingTabContainerView this$0 -> if
androidx.appcompat.widget.ScrollingTabContainerView$TabClickListener -> androidx.appcompat.widget.volatile$for:
    androidx.appcompat.widget.ScrollingTabContainerView this$0 -> if
androidx.appcompat.widget.ScrollingTabContainerView$TabView -> androidx.appcompat.widget.volatile$int:
    android.widget.TextView mTextView -> int
    android.widget.ImageView mIconView -> new
    androidx.appcompat.widget.ScrollingTabContainerView this$0 -> byte
    int[] BG_ATTRS -> if
    android.view.View mCustomView -> try
    androidx.appcompat.app.ActionBar$Tab mTab -> for
    void bindTab(androidx.appcompat.app.ActionBar$Tab) -> do
    androidx.appcompat.app.ActionBar$Tab getTab() -> do
    void update() -> if
androidx.appcompat.widget.SearchView -> androidx.appcompat.widget.SearchView:
    java.lang.CharSequence mUserQuery -> ʿ
    int[] mTemp2 -> static
    android.app.SearchableInfo mSearchable -> ˉ
    android.widget.ImageView mGoButton -> super
    androidx.appcompat.widget.SearchView$UpdatableTouchDelegate mTouchDelegate -> import
    android.os.Bundle mAppSearchData -> ˊ
    androidx.appcompat.widget.SearchView$AutoCompleteTextViewReflector HIDDEN_METHOD_INVOKER -> ᵎ
    boolean mSubmitButtonEnabled -> implements
    android.widget.ImageView mCloseButton -> throw
    android.graphics.drawable.Drawable mSearchHintIcon -> throws
    int[] mTemp -> return
    boolean mClearingFocus -> ʻ
    android.view.View$OnClickListener mOnClickListener -> ˑ
    androidx.appcompat.widget.SearchView$SearchAutoComplete mSearchSrcTextView -> class
    boolean mIconifiedByDefault -> interface
    android.widget.ImageView mVoiceButton -> while
    androidx.appcompat.widget.SearchView$OnSuggestionListener mOnSuggestionListener -> strictfp
    java.lang.Runnable mReleaseCursorRunnable -> ˎ
    androidx.appcompat.widget.SearchView$OnCloseListener mOnCloseListener -> abstract
    java.lang.CharSequence mOldQueryText -> ʾ
    android.view.View$OnFocusChangeListener mOnQueryTextFocusChangeListener -> continue
    int mSuggestionCommitIconResId -> default
    int mCollapsedImeOptions -> ˈ
    int mMaxWidth -> ʼ
    androidx.cursoradapter.widget.CursorAdapter mSuggestionsAdapter -> transient
    android.view.View mSubmitArea -> float
    android.widget.ImageView mCollapsedIcon -> switch
    java.lang.CharSequence mQueryHint -> instanceof
    android.graphics.Rect mSearchSrtTextViewBoundsExpanded -> public
    android.graphics.Rect mSearchSrcTextViewBounds -> native
    android.content.Intent mVoiceWebSearchIntent -> extends
    android.view.View mSearchPlate -> final
    android.text.TextWatcher mTextWatcher -> ᴵ
    android.widget.AdapterView$OnItemClickListener mOnItemClickListener -> ٴ
    android.view.View mDropDownAnchor -> double
    boolean mVoiceButtonEnabled -> ʽ
    android.widget.ImageView mSearchButton -> short
    android.content.Intent mVoiceAppSearchIntent -> finally
    int mSuggestionRowLayout -> boolean
    boolean mIconified -> protected
    android.view.View$OnKeyListener mTextKeyListener -> י
    android.view.View mSearchEditFrame -> const
    android.view.View$OnClickListener mOnSearchClickListener -> volatile
    boolean mQueryRefinement -> synchronized
    androidx.appcompat.widget.SearchView$OnQueryTextListener mOnQueryChangeListener -> private
    java.util.WeakHashMap mOutsideDrawablesCache -> ˏ
    android.widget.AdapterView$OnItemSelectedListener mOnItemSelectedListener -> ᐧ
    java.lang.CharSequence mDefaultQueryHint -> package
    boolean mExpandedInActionView -> ˆ
    java.lang.Runnable mUpdateDrawableStateRunnable -> ˋ
    android.widget.TextView$OnEditorActionListener mOnEditorActionListener -> ـ
    boolean isSubmitAreaEnabled() -> break
    void onCloseClicked() -> byte
    void onSearchClicked() -> case
    void postUpdateFocusedState() -> catch
    void onSubmitQuery() -> char
    void updateCloseButton() -> class
    void updateQueryHint() -> const
    android.content.Intent createIntent(java.lang.String,android.net.Uri,java.lang.String,java.lang.String,int,java.lang.String) -> do
    android.content.Intent createIntentFromSuggestion(android.database.Cursor,int,java.lang.String) -> do
    android.content.Intent createVoiceAppSearchIntent(android.content.Intent,android.app.SearchableInfo) -> do
    void getChildBoundsWithinSearchView(android.view.View,android.graphics.Rect) -> do
    boolean isLandscapeMode(android.content.Context) -> do
    void launchIntent(android.content.Intent) -> do
    void launchQuerySearch(int,java.lang.String,java.lang.String) -> do
    void onActionViewExpanded() -> do
    boolean onItemClicked(int,int,java.lang.String) -> do
    void onQueryRefine(java.lang.CharSequence) -> do
    boolean onSuggestionsKey(android.view.View,int,android.view.KeyEvent) -> do
    void setQuery(java.lang.CharSequence,boolean) -> do
    void updateSubmitButton(boolean) -> do
    void onTextFocusChanged() -> else
    void updateSearchAutoComplete() -> final
    void updateSubmitArea() -> float
    java.lang.CharSequence getDecoratedHint(java.lang.CharSequence) -> for
    void updateVoiceButton(boolean) -> for
    void onVoiceClicked() -> goto
    android.content.Intent createVoiceWebSearchIntent(android.content.Intent,android.app.SearchableInfo) -> if
    boolean launchSuggestion(int,int,java.lang.String) -> if
    void onActionViewCollapsed() -> if
    void onTextChanged(java.lang.CharSequence) -> if
    void updateViewsVisibility(boolean) -> if
    void adjustDropDownSizeAndPosition() -> int
    boolean onItemSelected(int) -> int
    void updateFocusedState() -> long
    void forceSuggestionQuery() -> new
    void rewriteQueryFromSuggestion(int) -> new
    void dismissSuggestions() -> this
    boolean isIconified() -> try
    boolean hasVoiceSearch() -> void
androidx.appcompat.widget.SearchView$1 -> androidx.appcompat.widget.SearchView$if:
    androidx.appcompat.widget.SearchView this$0 -> if
androidx.appcompat.widget.SearchView$10 -> androidx.appcompat.widget.SearchView$do:
    androidx.appcompat.widget.SearchView this$0 -> if
androidx.appcompat.widget.SearchView$2 -> androidx.appcompat.widget.SearchView$for:
    androidx.appcompat.widget.SearchView this$0 -> if
androidx.appcompat.widget.SearchView$3 -> androidx.appcompat.widget.SearchView$int:
    androidx.appcompat.widget.SearchView this$0 -> if
androidx.appcompat.widget.SearchView$4 -> androidx.appcompat.widget.SearchView$new:
    androidx.appcompat.widget.SearchView this$0 -> do
androidx.appcompat.widget.SearchView$5 -> androidx.appcompat.widget.SearchView$try:
    androidx.appcompat.widget.SearchView this$0 -> if
androidx.appcompat.widget.SearchView$6 -> androidx.appcompat.widget.SearchView$byte:
    androidx.appcompat.widget.SearchView this$0 -> if
androidx.appcompat.widget.SearchView$7 -> androidx.appcompat.widget.SearchView$case:
    androidx.appcompat.widget.SearchView this$0 -> do
androidx.appcompat.widget.SearchView$8 -> androidx.appcompat.widget.SearchView$char:
    androidx.appcompat.widget.SearchView this$0 -> if
androidx.appcompat.widget.SearchView$9 -> androidx.appcompat.widget.SearchView$else:
    androidx.appcompat.widget.SearchView this$0 -> if
androidx.appcompat.widget.SearchView$AutoCompleteTextViewReflector -> androidx.appcompat.widget.SearchView$goto:
    java.lang.reflect.Method doAfterTextChanged -> if
    java.lang.reflect.Method ensureImeVisible -> for
    java.lang.reflect.Method doBeforeTextChanged -> do
    void doAfterTextChanged(android.widget.AutoCompleteTextView) -> do
    void ensureImeVisible(android.widget.AutoCompleteTextView,boolean) -> do
    void doBeforeTextChanged(android.widget.AutoCompleteTextView) -> if
androidx.appcompat.widget.SearchView$OnCloseListener -> androidx.appcompat.widget.SearchView$long:
    boolean onClose() -> do
androidx.appcompat.widget.SearchView$OnQueryTextListener -> androidx.appcompat.widget.SearchView$this:
    boolean onQueryTextSubmit(java.lang.String) -> do
    boolean onQueryTextChange(java.lang.String) -> if
androidx.appcompat.widget.SearchView$OnSuggestionListener -> androidx.appcompat.widget.SearchView$void:
    boolean onSuggestionSelect(int) -> do
    boolean onSuggestionClick(int) -> if
androidx.appcompat.widget.SearchView$SavedState -> androidx.appcompat.widget.SearchView$break:
    boolean isIconified -> int
androidx.appcompat.widget.SearchView$SavedState$1 -> androidx.appcompat.widget.SearchView$break$do:
androidx.appcompat.widget.SearchView$SearchAutoComplete -> androidx.appcompat.widget.SearchView$SearchAutoComplete:
    boolean mHasPendingShowSoftInputRequest -> byte
    int mThreshold -> new
    java.lang.Runnable mRunShowSoftInputIfNecessary -> case
    androidx.appcompat.widget.SearchView mSearchView -> try
    boolean isEmpty() -> do
    void showSoftInputIfNecessary() -> if
androidx.appcompat.widget.SearchView$SearchAutoComplete$1 -> androidx.appcompat.widget.SearchView$SearchAutoComplete$do:
    androidx.appcompat.widget.SearchView$SearchAutoComplete this$0 -> if
androidx.appcompat.widget.SearchView$UpdatableTouchDelegate -> androidx.appcompat.widget.SearchView$catch:
    android.graphics.Rect mTargetBounds -> if
    android.view.View mDelegateView -> do
    android.graphics.Rect mSlopBounds -> int
    android.graphics.Rect mActualBounds -> for
    int mSlop -> new
    boolean mDelegateTargeted -> try
    void setBounds(android.graphics.Rect,android.graphics.Rect) -> do
androidx.appcompat.widget.SuggestionsAdapter -> androidx.appcompat.widget.interface:
    android.content.res.ColorStateList mUrlColor -> float
    android.app.SearchableInfo mSearchable -> void
    int mIconName1Col -> while
    int mFlagsCol -> import
    int mCommitIconResId -> class
    int mIconName2Col -> double
    androidx.appcompat.widget.SearchView mSearchView -> this
    int mText2UrlCol -> throw
    int mText2Col -> super
    int mQueryRefinement -> final
    android.content.Context mProviderContext -> break
    java.util.WeakHashMap mOutsideDrawablesCache -> catch
    boolean mClosed -> const
    int mText1Col -> short
    void updateSpinnerState(android.database.Cursor) -> byte
    void bindView(android.view.View,android.content.Context,android.database.Cursor) -> do
    android.graphics.drawable.Drawable checkIconCache(java.lang.String) -> do
    java.lang.CharSequence convertToString(android.database.Cursor) -> do
    android.graphics.drawable.Drawable getActivityIcon(android.content.ComponentName) -> do
    java.lang.String getColumnString(android.database.Cursor,java.lang.String) -> do
    android.graphics.drawable.Drawable getDrawableFromResourceUri(android.net.Uri) -> do
    android.database.Cursor getSearchManagerSuggestions(android.app.SearchableInfo,java.lang.String,int) -> do
    java.lang.String getStringOrNull(android.database.Cursor,int) -> do
    android.database.Cursor runQueryOnBackgroundThread(java.lang.CharSequence) -> do
    void setQueryRefinement(int) -> do
    void setViewDrawable(android.widget.ImageView,android.graphics.drawable.Drawable,int) -> do
    void setViewText(android.widget.TextView,java.lang.CharSequence) -> do
    void storeInIconCache(java.lang.String,android.graphics.drawable.Drawable) -> do
    void changeCursor(android.database.Cursor) -> if
    java.lang.CharSequence formatUrl(java.lang.CharSequence) -> if
    android.graphics.drawable.Drawable getActivityIconWithCache(android.content.ComponentName) -> if
    android.graphics.drawable.Drawable getDrawable(android.net.Uri) -> if
    android.graphics.drawable.Drawable getDrawableFromResourceValue(java.lang.String) -> if
    android.view.View newView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> if
    android.graphics.drawable.Drawable getDefaultIcon1(android.database.Cursor) -> int
    android.graphics.drawable.Drawable getIcon1(android.database.Cursor) -> new
    android.graphics.drawable.Drawable getIcon2(android.database.Cursor) -> try
androidx.appcompat.widget.SuggestionsAdapter$ChildViewCache -> androidx.appcompat.widget.interface$do:
    android.widget.ImageView mIcon1 -> for
    android.widget.ImageView mIconRefine -> new
    android.widget.ImageView mIcon2 -> int
    android.widget.TextView mText1 -> do
    android.widget.TextView mText2 -> if
androidx.appcompat.widget.ThemeUtils -> androidx.appcompat.widget.protected:
    int[] TEMP_ARRAY -> byte
    java.lang.ThreadLocal TL_TYPED_VALUE -> do
    int[] FOCUSED_STATE_SET -> for
    int[] EMPTY_STATE_SET -> try
    int[] DISABLED_STATE_SET -> if
    int[] PRESSED_STATE_SET -> int
    int[] CHECKED_STATE_SET -> new
    int getDisabledThemeAttrColor(android.content.Context,int) -> do
    int getThemeAttrColor(android.content.Context,int,float) -> do
    android.util.TypedValue getTypedValue() -> do
    android.content.res.ColorStateList getThemeAttrColorStateList(android.content.Context,int) -> for
    int getThemeAttrColor(android.content.Context,int) -> if
androidx.appcompat.widget.ThemedSpinnerAdapter -> androidx.appcompat.widget.transient:
androidx.appcompat.widget.TintContextWrapper -> androidx.appcompat.widget.implements:
    java.util.ArrayList sCache -> int
    java.lang.Object CACHE_LOCK -> for
    android.content.res.Resources mResources -> do
    android.content.res.Resources$Theme mTheme -> if
    boolean shouldWrap(android.content.Context) -> do
    android.content.Context wrap(android.content.Context) -> if
androidx.appcompat.widget.TintInfo -> androidx.appcompat.widget.instanceof:
    boolean mHasTintMode -> for
    boolean mHasTintList -> int
    android.graphics.PorterDuff$Mode mTintMode -> if
    android.content.res.ColorStateList mTintList -> do
    void clear() -> do
androidx.appcompat.widget.TintResources -> androidx.appcompat.widget.synchronized:
    java.lang.ref.WeakReference mContextRef -> if
androidx.appcompat.widget.TintTypedArray -> androidx.appcompat.widget.ʻ:
    android.content.res.TypedArray mWrapped -> if
    android.util.TypedValue mTypedValue -> for
    android.content.Context mContext -> do
    int getResourceId(int,int) -> byte
    boolean hasValue(int) -> byte
    boolean getBoolean(int,boolean) -> do
    int getColor(int,int) -> do
    android.content.res.ColorStateList getColorStateList(int) -> do
    float getDimension(int,float) -> do
    android.graphics.Typeface getFont(int,int,androidx.core.content.res.ResourcesCompat$FontCallback) -> do
    androidx.appcompat.widget.TintTypedArray obtainStyledAttributes(android.content.Context,int,int[]) -> do
    androidx.appcompat.widget.TintTypedArray obtainStyledAttributes(android.content.Context,android.util.AttributeSet,int[]) -> do
    androidx.appcompat.widget.TintTypedArray obtainStyledAttributes(android.content.Context,android.util.AttributeSet,int[],int,int) -> do
    void recycle() -> do
    int getDimensionPixelSize(int,int) -> for
    android.graphics.drawable.Drawable getDrawableIfKnown(int) -> for
    int getDimensionPixelOffset(int,int) -> if
    android.graphics.drawable.Drawable getDrawable(int) -> if
    float getFloat(int,float) -> if
    int getInt(int,int) -> int
    java.lang.String getString(int) -> int
    int getInteger(int,int) -> new
    java.lang.CharSequence getText(int) -> new
    int getLayoutDimension(int,int) -> try
    java.lang.CharSequence[] getTextArray(int) -> try
androidx.appcompat.widget.Toolbar -> androidx.appcompat.widget.Toolbar:
    int mTitleTextAppearance -> this
    android.widget.ImageButton mCollapseButtonView -> char
    java.lang.CharSequence mCollapseDescription -> case
    boolean mCollapsible -> strictfp
    androidx.appcompat.widget.ToolbarWidgetWrapper mWrapper -> finally
    androidx.appcompat.widget.ActionMenuView mMenuView -> if
    android.widget.TextView mSubtitleTextView -> int
    android.content.res.ColorStateList mSubtitleTextColor -> public
    android.widget.ImageButton mNavButtonView -> new
    int mPopupTheme -> long
    androidx.appcompat.widget.ActionMenuPresenter mOuterActionMenuPresenter -> package
    androidx.appcompat.widget.ActionMenuView$OnMenuItemClickListener mMenuViewItemClickListener -> extends
    androidx.appcompat.widget.Toolbar$ExpandedActionViewMenuPresenter mExpandedMenuPresenter -> private
    android.content.Context mPopupContext -> goto
    int mButtonGravity -> break
    int mGravity -> while
    int[] mTempMargins -> boolean
    androidx.appcompat.widget.RtlSpacingHelper mContentInsets -> short
    int mTitleMarginStart -> class
    int mTitleMarginBottom -> float
    android.graphics.drawable.Drawable mCollapseIcon -> byte
    android.widget.ImageView mLogoView -> try
    android.widget.TextView mTitleTextView -> for
    int mMaxButtonHeight -> catch
    int mContentInsetEndWithActions -> throw
    boolean mEatingTouch -> return
    int mTitleMarginEnd -> const
    android.view.View mExpandedActionView -> else
    androidx.appcompat.view.menu.MenuPresenter$Callback mActionMenuPresenterCallback -> abstract
    androidx.appcompat.view.menu.MenuBuilder$Callback mMenuBuilderCallback -> continue
    int mSubtitleTextAppearance -> void
    int mContentInsetStartWithNavigation -> super
    java.util.ArrayList mTempViews -> switch
    java.lang.Runnable mShowOverflowMenuRunnable -> volatile
    int mTitleMarginTop -> final
    android.content.res.ColorStateList mTitleTextColor -> native
    java.util.ArrayList mHiddenViews -> throws
    androidx.appcompat.widget.Toolbar$OnMenuItemClickListener mOnMenuItemClickListener -> default
    java.lang.CharSequence mSubtitleText -> import
    java.lang.CharSequence mTitleText -> double
    boolean mEatingHover -> static
    void ensureMenuView() -> break
    boolean hideOverflowMenu() -> byte
    boolean isOverflowMenuShowPending() -> case
    void ensureNavButtonView() -> catch
    boolean isOverflowMenuShowing() -> char
    void postShowOverflowMenu() -> class
    boolean shouldCollapse() -> const
    void addChildrenForExpandedActionView() -> do
    void addCustomViewsWithGravity(java.util.List,int) -> do
    void addSystemView(android.view.View,boolean) -> do
    int getChildTop(android.view.View,int) -> do
    int getHorizontalMargins(android.view.View) -> do
    int getViewListMeasuredWidth(java.util.List,int[]) -> do
    void inflateMenu(int) -> do
    int layoutChildLeft(android.view.View,int,int[],int) -> do
    int measureChildCollapseMargins(android.view.View,int,int,int,int,int[]) -> do
    void measureChildConstrained(android.view.View,int,int,int,int,int) -> do
    void setContentInsetsRelative(int,int) -> do
    void setMenu(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.widget.ActionMenuPresenter) -> do
    void setMenuCallbacks(androidx.appcompat.view.menu.MenuPresenter$Callback,androidx.appcompat.view.menu.MenuBuilder$Callback) -> do
    void setSubtitleTextAppearance(android.content.Context,int) -> do
    void removeChildrenForExpandedActionView() -> else
    void collapseActionView() -> for
    int getChildVerticalGravity(int) -> for
    boolean isChildOrHidden(android.view.View) -> for
    boolean showOverflowMenu() -> goto
    boolean canShowOverflowMenu() -> if
    int getChildHorizontalGravity(int) -> if
    int getVerticalMargins(android.view.View) -> if
    int layoutChildRight(android.view.View,int,int[],int) -> if
    void setTitleTextAppearance(android.content.Context,int) -> if
    void dismissPopupMenus() -> int
    boolean shouldLayout(android.view.View) -> int
    void ensureContentInsets() -> long
    void ensureCollapseButtonView() -> new
    void ensureLogoView() -> this
    boolean hasExpandedActionView() -> try
    void ensureMenu() -> void
androidx.appcompat.widget.Toolbar$1 -> androidx.appcompat.widget.Toolbar$do:
    androidx.appcompat.widget.Toolbar this$0 -> do
androidx.appcompat.widget.Toolbar$2 -> androidx.appcompat.widget.Toolbar$if:
    androidx.appcompat.widget.Toolbar this$0 -> if
androidx.appcompat.widget.Toolbar$3 -> androidx.appcompat.widget.Toolbar$for:
    androidx.appcompat.widget.Toolbar this$0 -> if
androidx.appcompat.widget.Toolbar$ExpandedActionViewMenuPresenter -> androidx.appcompat.widget.Toolbar$int:
    androidx.appcompat.view.menu.MenuItemImpl mCurrentExpandedItem -> for
    androidx.appcompat.widget.Toolbar this$0 -> int
    androidx.appcompat.view.menu.MenuBuilder mMenu -> if
    boolean expandItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> do
    void initForMenu(android.content.Context,androidx.appcompat.view.menu.MenuBuilder) -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    boolean onSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    void setCallback(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void updateMenuView(boolean) -> do
    int getId() -> for
    boolean collapseItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> if
    boolean flagActionItems() -> int
    android.os.Parcelable onSaveInstanceState() -> try
androidx.appcompat.widget.Toolbar$LayoutParams -> androidx.appcompat.widget.Toolbar$new:
    int mViewType -> if
    void copyMarginsFromCompat(android.view.ViewGroup$MarginLayoutParams) -> do
androidx.appcompat.widget.Toolbar$OnMenuItemClickListener -> androidx.appcompat.widget.Toolbar$try:
androidx.appcompat.widget.Toolbar$SavedState -> androidx.appcompat.widget.Toolbar$byte:
    int expandedMenuItemId -> int
    boolean isOverflowOpen -> new
androidx.appcompat.widget.Toolbar$SavedState$1 -> androidx.appcompat.widget.Toolbar$byte$do:
androidx.appcompat.widget.ToolbarWidgetWrapper -> androidx.appcompat.widget.ʼ:
    android.view.View mTabView -> for
    int mNavigationMode -> break
    java.lang.CharSequence mSubtitle -> else
    boolean mTitleSet -> case
    boolean mMenuPrepared -> this
    android.graphics.drawable.Drawable mDefaultNavigationIcon -> class
    java.lang.CharSequence mTitle -> char
    android.view.View mCustomView -> int
    android.graphics.drawable.Drawable mNavIcon -> byte
    java.lang.CharSequence mHomeDescription -> goto
    int mDefaultNavigationContentDescription -> catch
    androidx.appcompat.widget.Toolbar mToolbar -> do
    android.graphics.drawable.Drawable mIcon -> new
    androidx.appcompat.widget.ActionMenuPresenter mActionMenuPresenter -> void
    int mDisplayOpts -> if
    android.graphics.drawable.Drawable mLogo -> try
    android.view.Window$Callback mWindowCallback -> long
    int getNavigationMode() -> break
    void dismissPopupMenus() -> byte
    int getDisplayOptions() -> case
    int detectDisplayOptions() -> catch
    void initProgress() -> char
    void updateHomeAccessibility() -> class
    void updateNavigationIcon() -> const
    void setCustomView(android.view.View) -> do
    void setEmbeddedTabView(androidx.appcompat.widget.ScrollingTabContainerView) -> do
    void setHomeButtonEnabled(boolean) -> do
    void setMenu(android.view.Menu,androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void setMenuCallbacks(androidx.appcompat.view.menu.MenuPresenter$Callback,androidx.appcompat.view.menu.MenuBuilder$Callback) -> do
    void setNavigationContentDescription(java.lang.CharSequence) -> do
    void setNavigationIcon(android.graphics.drawable.Drawable) -> do
    void setVisibility(int) -> do
    androidx.core.view.ViewPropertyAnimatorCompat setupAnimatorToVisibility(int,long) -> do
    boolean showOverflowMenu() -> do
    android.view.Menu getMenu() -> else
    void updateToolbarLogo() -> final
    void setMenuPrepared() -> for
    void setNavigationContentDescription(int) -> for
    void setTitle(java.lang.CharSequence) -> for
    boolean hasExpandedActionView() -> goto
    boolean isOverflowMenuShowPending() -> if
    void setCollapsible(boolean) -> if
    void setLogo(int) -> if
    void setLogo(android.graphics.drawable.Drawable) -> if
    void setSubtitle(java.lang.CharSequence) -> if
    boolean isOverflowMenuShowing() -> int
    void setDisplayOptions(int) -> int
    void setTitleInt(java.lang.CharSequence) -> int
    android.view.ViewGroup getViewGroup() -> long
    boolean canShowOverflowMenu() -> new
    void setDefaultNavigationContentDescription(int) -> new
    void initIndeterminateProgress() -> this
    boolean hideOverflowMenu() -> try
    android.content.Context getContext() -> void
androidx.appcompat.widget.ToolbarWidgetWrapper$1 -> androidx.appcompat.widget.ʼ$do:
    androidx.appcompat.view.menu.ActionMenuItem mNavItem -> if
    androidx.appcompat.widget.ToolbarWidgetWrapper this$0 -> for
androidx.appcompat.widget.ToolbarWidgetWrapper$2 -> androidx.appcompat.widget.ʼ$if:
    boolean mCanceled -> do
    int val$visibility -> if
    androidx.appcompat.widget.ToolbarWidgetWrapper this$0 -> for
    void onAnimationEnd(android.view.View) -> do
    void onAnimationCancel(android.view.View) -> for
    void onAnimationStart(android.view.View) -> if
androidx.appcompat.widget.TooltipCompat -> androidx.appcompat.widget.ʽ:
    void setTooltipText(android.view.View,java.lang.CharSequence) -> do
androidx.appcompat.widget.TooltipCompatHandler -> androidx.appcompat.widget.ʾ:
    int mHoverSlop -> int
    boolean mFromTouch -> else
    java.lang.Runnable mHideRunnable -> try
    androidx.appcompat.widget.TooltipPopup mPopup -> char
    androidx.appcompat.widget.TooltipCompatHandler sActiveHandler -> long
    android.view.View mAnchor -> if
    int mAnchorX -> byte
    androidx.appcompat.widget.TooltipCompatHandler sPendingHandler -> goto
    java.lang.CharSequence mTooltipText -> for
    int mAnchorY -> case
    java.lang.Runnable mShowRunnable -> new
    void hide() -> do
    void setPendingHandler(androidx.appcompat.widget.TooltipCompatHandler) -> do
    void setTooltipText(android.view.View,java.lang.CharSequence) -> do
    void show(boolean) -> do
    boolean updateAnchorPos(android.view.MotionEvent) -> do
    void clearAnchorPos() -> for
    void cancelPendingShow() -> if
    void scheduleShow() -> int
androidx.appcompat.widget.TooltipCompatHandler$1 -> androidx.appcompat.widget.ʾ$do:
    androidx.appcompat.widget.TooltipCompatHandler this$0 -> if
androidx.appcompat.widget.TooltipCompatHandler$2 -> androidx.appcompat.widget.ʾ$if:
    androidx.appcompat.widget.TooltipCompatHandler this$0 -> if
androidx.appcompat.widget.TooltipPopup -> androidx.appcompat.widget.ʿ:
    int[] mTmpAppPos -> byte
    android.view.WindowManager$LayoutParams mLayoutParams -> int
    android.graphics.Rect mTmpDisplayFrame -> new
    android.view.View mContentView -> if
    int[] mTmpAnchorPos -> try
    android.widget.TextView mMessageView -> for
    android.content.Context mContext -> do
    void computePosition(android.view.View,int,int,boolean,android.view.WindowManager$LayoutParams) -> do
    android.view.View getAppRootView(android.view.View) -> do
    void hide() -> do
    void show(android.view.View,int,int,boolean,java.lang.CharSequence) -> do
    boolean isShowing() -> if
androidx.appcompat.widget.VectorEnabledTintResources -> androidx.appcompat.widget.ˆ:
    java.lang.ref.WeakReference mContextRef -> do
    boolean sCompatVectorFromResourcesEnabled -> if
    boolean isCompatVectorFromResourcesEnabled() -> do
    android.graphics.drawable.Drawable superGetDrawable(int) -> do
    boolean shouldBeUsed() -> if
androidx.appcompat.widget.ViewStubCompat -> androidx.appcompat.widget.ViewStubCompat:
    int mLayoutResource -> if
    android.view.LayoutInflater mInflater -> new
    int mInflatedId -> for
    androidx.appcompat.widget.ViewStubCompat$OnInflateListener mInflateListener -> try
    java.lang.ref.WeakReference mInflatedViewRef -> int
    android.view.View inflate() -> do
androidx.appcompat.widget.ViewStubCompat$OnInflateListener -> androidx.appcompat.widget.ViewStubCompat$do:
    void onInflate(androidx.appcompat.widget.ViewStubCompat,android.view.View) -> do
androidx.appcompat.widget.ViewUtils -> androidx.appcompat.widget.ˈ:
    java.lang.reflect.Method sComputeFitSystemWindowsMethod -> do
    void computeFitSystemWindows(android.view.View,android.graphics.Rect,android.graphics.Rect) -> do
    boolean isLayoutRtl(android.view.View) -> do
    void makeOptionalFitsSystemWindows(android.view.View) -> if
androidx.appcompat.widget.WithHint -> androidx.appcompat.widget.ˉ:
    java.lang.CharSequence getHint() -> do
androidx.arch.core.executor.ArchTaskExecutor -> if.if.do.do.do:
    androidx.arch.core.executor.TaskExecutor mDefaultTaskExecutor -> if
    androidx.arch.core.executor.TaskExecutor mDelegate -> do
    androidx.arch.core.executor.ArchTaskExecutor sInstance -> for
    void executeOnDiskIO(java.lang.Runnable) -> do
    boolean isMainThread() -> do
    androidx.arch.core.executor.ArchTaskExecutor getInstance() -> if
    void postToMainThread(java.lang.Runnable) -> if
androidx.arch.core.executor.ArchTaskExecutor$1 -> if.if.do.do.do$do:
androidx.arch.core.executor.ArchTaskExecutor$2 -> if.if.do.do.do$if:
androidx.arch.core.executor.DefaultTaskExecutor -> if.if.do.do.if:
    java.lang.Object mLock -> do
    java.util.concurrent.ExecutorService mDiskIO -> if
    android.os.Handler mMainHandler -> for
    void executeOnDiskIO(java.lang.Runnable) -> do
    boolean isMainThread() -> do
    void postToMainThread(java.lang.Runnable) -> if
androidx.arch.core.executor.DefaultTaskExecutor$1 -> if.if.do.do.if$do:
    java.util.concurrent.atomic.AtomicInteger mThreadId -> do
androidx.arch.core.executor.TaskExecutor -> if.if.do.do.for:
    void executeOnDiskIO(java.lang.Runnable) -> do
    boolean isMainThread() -> do
    void postToMainThread(java.lang.Runnable) -> if
androidx.arch.core.internal.FastSafeIterableMap -> if.if.do.if.do:
    java.util.HashMap mHashMap -> try
    androidx.arch.core.internal.SafeIterableMap$Entry get(java.lang.Object) -> do
    java.util.Map$Entry ceil(java.lang.Object) -> if
    java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object) -> if
androidx.arch.core.internal.SafeIterableMap -> if.if.do.if.if:
    androidx.arch.core.internal.SafeIterableMap$Entry mStart -> if
    androidx.arch.core.internal.SafeIterableMap$Entry mEnd -> for
    int mSize -> new
    java.util.WeakHashMap mIterators -> int
    java.util.Iterator descendingIterator() -> do
    androidx.arch.core.internal.SafeIterableMap$Entry get(java.lang.Object) -> do
    androidx.arch.core.internal.SafeIterableMap$Entry put(java.lang.Object,java.lang.Object) -> do
    androidx.arch.core.internal.SafeIterableMap$IteratorWithAdditions iteratorWithAdditions() -> for
    java.util.Map$Entry eldest() -> if
    java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object) -> if
    java.util.Map$Entry newest() -> int
androidx.arch.core.internal.SafeIterableMap$AscendingIterator -> if.if.do.if.if$do:
    androidx.arch.core.internal.SafeIterableMap$Entry forward(androidx.arch.core.internal.SafeIterableMap$Entry) -> for
    androidx.arch.core.internal.SafeIterableMap$Entry backward(androidx.arch.core.internal.SafeIterableMap$Entry) -> if
androidx.arch.core.internal.SafeIterableMap$DescendingIterator -> if.if.do.if.if$if:
    androidx.arch.core.internal.SafeIterableMap$Entry forward(androidx.arch.core.internal.SafeIterableMap$Entry) -> for
    androidx.arch.core.internal.SafeIterableMap$Entry backward(androidx.arch.core.internal.SafeIterableMap$Entry) -> if
androidx.arch.core.internal.SafeIterableMap$Entry -> if.if.do.if.if$for:
    java.lang.Object mValue -> for
    java.lang.Object mKey -> if
    androidx.arch.core.internal.SafeIterableMap$Entry mPrevious -> new
    androidx.arch.core.internal.SafeIterableMap$Entry mNext -> int
androidx.arch.core.internal.SafeIterableMap$IteratorWithAdditions -> if.if.do.if.if$int:
    androidx.arch.core.internal.SafeIterableMap$Entry mCurrent -> if
    boolean mBeforeStart -> for
    androidx.arch.core.internal.SafeIterableMap this$0 -> int
    void supportRemove(androidx.arch.core.internal.SafeIterableMap$Entry) -> do
androidx.arch.core.internal.SafeIterableMap$ListIterator -> if.if.do.if.if$new:
    androidx.arch.core.internal.SafeIterableMap$Entry mExpectedEnd -> if
    androidx.arch.core.internal.SafeIterableMap$Entry mNext -> for
    androidx.arch.core.internal.SafeIterableMap$Entry nextNode() -> do
    void supportRemove(androidx.arch.core.internal.SafeIterableMap$Entry) -> do
    androidx.arch.core.internal.SafeIterableMap$Entry forward(androidx.arch.core.internal.SafeIterableMap$Entry) -> for
    androidx.arch.core.internal.SafeIterableMap$Entry backward(androidx.arch.core.internal.SafeIterableMap$Entry) -> if
androidx.arch.core.internal.SafeIterableMap$SupportRemove -> if.if.do.if.if$try:
    void supportRemove(androidx.arch.core.internal.SafeIterableMap$Entry) -> do
androidx.cardview.R$attr -> if.for.do:
androidx.cardview.R$color -> if.for.if:
androidx.cardview.R$dimen -> if.for.for:
androidx.cardview.R$style -> if.for.int:
androidx.cardview.R$styleable -> if.for.new:
androidx.cardview.widget.CardView -> androidx.cardview.widget.CardView:
    int mUserSetMinWidth -> int
    android.graphics.Rect mContentPadding -> try
    int[] COLOR_BACKGROUND_ATTR -> char
    boolean mPreventCornerOverlap -> for
    androidx.cardview.widget.CardViewImpl IMPL -> else
    boolean mCompatPadding -> if
    android.graphics.Rect mShadowBounds -> byte
    int mUserSetMinHeight -> new
    androidx.cardview.widget.CardViewDelegate mCardViewDelegate -> case
    void access$001(androidx.cardview.widget.CardView,int,int,int,int) -> do
    void access$101(androidx.cardview.widget.CardView,int) -> do
    void access$201(androidx.cardview.widget.CardView,int) -> if
androidx.cardview.widget.CardView$1 -> androidx.cardview.widget.CardView$do:
    android.graphics.drawable.Drawable mCardBackground -> do
    androidx.cardview.widget.CardView this$0 -> if
    android.view.View getCardView() -> do
    void setCardBackground(android.graphics.drawable.Drawable) -> do
    void setMinWidthHeightInternal(int,int) -> do
    void setShadowPadding(int,int,int,int) -> do
    android.graphics.drawable.Drawable getCardBackground() -> for
    boolean getUseCompatPadding() -> if
    boolean getPreventCornerOverlap() -> int
androidx.cardview.widget.CardViewApi17Impl -> androidx.cardview.widget.do:
    void initStatic() -> do
androidx.cardview.widget.CardViewApi17Impl$1 -> androidx.cardview.widget.do$do:
    void drawRoundRect(android.graphics.Canvas,android.graphics.RectF,float,android.graphics.Paint) -> do
androidx.cardview.widget.CardViewApi21Impl -> androidx.cardview.widget.if:
    void onCompatPaddingChanged(androidx.cardview.widget.CardViewDelegate) -> byte
    android.content.res.ColorStateList getBackgroundColor(androidx.cardview.widget.CardViewDelegate) -> case
    void updatePadding(androidx.cardview.widget.CardViewDelegate) -> char
    float getMaxElevation(androidx.cardview.widget.CardViewDelegate) -> do
    void initStatic() -> do
    void initialize(androidx.cardview.widget.CardViewDelegate,android.content.Context,android.content.res.ColorStateList,float,float,float) -> do
    void setBackgroundColor(androidx.cardview.widget.CardViewDelegate,android.content.res.ColorStateList) -> do
    void setElevation(androidx.cardview.widget.CardViewDelegate,float) -> do
    androidx.cardview.widget.RoundRectDrawable getCardBackground(androidx.cardview.widget.CardViewDelegate) -> else
    void onPreventCornerOverlapChanged(androidx.cardview.widget.CardViewDelegate) -> for
    void setRadius(androidx.cardview.widget.CardViewDelegate,float) -> for
    float getRadius(androidx.cardview.widget.CardViewDelegate) -> if
    void setMaxElevation(androidx.cardview.widget.CardViewDelegate,float) -> if
    float getMinHeight(androidx.cardview.widget.CardViewDelegate) -> int
    float getElevation(androidx.cardview.widget.CardViewDelegate) -> new
    float getMinWidth(androidx.cardview.widget.CardViewDelegate) -> try
androidx.cardview.widget.CardViewBaseImpl -> androidx.cardview.widget.for:
    android.graphics.RectF mCornerRect -> do
    void onCompatPaddingChanged(androidx.cardview.widget.CardViewDelegate) -> byte
    android.content.res.ColorStateList getBackgroundColor(androidx.cardview.widget.CardViewDelegate) -> case
    void updatePadding(androidx.cardview.widget.CardViewDelegate) -> char
    androidx.cardview.widget.RoundRectDrawableWithShadow createBackground(android.content.Context,android.content.res.ColorStateList,float,float,float) -> do
    float getMaxElevation(androidx.cardview.widget.CardViewDelegate) -> do
    void initStatic() -> do
    void initialize(androidx.cardview.widget.CardViewDelegate,android.content.Context,android.content.res.ColorStateList,float,float,float) -> do
    void setBackgroundColor(androidx.cardview.widget.CardViewDelegate,android.content.res.ColorStateList) -> do
    void setElevation(androidx.cardview.widget.CardViewDelegate,float) -> do
    androidx.cardview.widget.RoundRectDrawableWithShadow getShadowBackground(androidx.cardview.widget.CardViewDelegate) -> else
    void onPreventCornerOverlapChanged(androidx.cardview.widget.CardViewDelegate) -> for
    void setRadius(androidx.cardview.widget.CardViewDelegate,float) -> for
    float getRadius(androidx.cardview.widget.CardViewDelegate) -> if
    void setMaxElevation(androidx.cardview.widget.CardViewDelegate,float) -> if
    float getMinHeight(androidx.cardview.widget.CardViewDelegate) -> int
    float getElevation(androidx.cardview.widget.CardViewDelegate) -> new
    float getMinWidth(androidx.cardview.widget.CardViewDelegate) -> try
androidx.cardview.widget.CardViewBaseImpl$1 -> androidx.cardview.widget.for$do:
    androidx.cardview.widget.CardViewBaseImpl this$0 -> do
    void drawRoundRect(android.graphics.Canvas,android.graphics.RectF,float,android.graphics.Paint) -> do
androidx.cardview.widget.CardViewDelegate -> androidx.cardview.widget.int:
    android.view.View getCardView() -> do
    void setCardBackground(android.graphics.drawable.Drawable) -> do
    void setMinWidthHeightInternal(int,int) -> do
    void setShadowPadding(int,int,int,int) -> do
    android.graphics.drawable.Drawable getCardBackground() -> for
    boolean getUseCompatPadding() -> if
    boolean getPreventCornerOverlap() -> int
androidx.cardview.widget.CardViewImpl -> androidx.cardview.widget.new:
    void onCompatPaddingChanged(androidx.cardview.widget.CardViewDelegate) -> byte
    android.content.res.ColorStateList getBackgroundColor(androidx.cardview.widget.CardViewDelegate) -> case
    float getMaxElevation(androidx.cardview.widget.CardViewDelegate) -> do
    void initStatic() -> do
    void initialize(androidx.cardview.widget.CardViewDelegate,android.content.Context,android.content.res.ColorStateList,float,float,float) -> do
    void setBackgroundColor(androidx.cardview.widget.CardViewDelegate,android.content.res.ColorStateList) -> do
    void setElevation(androidx.cardview.widget.CardViewDelegate,float) -> do
    void onPreventCornerOverlapChanged(androidx.cardview.widget.CardViewDelegate) -> for
    void setRadius(androidx.cardview.widget.CardViewDelegate,float) -> for
    float getRadius(androidx.cardview.widget.CardViewDelegate) -> if
    void setMaxElevation(androidx.cardview.widget.CardViewDelegate,float) -> if
    float getMinHeight(androidx.cardview.widget.CardViewDelegate) -> int
    float getElevation(androidx.cardview.widget.CardViewDelegate) -> new
    float getMinWidth(androidx.cardview.widget.CardViewDelegate) -> try
androidx.cardview.widget.RoundRectDrawable -> androidx.cardview.widget.try:
    float mRadius -> do
    android.content.res.ColorStateList mBackground -> case
    android.graphics.Rect mBoundsI -> int
    android.content.res.ColorStateList mTint -> else
    android.graphics.PorterDuffColorFilter mTintFilter -> char
    boolean mInsetForRadius -> byte
    android.graphics.RectF mBoundsF -> for
    android.graphics.PorterDuff$Mode mTintMode -> goto
    boolean mInsetForPadding -> try
    android.graphics.Paint mPaint -> if
    float mPadding -> new
    android.graphics.PorterDuffColorFilter createTintFilter(android.content.res.ColorStateList,android.graphics.PorterDuff$Mode) -> do
    android.content.res.ColorStateList getColor() -> do
    void setColor(android.content.res.ColorStateList) -> do
    void setPadding(float,boolean,boolean) -> do
    void setRadius(float) -> do
    void updateBounds(android.graphics.Rect) -> do
    float getRadius() -> for
    float getPadding() -> if
    void setBackground(android.content.res.ColorStateList) -> if
androidx.cardview.widget.RoundRectDrawableWithShadow -> androidx.cardview.widget.byte:
    android.graphics.Paint mCornerShadowPaint -> for
    androidx.cardview.widget.RoundRectDrawableWithShadow$RoundRectHelper sRoundRectHelper -> const
    int mShadowStartColor -> this
    boolean mAddPaddingForCorners -> break
    int mInsetShadow -> do
    float mCornerRadius -> try
    android.graphics.Path mCornerShadowPath -> byte
    android.graphics.RectF mCardBounds -> new
    boolean mDirty -> long
    int mShadowEndColor -> void
    float mRawShadowSize -> else
    float mShadowSize -> char
    boolean mPrintedShadowClipWarning -> catch
    android.content.res.ColorStateList mBackground -> goto
    android.graphics.Paint mEdgeShadowPaint -> int
    float mRawMaxShadowSize -> case
    double COS_45 -> class
    android.graphics.Paint mPaint -> if
    void buildShadowCorners() -> byte
    float calculateHorizontalPadding(float,float,boolean) -> do
    void drawShadow(android.graphics.Canvas) -> do
    android.content.res.ColorStateList getColor() -> do
    void getMaxShadowAndCornerPadding(android.graphics.Rect) -> do
    void setAddPaddingForCorners(boolean) -> do
    void setColor(android.content.res.ColorStateList) -> do
    void setCornerRadius(float) -> do
    void setShadowSize(float,float) -> do
    float getMaxShadowSize() -> for
    void setShadowSize(float) -> for
    void buildComponents(android.graphics.Rect) -> if
    float calculateVerticalPadding(float,float,boolean) -> if
    float getCornerRadius() -> if
    void setBackground(android.content.res.ColorStateList) -> if
    void setMaxShadowSize(float) -> if
    float getMinHeight() -> int
    int toEven(float) -> int
    float getMinWidth() -> new
    float getShadowSize() -> try
androidx.cardview.widget.RoundRectDrawableWithShadow$RoundRectHelper -> androidx.cardview.widget.byte$do:
    void drawRoundRect(android.graphics.Canvas,android.graphics.RectF,float,android.graphics.Paint) -> do
androidx.collection.ArrayMap -> if.int.do:
    androidx.collection.MapCollections mCollections -> char
    boolean retainAll(java.util.Collection) -> do
    androidx.collection.MapCollections getCollection() -> if
androidx.collection.ArrayMap$1 -> if.int.do$do:
    androidx.collection.ArrayMap this$0 -> int
    void colClear() -> do
    java.lang.Object colGetEntry(int,int) -> do
    int colIndexOfKey(java.lang.Object) -> do
    void colPut(java.lang.Object,java.lang.Object) -> do
    void colRemoveAt(int) -> do
    java.lang.Object colSetValue(int,java.lang.Object) -> do
    int colGetSize() -> for
    java.util.Map colGetMap() -> if
    int colIndexOfValue(java.lang.Object) -> if
androidx.collection.ArraySet -> if.int.if:
    java.lang.Object[] OBJECT -> byte
    int mSize -> int
    androidx.collection.MapCollections mCollections -> new
    int[] INT -> try
    java.lang.Object[] sBaseCache -> case
    int[] mHashes -> if
    int sBaseCacheSize -> char
    int sTwiceBaseCacheSize -> goto
    java.lang.Object[] mArray -> for
    java.lang.Object[] sTwiceBaseCache -> else
    void ensureCapacity(int) -> do
    void freeArrays(int[],java.lang.Object[],int) -> do
    androidx.collection.MapCollections getCollection() -> do
    int indexOf(java.lang.Object) -> do
    int indexOf(java.lang.Object,int) -> do
    java.lang.Object valueAt(int) -> for
    int indexOfNull() -> if
    java.lang.Object removeAt(int) -> if
    void allocArrays(int) -> int
androidx.collection.ArraySet$1 -> if.int.if$do:
    androidx.collection.ArraySet this$0 -> int
    void colClear() -> do
    java.lang.Object colGetEntry(int,int) -> do
    int colIndexOfKey(java.lang.Object) -> do
    void colPut(java.lang.Object,java.lang.Object) -> do
    void colRemoveAt(int) -> do
    java.lang.Object colSetValue(int,java.lang.Object) -> do
    int colGetSize() -> for
    java.util.Map colGetMap() -> if
    int colIndexOfValue(java.lang.Object) -> if
androidx.collection.ContainerHelpers -> if.int.for:
    int[] EMPTY_INTS -> do
    long[] EMPTY_LONGS -> if
    java.lang.Object[] EMPTY_OBJECTS -> for
    int binarySearch(int[],int,int) -> do
    int binarySearch(long[],int,long) -> do
    boolean equal(java.lang.Object,java.lang.Object) -> do
    int idealByteArraySize(int) -> do
    int idealLongArraySize(int) -> for
    int idealIntArraySize(int) -> if
androidx.collection.LongSparseArray -> if.int.int:
    java.lang.Object[] mValues -> int
    boolean mGarbage -> if
    java.lang.Object DELETED -> try
    int mSize -> new
    long[] mKeys -> for
    void append(long,java.lang.Object) -> do
    void clear() -> do
    void delete(long) -> do
    long keyAt(int) -> do
    void gc() -> for
    int indexOfKey(long) -> for
    void put(long,java.lang.Object) -> for
    java.lang.Object valueAt(int) -> for
    java.lang.Object get(long) -> if
    java.lang.Object get(long,java.lang.Object) -> if
    void removeAt(int) -> if
    int size() -> if
    void remove(long) -> int
androidx.collection.LruCache -> if.int.new:
    int size -> if
    int putCount -> int
    int maxSize -> for
    int hitCount -> byte
    int createCount -> new
    java.util.LinkedHashMap map -> do
    int evictionCount -> try
    int missCount -> case
    java.lang.Object create(java.lang.Object) -> do
    void entryRemoved(boolean,java.lang.Object,java.lang.Object,java.lang.Object) -> do
    java.lang.Object put(java.lang.Object,java.lang.Object) -> do
    void trimToSize(int) -> do
    int safeSizeOf(java.lang.Object,java.lang.Object) -> for
    java.lang.Object get(java.lang.Object) -> if
    int sizeOf(java.lang.Object,java.lang.Object) -> if
androidx.collection.MapCollections -> if.int.try:
    androidx.collection.MapCollections$ValuesCollection mValues -> for
    androidx.collection.MapCollections$EntrySet mEntrySet -> do
    androidx.collection.MapCollections$KeySet mKeySet -> if
    void colClear() -> do
    java.lang.Object colGetEntry(int,int) -> do
    int colIndexOfKey(java.lang.Object) -> do
    void colPut(java.lang.Object,java.lang.Object) -> do
    void colRemoveAt(int) -> do
    java.lang.Object colSetValue(int,java.lang.Object) -> do
    boolean containsAllHelper(java.util.Map,java.util.Collection) -> do
    boolean equalsSetHelper(java.util.Set,java.lang.Object) -> do
    java.lang.Object[] toArrayHelper(java.lang.Object[],int) -> do
    int colGetSize() -> for
    boolean retainAllHelper(java.util.Map,java.util.Collection) -> for
    java.util.Map colGetMap() -> if
    int colIndexOfValue(java.lang.Object) -> if
    boolean removeAllHelper(java.util.Map,java.util.Collection) -> if
    java.lang.Object[] toArrayHelper(int) -> if
    java.util.Set getEntrySet() -> int
    java.util.Set getKeySet() -> new
    java.util.Collection getValues() -> try
androidx.collection.MapCollections$ArrayIterator -> if.int.try$do:
    int mOffset -> if
    int mIndex -> int
    boolean mCanRemove -> new
    int mSize -> for
    androidx.collection.MapCollections this$0 -> try
androidx.collection.MapCollections$EntrySet -> if.int.try$if:
    androidx.collection.MapCollections this$0 -> if
    boolean add(java.util.Map$Entry) -> do
androidx.collection.MapCollections$KeySet -> if.int.try$for:
    androidx.collection.MapCollections this$0 -> if
androidx.collection.MapCollections$MapIterator -> if.int.try$int:
    int mEnd -> if
    boolean mEntryValid -> int
    androidx.collection.MapCollections this$0 -> new
    int mIndex -> for
androidx.collection.MapCollections$ValuesCollection -> if.int.try$new:
    androidx.collection.MapCollections this$0 -> if
androidx.collection.SimpleArrayMap -> if.int.byte:
    java.lang.Object[] mBaseCache -> new
    java.lang.Object[] mTwiceBaseCache -> byte
    int mSize -> int
    int[] mHashes -> if
    int mBaseCacheSize -> try
    int mTwiceBaseCacheSize -> case
    java.lang.Object[] mArray -> for
    int binarySearchHashes(int[],int,int) -> do
    void ensureCapacity(int) -> do
    void freeArrays(int[],java.lang.Object[],int) -> do
    int indexOf(java.lang.Object,int) -> do
    int indexOfKey(java.lang.Object) -> do
    int indexOfNull() -> do
    void putAll(androidx.collection.SimpleArrayMap) -> do
    java.lang.Object setValueAt(int,java.lang.Object) -> do
    java.lang.Object removeAt(int) -> for
    int indexOfValue(java.lang.Object) -> if
    java.lang.Object keyAt(int) -> if
    java.lang.Object valueAt(int) -> int
    void allocArrays(int) -> new
androidx.collection.SparseArrayCompat -> if.int.case:
    int[] mKeys -> for
    java.lang.Object[] mValues -> int
    boolean mGarbage -> if
    java.lang.Object DELETED -> try
    int mSize -> new
    void append(int,java.lang.Object) -> do
    void clear() -> do
    java.lang.Object get(int) -> do
    int indexOfValue(java.lang.Object) -> do
    void gc() -> for
    int keyAt(int) -> for
    void put(int,java.lang.Object) -> for
    java.lang.Object get(int,java.lang.Object) -> if
    int indexOfKey(int) -> if
    int size() -> if
    void remove(int) -> int
    java.lang.Object valueAt(int) -> new
androidx.coordinatorlayout.R$attr -> if.new.do:
androidx.coordinatorlayout.R$style -> if.new.if:
androidx.coordinatorlayout.R$styleable -> if.new.for:
androidx.coordinatorlayout.widget.CoordinatorLayout -> androidx.coordinatorlayout.widget.CoordinatorLayout:
    android.graphics.drawable.Drawable mStatusBarBackground -> const
    androidx.coordinatorlayout.widget.DirectedAcyclicGraph mChildDag -> for
    boolean mNeedsPreDrawListener -> break
    androidx.core.view.OnApplyWindowInsetsListener mApplyWindowInsetsListener -> float
    java.util.Comparator TOP_SORTED_CHILDREN_COMPARATOR -> double
    java.util.List mDependencySortedChildren -> if
    int[] mBehaviorConsumed -> byte
    java.util.List mTempList1 -> int
    boolean mIsAttachedToWindow -> else
    java.lang.Class[] CONSTRUCTOR_PARAMS -> throw
    int[] mKeylines -> goto
    java.lang.ThreadLocal sConstructors -> while
    android.view.View mNestedScrollingTarget -> this
    androidx.core.view.NestedScrollingParentHelper mNestedScrollingParentHelper -> short
    boolean mDrawStatusBarBackground -> class
    java.util.List mTempDependenciesList -> new
    android.graphics.Paint mScrimPaint -> try
    java.lang.String WIDGET_PACKAGE_NAME -> super
    androidx.core.util.Pools$Pool sRectPool -> import
    boolean mDisallowInterceptReset -> char
    android.view.View mBehaviorTouchView -> long
    androidx.coordinatorlayout.widget.CoordinatorLayout$OnPreDrawListener mOnPreDrawListener -> void
    android.view.ViewGroup$OnHierarchyChangeListener mOnHierarchyChangeListener -> final
    androidx.core.view.WindowInsetsCompat mLastInsets -> catch
    int[] mNestedScrollingV2ConsumedCompat -> case
    void addPreDrawListener() -> do
    int clamp(int,int,int) -> do
    void constrainChildRect(androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams,android.graphics.Rect,int,int) -> do
    void dispatchDependentViewsChanged(android.view.View) -> do
    void getChildRect(android.view.View,boolean,android.graphics.Rect) -> do
    void getDescendantRect(android.view.View,android.graphics.Rect) -> do
    void getDesiredAnchoredChildRect(android.view.View,int,android.graphics.Rect,android.graphics.Rect) -> do
    void getDesiredAnchoredChildRectWithoutConstraints(android.view.View,int,android.graphics.Rect,android.graphics.Rect,androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams,int,int) -> do
    void getTopSortedChildren(java.util.List) -> do
    boolean isPointInChildBounds(android.view.View,int,int) -> do
    void layoutChildWithAnchor(android.view.View,android.view.View,int) -> do
    void offsetChildByInset(android.view.View,android.graphics.Rect,int) -> do
    void onChildViewsChanged(int) -> do
    void onMeasureChild(android.view.View,int,int,int,int) -> do
    void onNestedPreScroll(android.view.View,int,int,int[],int) -> do
    void onNestedScroll(android.view.View,int,int,int,int,int) -> do
    void onNestedScroll(android.view.View,int,int,int,int,int,int[]) -> do
    void onNestedScrollAccepted(android.view.View,android.view.View,int,int) -> do
    void onStopNestedScroll(android.view.View,int) -> do
    androidx.coordinatorlayout.widget.CoordinatorLayout$Behavior parseBehavior(android.content.Context,android.util.AttributeSet,java.lang.String) -> do
    boolean performIntercept(android.view.MotionEvent,int) -> do
    void releaseTempRect(android.graphics.Rect) -> do
    void resetTouchBehaviors(boolean) -> do
    androidx.core.view.WindowInsetsCompat setWindowInsets(androidx.core.view.WindowInsetsCompat) -> do
    java.util.List getDependents(android.view.View) -> for
    void onLayoutChild(android.view.View,int) -> for
    void recordLastChildRect(android.view.View,android.graphics.Rect) -> for
    void removePreDrawListener() -> for
    int resolveAnchoredChildGravity(int) -> for
    androidx.core.view.WindowInsetsCompat dispatchApplyWindowInsetsToBehaviors(androidx.core.view.WindowInsetsCompat) -> if
    void ensurePreDrawListener() -> if
    java.util.List getDependencies(android.view.View) -> if
    int getKeyline(int) -> if
    void getLastChildRect(android.view.View,android.graphics.Rect) -> if
    void layoutChildWithKeyline(android.view.View,int,int) -> if
    void offsetChildToAnchor(android.view.View,int) -> if
    boolean onStartNestedScroll(android.view.View,android.view.View,int,int) -> if
    android.graphics.Rect acquireTempRect() -> int
    androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams getResolvedLayoutParams(android.view.View) -> int
    void layoutChild(android.view.View,int) -> int
    int resolveGravity(int) -> int
    boolean hasDependencies(android.view.View) -> new
    void prepareChildren() -> new
    int resolveKeylineGravity(int) -> new
    void setInsetOffsetX(android.view.View,int) -> new
    void setInsetOffsetY(android.view.View,int) -> try
    void setupForInsets() -> try
androidx.coordinatorlayout.widget.CoordinatorLayout$1 -> androidx.coordinatorlayout.widget.CoordinatorLayout$do:
    androidx.coordinatorlayout.widget.CoordinatorLayout this$0 -> do
    androidx.core.view.WindowInsetsCompat onApplyWindowInsets(android.view.View,androidx.core.view.WindowInsetsCompat) -> do
androidx.coordinatorlayout.widget.CoordinatorLayout$AttachedBehavior -> androidx.coordinatorlayout.widget.CoordinatorLayout$if:
androidx.coordinatorlayout.widget.CoordinatorLayout$Behavior -> androidx.coordinatorlayout.widget.CoordinatorLayout$for:
    boolean blocksInteractionBelow(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> do
    boolean getInsetDodgeRect(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.graphics.Rect) -> do
    boolean layoutDependsOn(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> do
    androidx.core.view.WindowInsetsCompat onApplyWindowInsets(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,androidx.core.view.WindowInsetsCompat) -> do
    void onAttachedToLayoutParams(androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams) -> do
    void onDetachedFromLayoutParams() -> do
    boolean onInterceptTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean onMeasureChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int,int,int,int) -> do
    boolean onNestedFling(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,float,float,boolean) -> do
    boolean onNestedPreFling(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,float,float) -> do
    void onNestedPreScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int[]) -> do
    void onNestedPreScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int[],int) -> do
    void onNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int,int) -> do
    void onNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int,int,int) -> do
    void onNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int,int,int,int[]) -> do
    void onNestedScrollAccepted(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,android.view.View,int) -> do
    void onNestedScrollAccepted(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,android.view.View,int,int) -> do
    boolean onRequestChildRectangleOnScreen(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.graphics.Rect,boolean) -> do
    void onRestoreInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.os.Parcelable) -> do
    void onStopNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int) -> do
    float getScrimOpacity(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> for
    void onDependentViewRemoved(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> for
    int getScrimColor(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> if
    boolean onDependentViewChanged(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> if
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,android.view.View,int) -> if
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,android.view.View,int,int) -> if
    boolean onTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> if
    android.os.Parcelable onSaveInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> int
    void onStopNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> int
androidx.coordinatorlayout.widget.CoordinatorLayout$DefaultBehavior -> androidx.coordinatorlayout.widget.CoordinatorLayout$int:
androidx.coordinatorlayout.widget.CoordinatorLayout$HierarchyChangeListener -> androidx.coordinatorlayout.widget.CoordinatorLayout$new:
    androidx.coordinatorlayout.widget.CoordinatorLayout this$0 -> if
androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams -> androidx.coordinatorlayout.widget.CoordinatorLayout$try:
    boolean mDidBlockInteraction -> this
    boolean mDidAcceptNestedScrollNonTouch -> break
    android.graphics.Rect mLastChildRect -> class
    int mAnchorId -> try
    androidx.coordinatorlayout.widget.CoordinatorLayout$Behavior mBehavior -> do
    android.view.View mAnchorDirectChild -> long
    int anchorGravity -> int
    int mInsetOffsetY -> else
    boolean mDidChangeAfterNestedScroll -> catch
    boolean mBehaviorResolved -> if
    int gravity -> for
    int insetEdge -> byte
    android.view.View mAnchorView -> goto
    int keyline -> new
    boolean mDidAcceptNestedScrollTouch -> void
    int mInsetOffsetX -> char
    int dodgeInsetEdges -> case
    void resetChangedAfterNestedScroll() -> byte
    void resetTouchBehaviorTracking() -> case
    boolean checkAnchorChanged() -> do
    boolean dependsOn(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> do
    android.view.View findAnchorView(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> do
    boolean isNestedScrollAccepted(int) -> do
    void resolveAnchorView(android.view.View,androidx.coordinatorlayout.widget.CoordinatorLayout) -> do
    void setBehavior(androidx.coordinatorlayout.widget.CoordinatorLayout$Behavior) -> do
    void setChangedAfterNestedScroll(boolean) -> do
    void setLastChildRect(android.graphics.Rect) -> do
    void setNestedScrollAccepted(int,boolean) -> do
    boolean shouldDodge(android.view.View,int) -> do
    int getAnchorId() -> for
    boolean didBlockInteraction() -> if
    boolean isBlockingInteractionBelow(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> if
    void resetNestedScroll(int) -> if
    boolean verifyAnchorView(android.view.View,androidx.coordinatorlayout.widget.CoordinatorLayout) -> if
    androidx.coordinatorlayout.widget.CoordinatorLayout$Behavior getBehavior() -> int
    boolean getChangedAfterNestedScroll() -> new
    android.graphics.Rect getLastChildRect() -> try
androidx.coordinatorlayout.widget.CoordinatorLayout$OnPreDrawListener -> androidx.coordinatorlayout.widget.CoordinatorLayout$byte:
    androidx.coordinatorlayout.widget.CoordinatorLayout this$0 -> if
androidx.coordinatorlayout.widget.CoordinatorLayout$SavedState -> androidx.coordinatorlayout.widget.CoordinatorLayout$case:
    android.util.SparseArray behaviorStates -> int
androidx.coordinatorlayout.widget.CoordinatorLayout$SavedState$1 -> androidx.coordinatorlayout.widget.CoordinatorLayout$case$do:
androidx.coordinatorlayout.widget.CoordinatorLayout$ViewElevationComparator -> androidx.coordinatorlayout.widget.CoordinatorLayout$char:
    int compare(android.view.View,android.view.View) -> do
androidx.coordinatorlayout.widget.DirectedAcyclicGraph -> androidx.coordinatorlayout.widget.do:
    java.util.HashSet mSortTmpMarked -> int
    androidx.core.util.Pools$Pool mListPool -> do
    androidx.collection.SimpleArrayMap mGraph -> if
    java.util.ArrayList mSortResult -> for
    void addEdge(java.lang.Object,java.lang.Object) -> do
    void addNode(java.lang.Object) -> do
    void clear() -> do
    void dfs(java.lang.Object,java.util.ArrayList,java.util.HashSet) -> do
    void poolList(java.util.ArrayList) -> do
    java.util.ArrayList getEmptyList() -> for
    java.util.List getIncomingEdges(java.lang.Object) -> for
    boolean contains(java.lang.Object) -> if
    java.util.ArrayList getSortedList() -> if
    java.util.List getOutgoingEdges(java.lang.Object) -> int
    boolean hasOutgoingEdges(java.lang.Object) -> new
androidx.coordinatorlayout.widget.ViewGroupUtils -> androidx.coordinatorlayout.widget.if:
    java.lang.ThreadLocal sRectF -> if
    java.lang.ThreadLocal sMatrix -> do
    void getDescendantRect(android.view.ViewGroup,android.view.View,android.graphics.Rect) -> do
    void offsetDescendantMatrix(android.view.ViewParent,android.view.View,android.graphics.Matrix) -> do
    void offsetDescendantRect(android.view.ViewGroup,android.view.View,android.graphics.Rect) -> if
androidx.core.R$attr -> if.try.do:
androidx.core.R$id -> if.try.if:
androidx.core.R$styleable -> if.try.for:
androidx.core.app.ActivityCompat -> androidx.core.app.do:
    androidx.core.app.ActivityCompat$PermissionCompatDelegate sDelegate -> for
    void finishAffinity(android.app.Activity) -> do
    androidx.core.app.ActivityCompat$PermissionCompatDelegate getPermissionCompatDelegate() -> do
    void startActivityForResult(android.app.Activity,android.content.Intent,int,android.os.Bundle) -> do
    void recreate(android.app.Activity) -> if
androidx.core.app.ActivityCompat$PermissionCompatDelegate -> androidx.core.app.do$do:
    boolean onActivityResult(android.app.Activity,int,int,android.content.Intent) -> do
androidx.core.app.ActivityRecreator -> androidx.core.app.if:
    android.os.Handler mainHandler -> byte
    java.lang.reflect.Field mainThreadField -> if
    java.lang.reflect.Field tokenField -> for
    java.lang.reflect.Method performStopActivity2ParamsMethod -> new
    java.lang.Class activityThreadClass -> do
    java.lang.reflect.Method requestRelaunchActivityMethod -> try
    java.lang.reflect.Method performStopActivity3ParamsMethod -> int
    java.lang.Class getActivityThreadClass() -> do
    java.lang.reflect.Method getPerformStopActivity2Params(java.lang.Class) -> do
    boolean queueOnStopIfNecessary(java.lang.Object,android.app.Activity) -> do
    boolean recreate(android.app.Activity) -> do
    java.lang.reflect.Method getRequestRelaunchActivityMethod(java.lang.Class) -> for
    java.lang.reflect.Field getTokenField() -> for
    java.lang.reflect.Field getMainThreadField() -> if
    java.lang.reflect.Method getPerformStopActivity3Params(java.lang.Class) -> if
    boolean needsRelaunchCall() -> int
androidx.core.app.ActivityRecreator$1 -> androidx.core.app.if$do:
    androidx.core.app.ActivityRecreator$LifecycleCheckCallbacks val$callbacks -> if
    java.lang.Object val$token -> for
androidx.core.app.ActivityRecreator$2 -> androidx.core.app.if$if:
    android.app.Application val$application -> if
    androidx.core.app.ActivityRecreator$LifecycleCheckCallbacks val$callbacks -> for
androidx.core.app.ActivityRecreator$3 -> androidx.core.app.if$for:
    java.lang.Object val$token -> for
    java.lang.Object val$activityThread -> if
androidx.core.app.ActivityRecreator$LifecycleCheckCallbacks -> androidx.core.app.if$int:
    java.lang.Object currentlyRecreatingToken -> do
    boolean mStarted -> for
    boolean mDestroyed -> int
    android.app.Activity mActivity -> if
    boolean mStopQueued -> new
androidx.core.app.AppOpsManagerCompat -> androidx.core.app.for:
    int noteProxyOpNoThrow(android.content.Context,java.lang.String,java.lang.String) -> do
    java.lang.String permissionToOp(java.lang.String) -> do
androidx.core.app.BundleCompat -> androidx.core.app.int:
    android.os.IBinder getBinder(android.os.Bundle,java.lang.String) -> do
androidx.core.app.BundleCompat$BundleCompatBaseImpl -> androidx.core.app.int$do:
    boolean sGetIBinderMethodFetched -> if
    java.lang.reflect.Method sGetIBinderMethod -> do
    android.os.IBinder getBinder(android.os.Bundle,java.lang.String) -> do
androidx.core.app.ComponentActivity -> androidx.core.app.new:
    androidx.lifecycle.LifecycleRegistry mLifecycleRegistry -> if
    boolean superDispatchKeyEvent(android.view.KeyEvent) -> do
androidx.core.app.CoreComponentFactory -> androidx.core.app.CoreComponentFactory:
    java.lang.Object checkCompatWrapper(java.lang.Object) -> do
androidx.core.app.CoreComponentFactory$CompatWrapped -> androidx.core.app.CoreComponentFactory$do:
    java.lang.Object getWrapper() -> do
androidx.core.app.NavUtils -> androidx.core.app.try:
    android.content.Intent getParentActivityIntent(android.app.Activity) -> do
    android.content.Intent getParentActivityIntent(android.content.Context,android.content.ComponentName) -> do
    void navigateUpTo(android.app.Activity,android.content.Intent) -> do
    java.lang.String getParentActivityName(android.app.Activity) -> if
    java.lang.String getParentActivityName(android.content.Context,android.content.ComponentName) -> if
    boolean shouldUpRecreateTask(android.app.Activity,android.content.Intent) -> if
androidx.core.app.RemoteActionCompat -> androidx.core.app.RemoteActionCompat:
    android.app.PendingIntent mActionIntent -> int
    boolean mEnabled -> new
    boolean mShouldShowIcon -> try
    java.lang.CharSequence mContentDescription -> for
    androidx.core.graphics.drawable.IconCompat mIcon -> do
    java.lang.CharSequence mTitle -> if
androidx.core.app.SharedElementCallback -> androidx.core.app.byte:
    void onMapSharedElements(java.util.List,java.util.Map) -> do
    void onSharedElementEnd(java.util.List,java.util.List,java.util.List) -> do
    void onSharedElementStart(java.util.List,java.util.List,java.util.List) -> if
androidx.core.app.TaskStackBuilder -> androidx.core.app.case:
    java.util.ArrayList mIntents -> if
    android.content.Context mSourceContext -> for
    androidx.core.app.TaskStackBuilder addNextIntent(android.content.Intent) -> do
    androidx.core.app.TaskStackBuilder addParentStack(android.app.Activity) -> do
    androidx.core.app.TaskStackBuilder addParentStack(android.content.ComponentName) -> do
    androidx.core.app.TaskStackBuilder create(android.content.Context) -> do
    void startActivities() -> do
    void startActivities(android.os.Bundle) -> do
androidx.core.app.TaskStackBuilder$SupportParentable -> androidx.core.app.case$do:
    android.content.Intent getSupportParentActivityIntent() -> try
androidx.core.content.ContextCompat -> androidx.core.content.do:
    java.lang.Object sLock -> do
    android.util.TypedValue sTempValue -> if
    int getColor(android.content.Context,int) -> do
    java.io.File[] getExternalCacheDirs(android.content.Context) -> do
    java.io.File[] getExternalFilesDirs(android.content.Context,java.lang.String) -> do
    boolean startActivities(android.content.Context,android.content.Intent[],android.os.Bundle) -> do
    android.graphics.drawable.Drawable getDrawable(android.content.Context,int) -> for
    android.content.res.ColorStateList getColorStateList(android.content.Context,int) -> if
androidx.core.content.FileProvider -> androidx.core.content.FileProvider:
    java.lang.String[] COLUMNS -> for
    java.util.HashMap sCache -> new
    java.io.File DEVICE_ROOT -> int
    androidx.core.content.FileProvider$PathStrategy mStrategy -> if
    java.io.File buildPath(java.io.File,java.lang.String[]) -> do
    java.lang.Object[] copyOf(java.lang.Object[],int) -> do
    java.lang.String[] copyOf(java.lang.String[],int) -> do
    androidx.core.content.FileProvider$PathStrategy getPathStrategy(android.content.Context,java.lang.String) -> do
    int modeToMode(java.lang.String) -> do
    androidx.core.content.FileProvider$PathStrategy parsePathStrategy(android.content.Context,java.lang.String) -> if
androidx.core.content.FileProvider$PathStrategy -> androidx.core.content.FileProvider$do:
    java.io.File getFileForUri(android.net.Uri) -> do
androidx.core.content.FileProvider$SimplePathStrategy -> androidx.core.content.FileProvider$if:
    java.util.HashMap mRoots -> do
    void addRoot(java.lang.String,java.io.File) -> do
    java.io.File getFileForUri(android.net.Uri) -> do
androidx.core.content.PermissionChecker -> androidx.core.content.if:
    int checkPermission(android.content.Context,java.lang.String,int,int,java.lang.String) -> do
    int checkSelfPermission(android.content.Context,java.lang.String) -> do
androidx.core.content.res.ColorStateListInflaterCompat -> androidx.core.content.for.do:
    android.content.res.ColorStateList createFromXml(android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.content.res.Resources$Theme) -> do
    android.content.res.ColorStateList createFromXmlInner(android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
    android.content.res.ColorStateList inflate(android.content.res.Resources,int,android.content.res.Resources$Theme) -> do
    int modulateColorAlpha(int,float) -> do
    android.content.res.TypedArray obtainAttributes(android.content.res.Resources,android.content.res.Resources$Theme,android.util.AttributeSet,int[]) -> do
    android.content.res.ColorStateList inflate(android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> if
androidx.core.content.res.ComplexColorCompat -> androidx.core.content.for.if:
    int mColor -> for
    android.graphics.Shader mShader -> do
    android.content.res.ColorStateList mColorStateList -> if
    androidx.core.content.res.ComplexColorCompat createFromXml(android.content.res.Resources,int,android.content.res.Resources$Theme) -> do
    androidx.core.content.res.ComplexColorCompat from(android.content.res.ColorStateList) -> do
    androidx.core.content.res.ComplexColorCompat from(android.graphics.Shader) -> do
    int getColor() -> do
    boolean onStateChanged(int[]) -> do
    void setColor(int) -> do
    boolean isGradient() -> for
    androidx.core.content.res.ComplexColorCompat from(int) -> if
    android.graphics.Shader getShader() -> if
    androidx.core.content.res.ComplexColorCompat inflate(android.content.res.Resources,int,android.content.res.Resources$Theme) -> if
    boolean isStateful() -> int
    boolean willDraw() -> new
androidx.core.content.res.FontResourcesParserCompat -> androidx.core.content.for.for:
    int getType(android.content.res.TypedArray,int) -> do
    androidx.core.content.res.FontResourcesParserCompat$FamilyResourceEntry parse(org.xmlpull.v1.XmlPullParser,android.content.res.Resources) -> do
    java.util.List readCerts(android.content.res.Resources,int) -> do
    void skip(org.xmlpull.v1.XmlPullParser) -> do
    java.util.List toByteArrayList(java.lang.String[]) -> do
    androidx.core.content.res.FontResourcesParserCompat$FamilyResourceEntry readFamily(org.xmlpull.v1.XmlPullParser,android.content.res.Resources) -> for
    androidx.core.content.res.FontResourcesParserCompat$FamilyResourceEntry readFamilies(org.xmlpull.v1.XmlPullParser,android.content.res.Resources) -> if
    androidx.core.content.res.FontResourcesParserCompat$FontFileResourceEntry readFont(org.xmlpull.v1.XmlPullParser,android.content.res.Resources) -> int
androidx.core.content.res.FontResourcesParserCompat$FamilyResourceEntry -> androidx.core.content.for.for$do:
androidx.core.content.res.FontResourcesParserCompat$FontFamilyFilesResourceEntry -> androidx.core.content.for.for$if:
    androidx.core.content.res.FontResourcesParserCompat$FontFileResourceEntry[] mEntries -> do
    androidx.core.content.res.FontResourcesParserCompat$FontFileResourceEntry[] getEntries() -> do
androidx.core.content.res.FontResourcesParserCompat$FontFileResourceEntry -> androidx.core.content.for.for$for:
    int mWeight -> if
    boolean mItalic -> for
    java.lang.String mFileName -> do
    java.lang.String mVariationSettings -> int
    int mTtcIndex -> new
    int mResourceId -> try
    java.lang.String getFileName() -> do
    int getTtcIndex() -> for
    int getResourceId() -> if
    java.lang.String getVariationSettings() -> int
    int getWeight() -> new
    boolean isItalic() -> try
androidx.core.content.res.FontResourcesParserCompat$ProviderResourceEntry -> androidx.core.content.for.for$int:
    int mTimeoutMs -> if
    int mStrategy -> for
    androidx.core.provider.FontRequest mRequest -> do
    int getFetchStrategy() -> do
    int getTimeout() -> for
    androidx.core.provider.FontRequest getRequest() -> if
androidx.core.content.res.GradientColorInflaterCompat -> androidx.core.content.for.int:
    androidx.core.content.res.GradientColorInflaterCompat$ColorStops checkColors(androidx.core.content.res.GradientColorInflaterCompat$ColorStops,int,int,boolean,int) -> do
    android.graphics.Shader createFromXmlInner(android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
    android.graphics.Shader$TileMode parseTileMode(int) -> do
    androidx.core.content.res.GradientColorInflaterCompat$ColorStops inflateChildElements(android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> if
androidx.core.content.res.GradientColorInflaterCompat$ColorStops -> androidx.core.content.for.int$do:
    float[] mOffsets -> if
    int[] mColors -> do
androidx.core.content.res.GrowingArrayUtils -> androidx.core.content.for.new:
    int[] append(int[],int,int) -> do
    java.lang.Object[] append(java.lang.Object[],int,java.lang.Object) -> do
    int growSize(int) -> do
androidx.core.content.res.ResourcesCompat -> androidx.core.content.for.try:
    android.graphics.drawable.Drawable getDrawable(android.content.res.Resources,int,android.content.res.Resources$Theme) -> do
    android.graphics.Typeface getFont(android.content.Context,int) -> do
    android.graphics.Typeface getFont(android.content.Context,int,android.util.TypedValue,int,androidx.core.content.res.ResourcesCompat$FontCallback) -> do
    void getFont(android.content.Context,int,androidx.core.content.res.ResourcesCompat$FontCallback,android.os.Handler) -> do
    android.graphics.Typeface loadFont(android.content.Context,int,android.util.TypedValue,int,androidx.core.content.res.ResourcesCompat$FontCallback,android.os.Handler,boolean) -> do
    android.graphics.Typeface loadFont(android.content.Context,android.content.res.Resources,android.util.TypedValue,int,int,androidx.core.content.res.ResourcesCompat$FontCallback,android.os.Handler,boolean) -> do
androidx.core.content.res.ResourcesCompat$FontCallback -> androidx.core.content.for.try$do:
    void callbackFailAsync(int,android.os.Handler) -> do
    void callbackSuccessAsync(android.graphics.Typeface,android.os.Handler) -> do
    void onFontRetrievalFailed(int) -> do
    void onFontRetrieved(android.graphics.Typeface) -> do
androidx.core.content.res.ResourcesCompat$FontCallback$1 -> androidx.core.content.for.try$do$do:
    androidx.core.content.res.ResourcesCompat$FontCallback this$0 -> for
    android.graphics.Typeface val$typeface -> if
androidx.core.content.res.ResourcesCompat$FontCallback$2 -> androidx.core.content.for.try$do$if:
    androidx.core.content.res.ResourcesCompat$FontCallback this$0 -> for
    int val$reason -> if
androidx.core.content.res.TypedArrayUtils -> androidx.core.content.for.byte:
    boolean getNamedBoolean(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,java.lang.String,int,boolean) -> do
    int getNamedColor(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,java.lang.String,int,int) -> do
    android.content.res.ColorStateList getNamedColorStateList(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,android.content.res.Resources$Theme,java.lang.String,int) -> do
    android.content.res.ColorStateList getNamedColorStateListFromInt(android.util.TypedValue) -> do
    androidx.core.content.res.ComplexColorCompat getNamedComplexColor(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,android.content.res.Resources$Theme,java.lang.String,int,int) -> do
    float getNamedFloat(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,java.lang.String,int,float) -> do
    java.lang.String getNamedString(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,java.lang.String,int) -> do
    boolean hasAttribute(org.xmlpull.v1.XmlPullParser,java.lang.String) -> do
    android.content.res.TypedArray obtainAttributes(android.content.res.Resources,android.content.res.Resources$Theme,android.util.AttributeSet,int[]) -> do
    int getNamedResourceId(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,java.lang.String,int,int) -> for
    int getNamedInt(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,java.lang.String,int,int) -> if
    android.util.TypedValue peekNamedValue(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,java.lang.String,int) -> if
androidx.core.graphics.ColorUtils -> if.try.int.do:
    int compositeAlpha(int,int) -> do
    int compositeComponent(int,int,int,int,int) -> do
    int setAlphaComponent(int,int) -> for
    int compositeColors(int,int) -> if
androidx.core.graphics.PathParser -> if.try.int.if:
    void addNode(java.util.ArrayList,char,float[]) -> do
    boolean canMorph(androidx.core.graphics.PathParser$PathDataNode[],androidx.core.graphics.PathParser$PathDataNode[]) -> do
    float[] copyOfRange(float[],int,int) -> do
    androidx.core.graphics.PathParser$PathDataNode[] createNodesFromPathData(java.lang.String) -> do
    androidx.core.graphics.PathParser$PathDataNode[] deepCopyNodes(androidx.core.graphics.PathParser$PathDataNode[]) -> do
    void extract(java.lang.String,int,androidx.core.graphics.PathParser$ExtractFloatResult) -> do
    int nextStart(java.lang.String,int) -> do
    float[] getFloats(java.lang.String) -> for
    android.graphics.Path createPathFromPathData(java.lang.String) -> if
    void updateNodes(androidx.core.graphics.PathParser$PathDataNode[],androidx.core.graphics.PathParser$PathDataNode[]) -> if
androidx.core.graphics.PathParser$ExtractFloatResult -> if.try.int.if$do:
    boolean mEndWithNegOrDot -> if
    int mEndPosition -> do
androidx.core.graphics.PathParser$PathDataNode -> if.try.int.if$if:
    float[] mParams -> if
    char mType -> do
    void addCommand(android.graphics.Path,float[],char,char,float[]) -> do
    void arcToBezier(android.graphics.Path,double,double,double,double,double,double,double,double,double) -> do
    void drawArc(android.graphics.Path,float,float,float,float,float,float,float,boolean,boolean) -> do
    void interpolatePathDataNode(androidx.core.graphics.PathParser$PathDataNode,androidx.core.graphics.PathParser$PathDataNode,float) -> do
    void nodesToPath(androidx.core.graphics.PathParser$PathDataNode[],android.graphics.Path) -> do
androidx.core.graphics.TypefaceCompat -> if.try.int.for:
    androidx.core.graphics.TypefaceCompatBaseImpl sTypefaceCompatImpl -> do
    androidx.collection.LruCache sTypefaceCache -> if
    android.graphics.Typeface create(android.content.Context,android.graphics.Typeface,int) -> do
    android.graphics.Typeface createFromFontInfo(android.content.Context,android.os.CancellationSignal,androidx.core.provider.FontsContractCompat$FontInfo[],int) -> do
    android.graphics.Typeface createFromResourcesFamilyXml(android.content.Context,androidx.core.content.res.FontResourcesParserCompat$FamilyResourceEntry,android.content.res.Resources,int,int,androidx.core.content.res.ResourcesCompat$FontCallback,android.os.Handler,boolean) -> do
    android.graphics.Typeface createFromResourcesFontFile(android.content.Context,android.content.res.Resources,int,java.lang.String,int) -> do
    java.lang.String createResourceUid(android.content.res.Resources,int,int) -> do
    android.graphics.Typeface findFromCache(android.content.res.Resources,int,int) -> if
    android.graphics.Typeface getBestFontFromFamily(android.content.Context,android.graphics.Typeface,int) -> if
androidx.core.graphics.TypefaceCompatApi21Impl -> if.try.int.int:
    java.lang.reflect.Constructor sFontFamilyCtor -> for
    java.lang.Class sFontFamily -> if
    java.lang.reflect.Method sCreateFromFamiliesWithDefault -> new
    java.lang.reflect.Method sAddFontWeightStyle -> int
    boolean sHasInitBeenCalled -> try
    boolean addFontWeightStyle(java.lang.Object,java.lang.String,int,boolean) -> do
    android.graphics.Typeface createFromFamiliesWithDefault(java.lang.Object) -> do
    android.graphics.Typeface createFromFontFamilyFilesResourceEntry(android.content.Context,androidx.core.content.res.FontResourcesParserCompat$FontFamilyFilesResourceEntry,android.content.res.Resources,int) -> do
    android.graphics.Typeface createFromFontInfo(android.content.Context,android.os.CancellationSignal,androidx.core.provider.FontsContractCompat$FontInfo[],int) -> do
    java.io.File getFile(android.os.ParcelFileDescriptor) -> do
    void init() -> do
    java.lang.Object newFamily() -> if
androidx.core.graphics.TypefaceCompatApi24Impl -> if.try.int.new:
    java.lang.reflect.Constructor sFontFamilyCtor -> for
    java.lang.Class sFontFamily -> if
    java.lang.reflect.Method sCreateFromFamiliesWithDefault -> new
    java.lang.reflect.Method sAddFontWeightStyle -> int
    boolean addFontWeightStyle(java.lang.Object,java.nio.ByteBuffer,int,int,boolean) -> do
    android.graphics.Typeface createFromFamiliesWithDefault(java.lang.Object) -> do
    android.graphics.Typeface createFromFontFamilyFilesResourceEntry(android.content.Context,androidx.core.content.res.FontResourcesParserCompat$FontFamilyFilesResourceEntry,android.content.res.Resources,int) -> do
    android.graphics.Typeface createFromFontInfo(android.content.Context,android.os.CancellationSignal,androidx.core.provider.FontsContractCompat$FontInfo[],int) -> do
    boolean isUsable() -> do
    java.lang.Object newFamily() -> if
androidx.core.graphics.TypefaceCompatApi26Impl -> if.try.int.try:
    java.lang.Class mFontFamily -> byte
    java.lang.reflect.Method mAddFontFromBuffer -> else
    java.lang.reflect.Method mCreateFromFamiliesWithDefault -> this
    java.lang.reflect.Method mFreeze -> goto
    java.lang.reflect.Method mAbortCreation -> long
    java.lang.reflect.Constructor mFontFamilyCtor -> case
    java.lang.reflect.Method mAddFontFromAssetManager -> char
    boolean addFontFromAssetManager(android.content.Context,java.lang.Object,java.lang.String,int,int,int,android.graphics.fonts.FontVariationAxis[]) -> do
    boolean addFontFromBuffer(java.lang.Object,java.nio.ByteBuffer,int,int,int) -> do
    android.graphics.Typeface createFromFontFamilyFilesResourceEntry(android.content.Context,androidx.core.content.res.FontResourcesParserCompat$FontFamilyFilesResourceEntry,android.content.res.Resources,int) -> do
    android.graphics.Typeface createFromFontInfo(android.content.Context,android.os.CancellationSignal,androidx.core.provider.FontsContractCompat$FontInfo[],int) -> do
    android.graphics.Typeface createFromResourcesFontFile(android.content.Context,android.content.res.Resources,int,java.lang.String,int) -> do
    java.lang.reflect.Method obtainAbortCreationMethod(java.lang.Class) -> do
    void abortCreation(java.lang.Object) -> for
    java.lang.reflect.Method obtainAddFontFromBufferMethod(java.lang.Class) -> for
    java.lang.Class obtainFontFamily() -> for
    android.graphics.Typeface createFromFamiliesWithDefault(java.lang.Object) -> if
    java.lang.reflect.Method obtainAddFontFromAssetManagerMethod(java.lang.Class) -> if
    boolean freeze(java.lang.Object) -> int
    boolean isFontFamilyPrivateAPIAvailable() -> int
    java.lang.reflect.Method obtainCreateFromFamiliesWithDefaultMethod(java.lang.Class) -> int
    java.lang.Object newFamily() -> new
    java.lang.reflect.Constructor obtainFontFamilyCtor(java.lang.Class) -> new
    java.lang.reflect.Method obtainFreezeMethod(java.lang.Class) -> try
androidx.core.graphics.TypefaceCompatApi28Impl -> if.try.int.byte:
    android.graphics.Typeface createFromFamiliesWithDefault(java.lang.Object) -> if
    java.lang.reflect.Method obtainCreateFromFamiliesWithDefaultMethod(java.lang.Class) -> int
androidx.core.graphics.TypefaceCompatBaseImpl -> if.try.int.case:
    java.util.concurrent.ConcurrentHashMap mFontFamilies -> do
    void addFontFamily(android.graphics.Typeface,androidx.core.content.res.FontResourcesParserCompat$FontFamilyFilesResourceEntry) -> do
    android.graphics.Typeface createFromFontFamilyFilesResourceEntry(android.content.Context,androidx.core.content.res.FontResourcesParserCompat$FontFamilyFilesResourceEntry,android.content.res.Resources,int) -> do
    android.graphics.Typeface createFromFontInfo(android.content.Context,android.os.CancellationSignal,androidx.core.provider.FontsContractCompat$FontInfo[],int) -> do
    android.graphics.Typeface createFromInputStream(android.content.Context,java.io.InputStream) -> do
    android.graphics.Typeface createFromResourcesFontFile(android.content.Context,android.content.res.Resources,int,java.lang.String,int) -> do
    androidx.core.content.res.FontResourcesParserCompat$FontFileResourceEntry findBestEntry(androidx.core.content.res.FontResourcesParserCompat$FontFamilyFilesResourceEntry,int) -> do
    java.lang.Object findBestFont(java.lang.Object[],int,androidx.core.graphics.TypefaceCompatBaseImpl$StyleExtractor) -> do
    androidx.core.provider.FontsContractCompat$FontInfo findBestInfo(androidx.core.provider.FontsContractCompat$FontInfo[],int) -> do
    androidx.core.content.res.FontResourcesParserCompat$FontFamilyFilesResourceEntry getFontFamily(android.graphics.Typeface) -> do
    long getUniqueKey(android.graphics.Typeface) -> if
androidx.core.graphics.TypefaceCompatBaseImpl$1 -> if.try.int.case$do:
    int getWeight(androidx.core.provider.FontsContractCompat$FontInfo) -> do
    int getWeight(java.lang.Object) -> do
    boolean isItalic(androidx.core.provider.FontsContractCompat$FontInfo) -> if
    boolean isItalic(java.lang.Object) -> if
androidx.core.graphics.TypefaceCompatBaseImpl$2 -> if.try.int.case$if:
    int getWeight(androidx.core.content.res.FontResourcesParserCompat$FontFileResourceEntry) -> do
    int getWeight(java.lang.Object) -> do
    boolean isItalic(androidx.core.content.res.FontResourcesParserCompat$FontFileResourceEntry) -> if
    boolean isItalic(java.lang.Object) -> if
androidx.core.graphics.TypefaceCompatBaseImpl$StyleExtractor -> if.try.int.case$for:
    int getWeight(java.lang.Object) -> do
    boolean isItalic(java.lang.Object) -> if
androidx.core.graphics.TypefaceCompatUtil -> if.try.int.char:
    void closeQuietly(java.io.Closeable) -> do
    java.nio.ByteBuffer copyToDirectBuffer(android.content.Context,android.content.res.Resources,int) -> do
    boolean copyToFile(java.io.File,android.content.res.Resources,int) -> do
    boolean copyToFile(java.io.File,java.io.InputStream) -> do
    java.io.File getTempFile(android.content.Context) -> do
    java.nio.ByteBuffer mmap(android.content.Context,android.os.CancellationSignal,android.net.Uri) -> do
    java.nio.ByteBuffer mmap(java.io.File) -> do
androidx.core.graphics.drawable.DrawableCompat -> androidx.core.graphics.drawable.do:
    boolean sGetLayoutDirectionMethodFetched -> int
    boolean sSetLayoutDirectionMethodFetched -> if
    java.lang.reflect.Method sGetLayoutDirectionMethod -> for
    java.lang.reflect.Method sSetLayoutDirectionMethod -> do
    void jumpToCurrentState(android.graphics.drawable.Drawable) -> byte
    android.graphics.drawable.Drawable unwrap(android.graphics.drawable.Drawable) -> case
    android.graphics.drawable.Drawable wrap(android.graphics.drawable.Drawable) -> char
    void applyTheme(android.graphics.drawable.Drawable,android.content.res.Resources$Theme) -> do
    boolean canApplyTheme(android.graphics.drawable.Drawable) -> do
    void inflate(android.graphics.drawable.Drawable,android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
    void setAutoMirrored(android.graphics.drawable.Drawable,boolean) -> do
    void setHotspot(android.graphics.drawable.Drawable,float,float) -> do
    void setHotspotBounds(android.graphics.drawable.Drawable,int,int,int,int) -> do
    boolean setLayoutDirection(android.graphics.drawable.Drawable,int) -> do
    void setTintList(android.graphics.drawable.Drawable,android.content.res.ColorStateList) -> do
    void setTintMode(android.graphics.drawable.Drawable,android.graphics.PorterDuff$Mode) -> do
    int getAlpha(android.graphics.drawable.Drawable) -> for
    void clearColorFilter(android.graphics.drawable.Drawable) -> if
    void setTint(android.graphics.drawable.Drawable,int) -> if
    android.graphics.ColorFilter getColorFilter(android.graphics.drawable.Drawable) -> int
    int getLayoutDirection(android.graphics.drawable.Drawable) -> new
    boolean isAutoMirrored(android.graphics.drawable.Drawable) -> try
androidx.core.graphics.drawable.IconCompat -> androidx.core.graphics.drawable.IconCompat:
    android.os.Parcelable mParcelable -> int
    android.graphics.PorterDuff$Mode DEFAULT_TINT_MODE -> else
    int mType -> do
    int mInt1 -> new
    byte[] mData -> for
    int mInt2 -> try
    java.lang.Object mObj1 -> if
    android.content.res.ColorStateList mTintList -> byte
    java.lang.String mTintModeStr -> char
    android.graphics.PorterDuff$Mode mTintMode -> case
    int getResId() -> do
    int getResId(android.graphics.drawable.Icon) -> do
    void onPreParceling(boolean) -> do
    java.lang.String typeToString(int) -> do
    void onPostParceling() -> for
    java.lang.String getResPackage() -> if
    java.lang.String getResPackage(android.graphics.drawable.Icon) -> if
androidx.core.graphics.drawable.TintAwareDrawable -> androidx.core.graphics.drawable.if:
androidx.core.graphics.drawable.WrappedDrawable -> androidx.core.graphics.drawable.for:
    android.graphics.drawable.Drawable getWrappedDrawable() -> do
    void setWrappedDrawable(android.graphics.drawable.Drawable) -> do
androidx.core.graphics.drawable.WrappedDrawableApi14 -> androidx.core.graphics.drawable.int:
    int mCurrentColor -> if
    android.graphics.PorterDuff$Mode mCurrentMode -> for
    boolean mColorFilterSet -> int
    android.graphics.drawable.Drawable mDrawable -> byte
    boolean mMutated -> try
    android.graphics.PorterDuff$Mode DEFAULT_TINT_MODE -> case
    androidx.core.graphics.drawable.WrappedDrawableState mState -> new
    android.graphics.drawable.Drawable getWrappedDrawable() -> do
    void setWrappedDrawable(android.graphics.drawable.Drawable) -> do
    void updateLocalState(android.content.res.Resources) -> do
    boolean updateTint(int[]) -> do
    androidx.core.graphics.drawable.WrappedDrawableState mutateConstantState() -> for
    boolean isCompatTintEnabled() -> if
androidx.core.graphics.drawable.WrappedDrawableApi21 -> androidx.core.graphics.drawable.new:
    java.lang.reflect.Method sIsProjectedDrawableMethod -> char
    boolean isCompatTintEnabled() -> if
    void findAndCacheIsProjectedDrawableMethod() -> int
androidx.core.graphics.drawable.WrappedDrawableState -> androidx.core.graphics.drawable.try:
    android.graphics.drawable.Drawable$ConstantState mDrawableState -> if
    int mChangingConfigurations -> do
    android.graphics.PorterDuff$Mode mTintMode -> int
    android.content.res.ColorStateList mTint -> for
    boolean canConstantState() -> do
androidx.core.internal.view.SupportMenu -> if.try.new.do.do:
androidx.core.internal.view.SupportMenuItem -> if.try.new.do.if:
    androidx.core.view.ActionProvider getSupportActionProvider() -> do
    androidx.core.internal.view.SupportMenuItem setSupportActionProvider(androidx.core.view.ActionProvider) -> do
androidx.core.internal.view.SupportSubMenu -> if.try.new.do.for:
androidx.core.math.MathUtils -> if.try.try.do:
    float clamp(float,float,float) -> do
    int clamp(int,int,int) -> do
androidx.core.os.TraceCompat -> if.try.byte.do:
    void beginSection(java.lang.String) -> do
    void endSection() -> do
androidx.core.provider.FontRequest -> if.try.case.do:
    java.lang.String mQuery -> for
    java.util.List mCertificates -> int
    java.lang.String mProviderAuthority -> do
    java.lang.String mProviderPackage -> if
    int mCertificatesArray -> new
    java.lang.String mIdentifier -> try
    java.util.List getCertificates() -> do
    java.lang.String getIdentifier() -> for
    int getCertificatesArrayResId() -> if
    java.lang.String getProviderAuthority() -> int
    java.lang.String getProviderPackage() -> new
    java.lang.String getQuery() -> try
androidx.core.provider.FontsContractCompat -> if.try.case.if:
    androidx.collection.SimpleArrayMap sPendingReplies -> int
    java.lang.Object sLock -> for
    androidx.core.provider.SelfDestructiveThread sBackgroundThread -> if
    java.util.Comparator sByteArrayComparator -> new
    androidx.collection.LruCache sTypefaceCache -> do
    java.util.List convertToByteArrayList(android.content.pm.Signature[]) -> do
    boolean equalsByteArrayList(java.util.List,java.util.List) -> do
    androidx.core.provider.FontsContractCompat$FontFamilyResult fetchFonts(android.content.Context,android.os.CancellationSignal,androidx.core.provider.FontRequest) -> do
    java.util.List getCertificates(androidx.core.provider.FontRequest,android.content.res.Resources) -> do
    androidx.core.provider.FontsContractCompat$FontInfo[] getFontFromProvider(android.content.Context,androidx.core.provider.FontRequest,java.lang.String,android.os.CancellationSignal) -> do
    androidx.core.provider.FontsContractCompat$TypefaceResult getFontInternal(android.content.Context,androidx.core.provider.FontRequest,int) -> do
    android.graphics.Typeface getFontSync(android.content.Context,androidx.core.provider.FontRequest,androidx.core.content.res.ResourcesCompat$FontCallback,android.os.Handler,boolean,int,int) -> do
    android.content.pm.ProviderInfo getProvider(android.content.pm.PackageManager,androidx.core.provider.FontRequest,android.content.res.Resources) -> do
    java.util.Map prepareFontData(android.content.Context,androidx.core.provider.FontsContractCompat$FontInfo[],android.os.CancellationSignal) -> do
androidx.core.provider.FontsContractCompat$1 -> if.try.case.if$do:
    int val$style -> for
    androidx.core.provider.FontRequest val$request -> if
    java.lang.String val$id -> int
    android.content.Context val$context -> do
androidx.core.provider.FontsContractCompat$2 -> if.try.case.if$if:
    androidx.core.content.res.ResourcesCompat$FontCallback val$fontCallback -> do
    android.os.Handler val$handler -> if
    void onReply(androidx.core.provider.FontsContractCompat$TypefaceResult) -> do
    void onReply(java.lang.Object) -> do
androidx.core.provider.FontsContractCompat$3 -> if.try.case.if$for:
    java.lang.String val$id -> do
    void onReply(androidx.core.provider.FontsContractCompat$TypefaceResult) -> do
    void onReply(java.lang.Object) -> do
androidx.core.provider.FontsContractCompat$5 -> if.try.case.if$int:
    int compare(byte[],byte[]) -> do
androidx.core.provider.FontsContractCompat$FontFamilyResult -> if.try.case.if$new:
    androidx.core.provider.FontsContractCompat$FontInfo[] mFonts -> if
    int mStatusCode -> do
    androidx.core.provider.FontsContractCompat$FontInfo[] getFonts() -> do
    int getStatusCode() -> if
androidx.core.provider.FontsContractCompat$FontInfo -> if.try.case.if$try:
    int mTtcIndex -> if
    android.net.Uri mUri -> do
    boolean mItalic -> int
    int mWeight -> for
    int mResultCode -> new
    int getResultCode() -> do
    android.net.Uri getUri() -> for
    int getTtcIndex() -> if
    int getWeight() -> int
    boolean isItalic() -> new
androidx.core.provider.FontsContractCompat$TypefaceResult -> if.try.case.if$byte:
    int mResult -> if
    android.graphics.Typeface mTypeface -> do
androidx.core.provider.SelfDestructiveThread -> if.try.case.for:
    android.os.HandlerThread mThread -> if
    java.lang.Object mLock -> do
    int mGeneration -> int
    int mPriority -> byte
    java.lang.String mThreadName -> case
    android.os.Handler$Callback mCallback -> new
    int mDestructAfterMillisec -> try
    android.os.Handler mHandler -> for
    void onDestruction() -> do
    void onInvokeRunnable(java.lang.Runnable) -> do
    void postAndReply(java.util.concurrent.Callable,androidx.core.provider.SelfDestructiveThread$ReplyCallback) -> do
    java.lang.Object postAndWait(java.util.concurrent.Callable,int) -> do
    void post(java.lang.Runnable) -> if
androidx.core.provider.SelfDestructiveThread$1 -> if.try.case.for$do:
    androidx.core.provider.SelfDestructiveThread this$0 -> do
androidx.core.provider.SelfDestructiveThread$2 -> if.try.case.for$if:
    androidx.core.provider.SelfDestructiveThread$ReplyCallback val$reply -> int
    java.util.concurrent.Callable val$callable -> if
    android.os.Handler val$callingHandler -> for
androidx.core.provider.SelfDestructiveThread$2$1 -> if.try.case.for$if$do:
    androidx.core.provider.SelfDestructiveThread$2 this$1 -> for
    java.lang.Object val$result -> if
androidx.core.provider.SelfDestructiveThread$3 -> if.try.case.for$for:
    java.util.concurrent.locks.Condition val$cond -> try
    java.util.concurrent.Callable val$callable -> for
    java.util.concurrent.atomic.AtomicReference val$holder -> if
    java.util.concurrent.locks.ReentrantLock val$lock -> int
    java.util.concurrent.atomic.AtomicBoolean val$running -> new
androidx.core.provider.SelfDestructiveThread$ReplyCallback -> if.try.case.for$int:
    void onReply(java.lang.Object) -> do
androidx.core.text.BidiFormatter -> if.try.char.do:
    androidx.core.text.BidiFormatter DEFAULT_LTR_INSTANCE -> byte
    boolean mIsRtlContext -> do
    int mFlags -> if
    androidx.core.text.TextDirectionHeuristicCompat DEFAULT_TEXT_DIRECTION_HEURISTIC -> int
    java.lang.String LRM_STRING -> new
    androidx.core.text.BidiFormatter DEFAULT_RTL_INSTANCE -> case
    androidx.core.text.TextDirectionHeuristicCompat mDefaultTextDirectionHeuristicCompat -> for
    java.lang.String RLM_STRING -> try
    boolean getStereoReset() -> do
    boolean isRtlLocale(java.util.Locale) -> do
    java.lang.String markAfter(java.lang.CharSequence,androidx.core.text.TextDirectionHeuristicCompat) -> do
    java.lang.CharSequence unicodeWrap(java.lang.CharSequence) -> do
    java.lang.CharSequence unicodeWrap(java.lang.CharSequence,androidx.core.text.TextDirectionHeuristicCompat,boolean) -> do
    int getExitDir(java.lang.CharSequence) -> for
    int getEntryDir(java.lang.CharSequence) -> if
    androidx.core.text.BidiFormatter getInstance() -> if
    java.lang.String markBefore(java.lang.CharSequence,androidx.core.text.TextDirectionHeuristicCompat) -> if
androidx.core.text.BidiFormatter$Builder -> if.try.char.do$do:
    boolean mIsRtlContext -> do
    int mFlags -> if
    androidx.core.text.TextDirectionHeuristicCompat mTextDirectionHeuristicCompat -> for
    androidx.core.text.BidiFormatter build() -> do
    androidx.core.text.BidiFormatter getDefaultInstanceFromContext(boolean) -> do
    void initialize(boolean) -> if
androidx.core.text.BidiFormatter$DirectionalityEstimator -> if.try.char.do$if:
    java.lang.CharSequence text -> do
    int charIndex -> int
    char lastChar -> new
    boolean isHtml -> if
    int length -> for
    byte[] DIR_TYPE_CACHE -> try
    byte skipTagBackward() -> byte
    byte skipTagForward() -> case
    byte dirTypeBackward() -> do
    byte getCachedDirectionality(char) -> do
    int getEntryDir() -> for
    byte dirTypeForward() -> if
    int getExitDir() -> int
    byte skipEntityBackward() -> new
    byte skipEntityForward() -> try
androidx.core.text.ICUCompat -> if.try.char.if:
    java.lang.reflect.Method sAddLikelySubtagsMethod -> if
    java.lang.reflect.Method sGetScriptMethod -> do
    java.lang.String addLikelySubtags(java.util.Locale) -> do
    java.lang.String getScript(java.lang.String) -> do
    java.lang.String maximizeAndGetScript(java.util.Locale) -> if
androidx.core.text.PrecomputedTextCompat -> if.try.char.for:
    android.text.Spannable mText -> if
    androidx.core.text.PrecomputedTextCompat$Params mParams -> for
    androidx.core.text.PrecomputedTextCompat$Params getParams() -> do
androidx.core.text.PrecomputedTextCompat$Params -> if.try.char.for$do:
    int mHyphenationFrequency -> int
    int mBreakStrategy -> for
    android.text.PrecomputedText$Params mWrapped -> new
    android.text.TextDirectionHeuristic mTextDir -> if
    android.text.TextPaint mPaint -> do
    boolean equalsWithoutTextDirection(androidx.core.text.PrecomputedTextCompat$Params) -> do
    int getBreakStrategy() -> do
    android.text.TextDirectionHeuristic getTextDirection() -> for
    int getHyphenationFrequency() -> if
    android.text.TextPaint getTextPaint() -> int
androidx.core.text.PrecomputedTextCompat$Params$Builder -> if.try.char.for$do$do:
    int mHyphenationFrequency -> int
    int mBreakStrategy -> for
    android.text.TextDirectionHeuristic mTextDir -> if
    android.text.TextPaint mPaint -> do
    androidx.core.text.PrecomputedTextCompat$Params build() -> do
    androidx.core.text.PrecomputedTextCompat$Params$Builder setBreakStrategy(int) -> do
    androidx.core.text.PrecomputedTextCompat$Params$Builder setTextDirection(android.text.TextDirectionHeuristic) -> do
    androidx.core.text.PrecomputedTextCompat$Params$Builder setHyphenationFrequency(int) -> if
androidx.core.text.TextDirectionHeuristicCompat -> if.try.char.int:
    boolean isRtl(java.lang.CharSequence,int,int) -> do
androidx.core.text.TextDirectionHeuristicsCompat -> if.try.char.new:
    androidx.core.text.TextDirectionHeuristicCompat LTR -> do
    androidx.core.text.TextDirectionHeuristicCompat RTL -> if
    androidx.core.text.TextDirectionHeuristicCompat FIRSTSTRONG_RTL -> int
    androidx.core.text.TextDirectionHeuristicCompat FIRSTSTRONG_LTR -> for
    int isRtlText(int) -> do
    int isRtlTextOrFormat(int) -> if
androidx.core.text.TextDirectionHeuristicsCompat$AnyStrong -> if.try.char.new$do:
    boolean mLookForRtl -> do
    androidx.core.text.TextDirectionHeuristicsCompat$AnyStrong INSTANCE_RTL -> if
    int checkRtl(java.lang.CharSequence,int,int) -> do
androidx.core.text.TextDirectionHeuristicsCompat$FirstStrong -> if.try.char.new$if:
    androidx.core.text.TextDirectionHeuristicsCompat$FirstStrong INSTANCE -> do
    int checkRtl(java.lang.CharSequence,int,int) -> do
androidx.core.text.TextDirectionHeuristicsCompat$TextDirectionAlgorithm -> if.try.char.new$for:
    int checkRtl(java.lang.CharSequence,int,int) -> do
androidx.core.text.TextDirectionHeuristicsCompat$TextDirectionHeuristicImpl -> if.try.char.new$int:
    androidx.core.text.TextDirectionHeuristicsCompat$TextDirectionAlgorithm mAlgorithm -> do
    boolean defaultIsRtl() -> do
    boolean isRtl(java.lang.CharSequence,int,int) -> do
    boolean doCheck(java.lang.CharSequence,int,int) -> if
androidx.core.text.TextDirectionHeuristicsCompat$TextDirectionHeuristicInternal -> if.try.char.new$new:
    boolean mDefaultIsRtl -> if
    boolean defaultIsRtl() -> do
androidx.core.text.TextDirectionHeuristicsCompat$TextDirectionHeuristicLocale -> if.try.char.new$try:
    androidx.core.text.TextDirectionHeuristicsCompat$TextDirectionHeuristicLocale INSTANCE -> if
    boolean defaultIsRtl() -> do
androidx.core.text.TextUtilsCompat -> if.try.char.try:
    java.util.Locale ROOT -> do
    int getLayoutDirectionFromFirstChar(java.util.Locale) -> do
    int getLayoutDirectionFromLocale(java.util.Locale) -> if
androidx.core.util.DebugUtils -> if.try.else.do:
    void buildShortClassTag(java.lang.Object,java.lang.StringBuilder) -> do
androidx.core.util.LogWriter -> if.try.else.if:
    java.lang.StringBuilder mBuilder -> for
    java.lang.String mTag -> if
    void flushBuilder() -> do
androidx.core.util.ObjectsCompat -> if.try.else.for:
    boolean equals(java.lang.Object,java.lang.Object) -> do
    int hash(java.lang.Object[]) -> do
androidx.core.util.Pair -> if.try.else.int:
    java.lang.Object first -> do
    java.lang.Object second -> if
androidx.core.util.Pools$Pool -> if.try.else.new:
    java.lang.Object acquire() -> do
    boolean release(java.lang.Object) -> do
androidx.core.util.Pools$SimplePool -> if.try.else.try:
    int mPoolSize -> if
    java.lang.Object[] mPool -> do
    java.lang.Object acquire() -> do
    boolean release(java.lang.Object) -> do
    boolean isInPool(java.lang.Object) -> if
androidx.core.util.Pools$SynchronizedPool -> if.try.else.byte:
    java.lang.Object mLock -> for
    java.lang.Object acquire() -> do
    boolean release(java.lang.Object) -> do
androidx.core.util.Preconditions -> if.try.else.case:
    void checkArgument(boolean,java.lang.Object) -> do
    int checkArgumentNonnegative(int) -> do
    java.lang.Object checkNotNull(java.lang.Object) -> do
    java.lang.Object checkNotNull(java.lang.Object,java.lang.Object) -> do
androidx.core.view.AccessibilityDelegateCompat -> if.try.goto.do:
    android.view.View$AccessibilityDelegate DEFAULT_DELEGATE -> for
    android.view.View$AccessibilityDelegate mBridge -> if
    android.view.View$AccessibilityDelegate mOriginalDelegate -> do
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> do
    androidx.core.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> do
    android.view.View$AccessibilityDelegate getBridge() -> do
    boolean isSpanStillValid(android.text.style.ClickableSpan,android.view.View) -> do
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> do
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> do
    boolean performClickableSpanAction(int,android.view.View) -> do
    void sendAccessibilityEvent(android.view.View,int) -> do
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> for
    java.util.List getActionList(android.view.View) -> if
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> if
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> int
androidx.core.view.AccessibilityDelegateCompat$AccessibilityDelegateAdapter -> if.try.goto.do$do:
    androidx.core.view.AccessibilityDelegateCompat mCompat -> do
androidx.core.view.ActionProvider -> if.try.goto.if:
    androidx.core.view.ActionProvider$VisibilityListener mVisibilityListener -> do
    boolean hasSubMenu() -> do
    android.view.View onCreateActionView(android.view.MenuItem) -> do
    void onPrepareSubMenu(android.view.SubMenu) -> do
    void setSubUiVisibilityListener(androidx.core.view.ActionProvider$SubUiVisibilityListener) -> do
    void setVisibilityListener(androidx.core.view.ActionProvider$VisibilityListener) -> do
    android.view.View onCreateActionView() -> for
    boolean isVisible() -> if
    boolean onPerformDefaultAction() -> int
    boolean overridesItemVisibility() -> new
    void reset() -> try
androidx.core.view.ActionProvider$SubUiVisibilityListener -> if.try.goto.if$do:
androidx.core.view.ActionProvider$VisibilityListener -> if.try.goto.if$if:
androidx.core.view.GravityCompat -> if.try.goto.for:
    void apply(int,int,int,android.graphics.Rect,android.graphics.Rect,int) -> do
    int getAbsoluteGravity(int,int) -> do
androidx.core.view.KeyEventDispatcher -> if.try.goto.int:
    boolean sActionBarFieldsFetched -> do
    boolean sDialogFieldsFetched -> for
    java.lang.reflect.Method sActionBarOnMenuKeyMethod -> if
    java.lang.reflect.Field sDialogKeyListenerField -> int
    boolean actionBarOnMenuKeyEventPre28(android.app.ActionBar,android.view.KeyEvent) -> do
    boolean activitySuperDispatchKeyEventPre28(android.app.Activity,android.view.KeyEvent) -> do
    boolean dialogSuperDispatchKeyEventPre28(android.app.Dialog,android.view.KeyEvent) -> do
    boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent) -> do
    boolean dispatchKeyEvent(androidx.core.view.KeyEventDispatcher$Component,android.view.View,android.view.Window$Callback,android.view.KeyEvent) -> do
    android.content.DialogInterface$OnKeyListener getDialogKeyListenerPre28(android.app.Dialog) -> do
androidx.core.view.KeyEventDispatcher$Component -> if.try.goto.int$do:
    boolean superDispatchKeyEvent(android.view.KeyEvent) -> do
androidx.core.view.LayoutInflaterCompat -> if.try.goto.new:
    java.lang.reflect.Field sLayoutInflaterFactory2Field -> do
    boolean sCheckedField -> if
    void forceSetFactory2(android.view.LayoutInflater,android.view.LayoutInflater$Factory2) -> do
    void setFactory2(android.view.LayoutInflater,android.view.LayoutInflater$Factory2) -> if
androidx.core.view.MarginLayoutParamsCompat -> if.try.goto.try:
    int getMarginEnd(android.view.ViewGroup$MarginLayoutParams) -> do
    int getMarginStart(android.view.ViewGroup$MarginLayoutParams) -> if
androidx.core.view.MenuItemCompat -> if.try.goto.byte:
    android.view.MenuItem setActionProvider(android.view.MenuItem,androidx.core.view.ActionProvider) -> do
    void setAlphabeticShortcut(android.view.MenuItem,char,int) -> do
    void setContentDescription(android.view.MenuItem,java.lang.CharSequence) -> do
    void setIconTintList(android.view.MenuItem,android.content.res.ColorStateList) -> do
    void setIconTintMode(android.view.MenuItem,android.graphics.PorterDuff$Mode) -> do
    void setNumericShortcut(android.view.MenuItem,char,int) -> if
    void setTooltipText(android.view.MenuItem,java.lang.CharSequence) -> if
androidx.core.view.MotionEventCompat -> if.try.goto.case:
    int findPointerIndex(android.view.MotionEvent,int) -> do
    int getActionIndex(android.view.MotionEvent) -> do
    float getY(android.view.MotionEvent,int) -> for
    int getActionMasked(android.view.MotionEvent) -> if
    int getPointerId(android.view.MotionEvent,int) -> if
    boolean isFromSource(android.view.MotionEvent,int) -> int
androidx.core.view.NestedScrollingChild -> if.try.goto.goto:
androidx.core.view.NestedScrollingChild2 -> if.try.goto.char:
androidx.core.view.NestedScrollingChild3 -> if.try.goto.else:
androidx.core.view.NestedScrollingChildHelper -> if.try.goto.long:
    android.view.ViewParent mNestedScrollingParentNonTouch -> if
    android.view.View mView -> for
    android.view.ViewParent mNestedScrollingParentTouch -> do
    boolean mIsNestedScrollingEnabled -> int
    int[] mTempNestedScrollConsumed -> new
    boolean dispatchNestedFling(float,float,boolean) -> do
    boolean dispatchNestedPreFling(float,float) -> do
    boolean dispatchNestedPreScroll(int,int,int[],int[]) -> do
    boolean dispatchNestedPreScroll(int,int,int[],int[],int) -> do
    void dispatchNestedScroll(int,int,int,int,int[],int,int[]) -> do
    boolean dispatchNestedScroll(int,int,int,int,int[]) -> do
    boolean dispatchNestedScroll(int,int,int,int,int[],int) -> do
    boolean hasNestedScrollingParent() -> do
    boolean hasNestedScrollingParent(int) -> do
    void setNestedScrollingEnabled(boolean) -> do
    void setNestedScrollingParentForType(int,android.view.ViewParent) -> do
    boolean startNestedScroll(int,int) -> do
    void stopNestedScroll() -> for
    void stopNestedScroll(int) -> for
    boolean dispatchNestedScrollInternal(int,int,int,int,int[],int,int[]) -> if
    boolean isNestedScrollingEnabled() -> if
    boolean startNestedScroll(int) -> if
    android.view.ViewParent getNestedScrollingParentForType(int) -> int
    int[] getTempNestedScrollConsumed() -> int
androidx.core.view.NestedScrollingParent -> if.try.goto.break:
androidx.core.view.NestedScrollingParent2 -> if.try.goto.this:
    void onNestedPreScroll(android.view.View,int,int,int[],int) -> do
    void onNestedScroll(android.view.View,int,int,int,int,int) -> do
    void onNestedScrollAccepted(android.view.View,android.view.View,int,int) -> do
    void onStopNestedScroll(android.view.View,int) -> do
    boolean onStartNestedScroll(android.view.View,android.view.View,int,int) -> if
androidx.core.view.NestedScrollingParent3 -> if.try.goto.void:
    void onNestedScroll(android.view.View,int,int,int,int,int,int[]) -> do
androidx.core.view.NestedScrollingParentHelper -> if.try.goto.catch:
    int mNestedScrollAxesNonTouch -> if
    int mNestedScrollAxesTouch -> do
    int getNestedScrollAxes() -> do
    void onNestedScrollAccepted(android.view.View,android.view.View,int) -> do
    void onNestedScrollAccepted(android.view.View,android.view.View,int,int) -> do
    void onStopNestedScroll(android.view.View,int) -> do
androidx.core.view.OnApplyWindowInsetsListener -> if.try.goto.class:
    androidx.core.view.WindowInsetsCompat onApplyWindowInsets(android.view.View,androidx.core.view.WindowInsetsCompat) -> do
androidx.core.view.OneShotPreDrawListener -> if.try.goto.const:
    android.view.ViewTreeObserver mViewTreeObserver -> for
    android.view.View mView -> if
    java.lang.Runnable mRunnable -> int
    androidx.core.view.OneShotPreDrawListener add(android.view.View,java.lang.Runnable) -> do
    void removeListener() -> do
androidx.core.view.TintableBackgroundView -> if.try.goto.final:
androidx.core.view.ViewCompat -> if.try.goto.float:
    java.lang.reflect.Field sMinWidthField -> do
    java.lang.reflect.Field sMinHeightField -> for
    boolean sMinHeightFieldFetched -> int
    java.util.WeakHashMap sViewPropertyAnimatorMap -> try
    java.lang.ThreadLocal sThreadLocalRect -> else
    boolean sMinWidthFieldFetched -> if
    java.lang.reflect.Method sChildrenDrawingOrderMethod -> byte
    java.util.WeakHashMap sTransitionNameMap -> new
    boolean sAccessibilityDelegateCheckFailed -> char
    java.lang.reflect.Field sAccessibilityDelegateField -> case
    boolean isScreenReaderFocusable(android.view.View) -> boolean
    int getLayoutDirection(android.view.View) -> break
    android.content.res.ColorStateList getBackgroundTintList(android.view.View) -> byte
    void removeAccessibilityAction(android.view.View,int) -> byte
    android.graphics.PorterDuff$Mode getBackgroundTintMode(android.view.View) -> case
    void setAccessibilityLiveRegion(android.view.View,int) -> case
    int getMinimumHeight(android.view.View) -> catch
    android.graphics.Rect getClipBounds(android.view.View) -> char
    void setImportantForAccessibility(android.view.View,int) -> char
    int getMinimumWidth(android.view.View) -> class
    androidx.core.view.AccessibilityDelegateCompat getOrCreateAccessibilityDelegateCompat(android.view.View) -> const
    void postInvalidateOnAnimation(android.view.View) -> default
    androidx.core.view.ViewCompat$AccessibilityViewProperty accessibilityHeadingProperty() -> do
    void addAccessibilityAction(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat) -> do
    androidx.core.view.ViewPropertyAnimatorCompat animate(android.view.View) -> do
    boolean canScrollVertically(android.view.View,int) -> do
    androidx.core.view.WindowInsetsCompat dispatchApplyWindowInsets(android.view.View,androidx.core.view.WindowInsetsCompat) -> do
    boolean dispatchUnhandledKeyEventBeforeCallback(android.view.View,android.view.KeyEvent) -> do
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> do
    void postOnAnimation(android.view.View,java.lang.Runnable) -> do
    void postOnAnimationDelayed(android.view.View,java.lang.Runnable,long) -> do
    void removeActionWithId(int,android.view.View) -> do
    void replaceAccessibilityAction(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat,java.lang.CharSequence,androidx.core.view.accessibility.AccessibilityViewCommand) -> do
    void setAccessibilityDelegate(android.view.View,androidx.core.view.AccessibilityDelegateCompat) -> do
    void setAccessibilityHeading(android.view.View,boolean) -> do
    void setBackground(android.view.View,android.graphics.drawable.Drawable) -> do
    void setBackgroundTintList(android.view.View,android.content.res.ColorStateList) -> do
    void setBackgroundTintMode(android.view.View,android.graphics.PorterDuff$Mode) -> do
    void setChildrenDrawingOrderEnabled(android.view.ViewGroup,boolean) -> do
    void setClipBounds(android.view.View,android.graphics.Rect) -> do
    void setElevation(android.view.View,float) -> do
    void setOnApplyWindowInsetsListener(android.view.View,androidx.core.view.OnApplyWindowInsetsListener) -> do
    void setPaddingRelative(android.view.View,int,int,int,int) -> do
    void setScrollIndicators(android.view.View,int,int) -> do
    void setTransitionName(android.view.View,java.lang.String) -> do
    boolean hasOnClickListeners(android.view.View) -> double
    android.view.Display getDisplay(android.view.View) -> else
    void setImportantForAutofill(android.view.View,int) -> else
    void requestApplyInsets(android.view.View) -> extends
    int getPaddingEnd(android.view.View) -> final
    void stopNestedScroll(android.view.View) -> finally
    int getPaddingStart(android.view.View) -> float
    void compatOffsetTopAndBottom(android.view.View,int) -> for
    android.view.View$AccessibilityDelegate getAccessibilityDelegateInternal(android.view.View) -> for
    androidx.core.view.ViewCompat$AccessibilityViewProperty paneTitleProperty() -> for
    void setHasTransientState(android.view.View,boolean) -> for
    float getElevation(android.view.View) -> goto
    void compatOffsetLeftAndRight(android.view.View,int) -> if
    boolean dispatchUnhandledKeyEventBeforeHierarchy(android.view.View,android.view.KeyEvent) -> if
    androidx.core.view.AccessibilityDelegateCompat getAccessibilityDelegate(android.view.View) -> if
    android.graphics.Rect getEmptyTempRect() -> if
    androidx.core.view.WindowInsetsCompat onApplyWindowInsets(android.view.View,androidx.core.view.WindowInsetsCompat) -> if
    void setFitsSystemWindows(android.view.View,boolean) -> if
    boolean hasOverlappingRendering(android.view.View) -> import
    int getAccessibilityLiveRegion(android.view.View) -> int
    void notifyViewAccessibilityStateChangedIfNeeded(android.view.View,int) -> int
    androidx.core.view.ViewCompat$AccessibilityViewProperty screenReaderFocusableProperty() -> int
    boolean getFitsSystemWindows(android.view.View) -> long
    boolean hasTransientState(android.view.View) -> native
    java.lang.CharSequence getAccessibilityPaneTitle(android.view.View) -> new
    void offsetLeftAndRight(android.view.View,int) -> new
    void tickleInvalidationFlag(android.view.View) -> package
    boolean isAccessibilityHeading(android.view.View) -> public
    boolean isAttachedToWindow(android.view.View) -> return
    android.view.ViewParent getParentForAccessibility(android.view.View) -> short
    boolean isLaidOut(android.view.View) -> static
    java.lang.String getTransitionName(android.view.View) -> super
    boolean isNestedScrollingEnabled(android.view.View) -> switch
    int getImportantForAccessibility(android.view.View) -> this
    int getWindowSystemUiVisibility(android.view.View) -> throw
    boolean isPaddingRelative(android.view.View) -> throws
    java.util.List getActionList(android.view.View) -> try
    void offsetTopAndBottom(android.view.View,int) -> try
    int getImportantForAutofill(android.view.View) -> void
    float getZ(android.view.View) -> while
androidx.core.view.ViewCompat$1 -> if.try.goto.float$do:
    androidx.core.view.OnApplyWindowInsetsListener val$listener -> do
androidx.core.view.ViewCompat$3 -> if.try.goto.float$if:
    java.lang.Boolean frameworkGet(android.view.View) -> do
    java.lang.Object frameworkGet(android.view.View) -> do
    void frameworkSet(android.view.View,java.lang.Boolean) -> do
    void frameworkSet(android.view.View,java.lang.Object) -> do
    boolean shouldUpdate(java.lang.Object,java.lang.Object) -> do
    boolean shouldUpdate(java.lang.Boolean,java.lang.Boolean) -> if
androidx.core.view.ViewCompat$4 -> if.try.goto.float$for:
    java.lang.CharSequence frameworkGet(android.view.View) -> do
    java.lang.Object frameworkGet(android.view.View) -> do
    void frameworkSet(android.view.View,java.lang.CharSequence) -> do
    void frameworkSet(android.view.View,java.lang.Object) -> do
    boolean shouldUpdate(java.lang.CharSequence,java.lang.CharSequence) -> do
    boolean shouldUpdate(java.lang.Object,java.lang.Object) -> do
androidx.core.view.ViewCompat$5 -> if.try.goto.float$int:
    java.lang.Boolean frameworkGet(android.view.View) -> do
    java.lang.Object frameworkGet(android.view.View) -> do
    void frameworkSet(android.view.View,java.lang.Boolean) -> do
    void frameworkSet(android.view.View,java.lang.Object) -> do
    boolean shouldUpdate(java.lang.Object,java.lang.Object) -> do
    boolean shouldUpdate(java.lang.Boolean,java.lang.Boolean) -> if
androidx.core.view.ViewCompat$AccessibilityPaneVisibilityManager -> if.try.goto.float$new:
    java.util.WeakHashMap mPanesToVisible -> if
    void checkPaneVisibility(android.view.View,boolean) -> do
    void registerForLayoutCallback(android.view.View) -> do
androidx.core.view.ViewCompat$AccessibilityViewProperty -> if.try.goto.float$try:
    int mTagKey -> do
    java.lang.Class mType -> if
    int mFrameworkMinimumSdk -> for
    boolean booleanNullToFalseEquals(java.lang.Boolean,java.lang.Boolean) -> do
    boolean extrasAvailable() -> do
    java.lang.Object frameworkGet(android.view.View) -> do
    void frameworkSet(android.view.View,java.lang.Object) -> do
    boolean shouldUpdate(java.lang.Object,java.lang.Object) -> do
    boolean frameworkAvailable() -> if
    java.lang.Object get(android.view.View) -> if
    void set(android.view.View,java.lang.Object) -> if
androidx.core.view.ViewCompat$OnUnhandledKeyEventListenerCompat -> if.try.goto.float$byte:
    boolean onUnhandledKeyEvent(android.view.View,android.view.KeyEvent) -> do
androidx.core.view.ViewCompat$UnhandledKeyEventManager -> if.try.goto.float$case:
    java.util.ArrayList sViewsWithListeners -> int
    android.util.SparseArray mCapturedKeys -> if
    java.util.WeakHashMap mViewsContainingListeners -> do
    java.lang.ref.WeakReference mLastDispatchedPreViewKeyEvent -> for
    androidx.core.view.ViewCompat$UnhandledKeyEventManager at(android.view.View) -> do
    boolean dispatch(android.view.View,android.view.KeyEvent) -> do
    android.util.SparseArray getCapturedKeys() -> do
    boolean preDispatch(android.view.KeyEvent) -> do
    boolean onUnhandledKeyEvent(android.view.View,android.view.KeyEvent) -> for
    android.view.View dispatchInOrder(android.view.View,android.view.KeyEvent) -> if
    void recalcViewsWithUnhandled() -> if
androidx.core.view.ViewConfigurationCompat -> if.try.goto.short:
    java.lang.reflect.Method sGetScaledScrollFactorMethod -> do
    float getLegacyScrollFactor(android.view.ViewConfiguration,android.content.Context) -> do
    int getScaledHoverSlop(android.view.ViewConfiguration) -> do
    float getScaledVerticalScrollFactor(android.view.ViewConfiguration,android.content.Context) -> for
    float getScaledHorizontalScrollFactor(android.view.ViewConfiguration,android.content.Context) -> if
    boolean shouldShowMenuShortcutsWhenKeyboardPresent(android.view.ViewConfiguration,android.content.Context) -> int
androidx.core.view.ViewGroupCompat -> if.try.goto.super:
    boolean isTransitionGroup(android.view.ViewGroup) -> do
androidx.core.view.ViewParentCompat -> if.try.goto.throw:
    boolean onNestedFling(android.view.ViewParent,android.view.View,float,float,boolean) -> do
    boolean onNestedPreFling(android.view.ViewParent,android.view.View,float,float) -> do
    void onNestedPreScroll(android.view.ViewParent,android.view.View,int,int,int[],int) -> do
    void onNestedScroll(android.view.ViewParent,android.view.View,int,int,int,int,int,int[]) -> do
    void onNestedScrollAccepted(android.view.ViewParent,android.view.View,android.view.View,int,int) -> do
    void onStopNestedScroll(android.view.ViewParent,android.view.View,int) -> do
    boolean requestSendAccessibilityEvent(android.view.ViewParent,android.view.View,android.view.accessibility.AccessibilityEvent) -> do
    boolean onStartNestedScroll(android.view.ViewParent,android.view.View,android.view.View,int,int) -> if
androidx.core.view.ViewPropertyAnimatorCompat -> if.try.goto.while:
    java.lang.ref.WeakReference mView -> do
    int mOldLayerType -> int
    java.lang.Runnable mEndAction -> for
    java.lang.Runnable mStartAction -> if
    androidx.core.view.ViewPropertyAnimatorCompat alpha(float) -> do
    void cancel() -> do
    androidx.core.view.ViewPropertyAnimatorCompat setDuration(long) -> do
    androidx.core.view.ViewPropertyAnimatorCompat setInterpolator(android.view.animation.Interpolator) -> do
    androidx.core.view.ViewPropertyAnimatorCompat setListener(androidx.core.view.ViewPropertyAnimatorListener) -> do
    void setListenerInternal(android.view.View,androidx.core.view.ViewPropertyAnimatorListener) -> do
    androidx.core.view.ViewPropertyAnimatorCompat setUpdateListener(androidx.core.view.ViewPropertyAnimatorUpdateListener) -> do
    void start() -> for
    long getDuration() -> if
    androidx.core.view.ViewPropertyAnimatorCompat setStartDelay(long) -> if
    androidx.core.view.ViewPropertyAnimatorCompat translationY(float) -> if
androidx.core.view.ViewPropertyAnimatorCompat$1 -> if.try.goto.while$do:
    androidx.core.view.ViewPropertyAnimatorListener val$listener -> do
    android.view.View val$view -> if
androidx.core.view.ViewPropertyAnimatorCompat$2 -> if.try.goto.while$if:
    android.view.View val$view -> if
    androidx.core.view.ViewPropertyAnimatorUpdateListener val$listener -> do
androidx.core.view.ViewPropertyAnimatorCompat$ViewPropertyAnimatorListenerApi14 -> if.try.goto.while$for:
    androidx.core.view.ViewPropertyAnimatorCompat mVpa -> do
    boolean mAnimEndCalled -> if
    void onAnimationEnd(android.view.View) -> do
    void onAnimationCancel(android.view.View) -> for
    void onAnimationStart(android.view.View) -> if
androidx.core.view.ViewPropertyAnimatorListener -> if.try.goto.double:
    void onAnimationEnd(android.view.View) -> do
    void onAnimationCancel(android.view.View) -> for
    void onAnimationStart(android.view.View) -> if
androidx.core.view.ViewPropertyAnimatorListenerAdapter -> if.try.goto.import:
    void onAnimationCancel(android.view.View) -> for
    void onAnimationStart(android.view.View) -> if
androidx.core.view.ViewPropertyAnimatorUpdateListener -> if.try.goto.native:
    void onAnimationUpdate(android.view.View) -> do
androidx.core.view.WindowInsetsCompat -> if.try.goto.public:
    java.lang.Object mInsets -> do
    boolean isConsumed() -> byte
    androidx.core.view.WindowInsetsCompat consumeSystemWindowInsets() -> do
    androidx.core.view.WindowInsetsCompat replaceSystemWindowInsets(int,int,int,int) -> do
    java.lang.Object unwrap(androidx.core.view.WindowInsetsCompat) -> do
    androidx.core.view.WindowInsetsCompat wrap(java.lang.Object) -> do
    int getSystemWindowInsetLeft() -> for
    int getSystemWindowInsetBottom() -> if
    int getSystemWindowInsetRight() -> int
    int getSystemWindowInsetTop() -> new
    boolean hasSystemWindowInsets() -> try
androidx.core.view.accessibility.AccessibilityClickableSpanCompat -> if.try.goto.return.do:
    int mOriginalClickableSpanId -> if
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat mNodeInfoCompat -> for
    int mClickableSpanActionId -> int
androidx.core.view.accessibility.AccessibilityEventCompat -> if.try.goto.return.if:
    int getContentChangeTypes(android.view.accessibility.AccessibilityEvent) -> do
    void setContentChangeTypes(android.view.accessibility.AccessibilityEvent,int) -> do
androidx.core.view.accessibility.AccessibilityNodeInfoCompat -> if.try.goto.return.for:
    int mParentVirtualDescendantId -> if
    int sClickableSpanId -> int
    int mVirtualDescendantId -> for
    android.view.accessibility.AccessibilityNodeInfo mInfo -> do
    boolean isFocused() -> break
    void setShowingHintText(boolean) -> break
    java.lang.CharSequence getText() -> byte
    void removeCollectedSpans(android.view.View) -> byte
    void setEnabled(boolean) -> byte
    void setText(java.lang.CharSequence) -> byte
    android.text.style.ClickableSpan[] getClickableSpans(java.lang.CharSequence) -> case
    java.lang.String getViewIdResourceName() -> case
    void setFocusable(boolean) -> case
    boolean isLongClickable() -> catch
    void setVisibleToUser(boolean) -> catch
    boolean isAccessibilityFocused() -> char
    void setFocused(boolean) -> char
    boolean isPassword() -> class
    boolean isScrollable() -> const
    void addAction(int) -> do
    void addAction(androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat) -> do
    void addChild(android.view.View) -> do
    void addChild(android.view.View,int) -> do
    void addSpanLocationToExtras(android.text.style.ClickableSpan,android.text.Spanned,int) -> do
    void addSpansToExtras(java.lang.CharSequence,android.view.View) -> do
    java.util.List extrasIntList(java.lang.String) -> do
    int getActions() -> do
    void getBoundsInParent(android.graphics.Rect) -> do
    int idForClickableSpan(android.text.style.ClickableSpan,android.util.SparseArray) -> do
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat obtain(androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean performAction(int,android.os.Bundle) -> do
    void setAccessibilityFocused(boolean) -> do
    void setBooleanProperty(int,boolean) -> do
    void setClassName(java.lang.CharSequence) -> do
    void setCollectionInfo(java.lang.Object) -> do
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat wrap(android.view.accessibility.AccessibilityNodeInfo) -> do
    boolean hasSpans() -> double
    boolean isCheckable() -> else
    void setHeading(boolean) -> else
    boolean isSelected() -> final
    boolean isShowingHintText() -> float
    boolean getBooleanProperty(int) -> for
    java.lang.CharSequence getClassName() -> for
    void setBoundsInParent(android.graphics.Rect) -> for
    void setChecked(boolean) -> for
    void setError(java.lang.CharSequence) -> for
    void setSource(android.view.View) -> for
    void setSource(android.view.View,int) -> for
    boolean isChecked() -> goto
    void setLongClickable(boolean) -> goto
    java.lang.String getActionSymbolicName(int) -> if
    void getBoundsInScreen(android.graphics.Rect) -> if
    int getChildCount() -> if
    boolean removeAction(androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat) -> if
    void setCheckable(boolean) -> if
    void setCollectionItemInfo(java.lang.Object) -> if
    void setContentDescription(java.lang.CharSequence) -> if
    void setParent(android.view.View) -> if
    void setParent(android.view.View,int) -> if
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat obtain() -> import
    java.lang.CharSequence getContentDescription() -> int
    android.util.SparseArray getOrCreateSpansFromViewTags(android.view.View) -> int
    void setBoundsInScreen(android.graphics.Rect) -> int
    void setClickable(boolean) -> int
    void setHintText(java.lang.CharSequence) -> int
    boolean isClickable() -> long
    void setScreenReaderFocusable(boolean) -> long
    android.os.Bundle getExtras() -> new
    android.util.SparseArray getSpansFromViewTags(android.view.View) -> new
    void setContentInvalid(boolean) -> new
    void setPackageName(java.lang.CharSequence) -> new
    boolean isVisibleToUser() -> short
    void recycle() -> super
    boolean isEnabled() -> this
    void setScrollable(boolean) -> this
    android.view.accessibility.AccessibilityNodeInfo unwrap() -> throw
    java.lang.CharSequence getPackageName() -> try
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat obtain(android.view.View) -> try
    void setDismissable(boolean) -> try
    void setPaneTitle(java.lang.CharSequence) -> try
    boolean isFocusable() -> void
    void setSelected(boolean) -> void
    void clearExtrasSpans() -> while
androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat -> if.try.goto.return.for$do:
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat ACTION_COLLAPSE -> char
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat ACTION_DISMISS -> else
    int mId -> if
    java.lang.Object mAction -> do
    java.lang.Class mViewCommandArgumentClass -> for
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat ACTION_CLEAR_FOCUS -> try
    androidx.core.view.accessibility.AccessibilityViewCommand mCommand -> int
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat ACTION_EXPAND -> case
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat ACTION_CLICK -> byte
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat ACTION_FOCUS -> new
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat createReplacementAction(java.lang.CharSequence,androidx.core.view.accessibility.AccessibilityViewCommand) -> do
    int getId() -> do
    boolean perform(android.view.View,android.os.Bundle) -> do
androidx.core.view.accessibility.AccessibilityNodeInfoCompat$CollectionInfoCompat -> if.try.goto.return.for$if:
    java.lang.Object mInfo -> do
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$CollectionInfoCompat obtain(int,int,boolean) -> do
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$CollectionInfoCompat obtain(int,int,boolean,int) -> do
androidx.core.view.accessibility.AccessibilityNodeInfoCompat$CollectionItemInfoCompat -> if.try.goto.return.for$for:
    java.lang.Object mInfo -> do
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat$CollectionItemInfoCompat obtain(int,int,int,int,boolean,boolean) -> do
androidx.core.view.accessibility.AccessibilityNodeProviderCompat -> if.try.goto.return.int:
    java.lang.Object mProvider -> do
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat createAccessibilityNodeInfo(int) -> do
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> do
    java.lang.Object getProvider() -> do
    boolean performAction(int,int,android.os.Bundle) -> do
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat findFocus(int) -> if
androidx.core.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderApi16 -> if.try.goto.return.int$do:
    androidx.core.view.accessibility.AccessibilityNodeProviderCompat mCompat -> do
androidx.core.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderApi19 -> if.try.goto.return.int$if:
androidx.core.view.accessibility.AccessibilityRecordCompat -> if.try.goto.return.new:
    void setMaxScrollX(android.view.accessibility.AccessibilityRecord,int) -> do
    void setSource(android.view.accessibility.AccessibilityRecord,android.view.View,int) -> do
    void setMaxScrollY(android.view.accessibility.AccessibilityRecord,int) -> if
androidx.core.view.accessibility.AccessibilityViewCommand -> if.try.goto.return.try:
    boolean perform(android.view.View,androidx.core.view.accessibility.AccessibilityViewCommand$CommandArguments) -> do
androidx.core.view.accessibility.AccessibilityViewCommand$CommandArguments -> if.try.goto.return.try$do:
    void setBundle(android.os.Bundle) -> do
androidx.core.view.accessibility.AccessibilityViewCommand$MoveAtGranularityArguments -> if.try.goto.return.try$if:
androidx.core.view.accessibility.AccessibilityViewCommand$MoveHtmlArguments -> if.try.goto.return.try$for:
androidx.core.view.accessibility.AccessibilityViewCommand$MoveWindowArguments -> if.try.goto.return.try$int:
androidx.core.view.accessibility.AccessibilityViewCommand$ScrollToPositionArguments -> if.try.goto.return.try$new:
androidx.core.view.accessibility.AccessibilityViewCommand$SetProgressArguments -> if.try.goto.return.try$try:
androidx.core.view.accessibility.AccessibilityViewCommand$SetSelectionArguments -> if.try.goto.return.try$byte:
androidx.core.view.accessibility.AccessibilityViewCommand$SetTextArguments -> if.try.goto.return.try$case:
androidx.core.widget.AutoScrollHelper -> androidx.core.widget.do:
    float[] mRelativeEdges -> try
    boolean mAlreadyDelayed -> this
    boolean mNeedsCancel -> break
    android.view.View mTarget -> int
    float[] mMinimumVelocity -> goto
    int DEFAULT_ACTIVATION_DELAY -> final
    androidx.core.widget.AutoScrollHelper$ClampedScroller mScroller -> if
    float[] mMaximumVelocity -> long
    boolean mAnimating -> catch
    float[] mRelativeVelocity -> else
    float[] mMaximumEdges -> byte
    boolean mNeedsReset -> void
    boolean mEnabled -> class
    android.view.animation.Interpolator mEdgeInterpolator -> for
    int mActivationDelay -> char
    int mEdgeType -> case
    java.lang.Runnable mRunnable -> new
    boolean mExclusive -> const
    boolean canTargetScrollHorizontally(int) -> do
    void cancelTargetTouch() -> do
    float computeTargetVelocity(int,float,float,float) -> do
    float constrain(float,float,float) -> do
    int constrain(int,int,int) -> do
    float getEdgeValue(float,float,float,float) -> do
    void scrollTargetBy(int,int) -> do
    androidx.core.widget.AutoScrollHelper setEnabled(boolean) -> do
    androidx.core.widget.AutoScrollHelper setMaximumEdges(float,float) -> do
    void requestStop() -> for
    androidx.core.widget.AutoScrollHelper setActivationDelay(int) -> for
    androidx.core.widget.AutoScrollHelper setMinimumVelocity(float,float) -> for
    boolean canTargetScrollVertically(int) -> if
    androidx.core.widget.AutoScrollHelper setMaximumVelocity(float,float) -> if
    boolean shouldAnimate() -> if
    androidx.core.widget.AutoScrollHelper setEdgeType(int) -> int
    androidx.core.widget.AutoScrollHelper setRelativeEdges(float,float) -> int
    void startAnimating() -> int
    androidx.core.widget.AutoScrollHelper setRampDownDuration(int) -> new
    androidx.core.widget.AutoScrollHelper setRelativeVelocity(float,float) -> new
    float constrainEdgeValue(float,float) -> try
    androidx.core.widget.AutoScrollHelper setRampUpDuration(int) -> try
androidx.core.widget.AutoScrollHelper$ClampedScroller -> androidx.core.widget.do$do:
    long mStopTime -> char
    int mRampDownDuration -> if
    float mStopValue -> else
    float mTargetVelocityX -> for
    int mRampUpDuration -> do
    long mDeltaTime -> try
    int mDeltaX -> byte
    long mStartTime -> new
    float mTargetVelocityY -> int
    int mDeltaY -> case
    int mEffectiveRampDown -> goto
    void requestStop() -> byte
    void start() -> case
    void computeScrollDelta() -> do
    float getValueAt(long) -> do
    float interpolateValue(float) -> do
    void setRampDownDuration(int) -> do
    void setTargetVelocity(float,float) -> do
    int getDeltaY() -> for
    int getDeltaX() -> if
    void setRampUpDuration(int) -> if
    int getHorizontalDirection() -> int
    int getVerticalDirection() -> new
    boolean isFinished() -> try
androidx.core.widget.AutoScrollHelper$ScrollAnimationRunnable -> androidx.core.widget.do$if:
    androidx.core.widget.AutoScrollHelper this$0 -> if
androidx.core.widget.AutoSizeableTextView -> androidx.core.widget.if:
    boolean PLATFORM_SUPPORTS_AUTOSIZE -> do
androidx.core.widget.CompoundButtonCompat -> androidx.core.widget.for:
    java.lang.reflect.Field sButtonDrawableField -> do
    boolean sButtonDrawableFieldFetched -> if
    android.graphics.drawable.Drawable getButtonDrawable(android.widget.CompoundButton) -> do
    void setButtonTintList(android.widget.CompoundButton,android.content.res.ColorStateList) -> do
    void setButtonTintMode(android.widget.CompoundButton,android.graphics.PorterDuff$Mode) -> do
    android.content.res.ColorStateList getButtonTintList(android.widget.CompoundButton) -> if
androidx.core.widget.EdgeEffectCompat -> androidx.core.widget.int:
    void onPull(android.widget.EdgeEffect,float,float) -> do
androidx.core.widget.ImageViewCompat -> androidx.core.widget.new:
    android.content.res.ColorStateList getImageTintList(android.widget.ImageView) -> do
    void setImageTintList(android.widget.ImageView,android.content.res.ColorStateList) -> do
    void setImageTintMode(android.widget.ImageView,android.graphics.PorterDuff$Mode) -> do
    android.graphics.PorterDuff$Mode getImageTintMode(android.widget.ImageView) -> if
androidx.core.widget.ListViewAutoScrollHelper -> androidx.core.widget.try:
    android.widget.ListView mTarget -> float
    boolean canTargetScrollHorizontally(int) -> do
    void scrollTargetBy(int,int) -> do
    boolean canTargetScrollVertically(int) -> if
androidx.core.widget.ListViewCompat -> androidx.core.widget.byte:
    void scrollListBy(android.widget.ListView,int) -> do
androidx.core.widget.NestedScrollView -> androidx.core.widget.NestedScrollView:
    boolean mIsLayoutDirty -> case
    android.widget.EdgeEffect mEdgeGlowBottom -> try
    float mVerticalScrollFactor -> import
    long mLastScroll -> if
    androidx.core.widget.NestedScrollView$OnScrollChangeListener mOnScrollChangeListener -> native
    android.widget.EdgeEffect mEdgeGlowTop -> new
    int[] SCROLLVIEW_STYLEABLE -> return
    androidx.core.view.NestedScrollingParentHelper mParentHelper -> while
    androidx.core.widget.NestedScrollView$AccessibilityDelegate ACCESSIBILITY_DELEGATE -> public
    boolean mSmoothScrollingEnabled -> void
    int[] mScrollConsumed -> float
    androidx.core.view.NestedScrollingChildHelper mChildHelper -> double
    boolean mIsBeingDragged -> goto
    int[] mScrollOffset -> final
    int mNestedYOffset -> short
    android.widget.OverScroller mScroller -> int
    int mTouchSlop -> break
    boolean mFillViewport -> this
    android.graphics.Rect mTempRect -> for
    int mMaximumVelocity -> class
    int mMinimumVelocity -> catch
    boolean mIsLaidOut -> char
    int mActivePointerId -> const
    android.view.View mChildToScrollTo -> else
    int mLastScrollerY -> super
    android.view.VelocityTracker mVelocityTracker -> long
    androidx.core.widget.NestedScrollView$SavedState mSavedState -> throw
    int mLastMotionY -> byte
    void doScrollY(int) -> byte
    void initVelocityTrackerIfNotExists() -> byte
    void recycleVelocityTracker() -> case
    void abortAnimatedScroll() -> do
    boolean arrowScroll(int) -> do
    int clamp(int,int,int) -> do
    int computeScrollDeltaToGetChildRectOnScreen(android.graphics.Rect) -> do
    boolean dispatchNestedPreScroll(int,int,int[],int[],int) -> do
    void dispatchNestedScroll(int,int,int,int,int[],int,int[]) -> do
    boolean executeKeyEvent(android.view.KeyEvent) -> do
    android.view.View findFocusableViewInBounds(boolean,int,int) -> do
    boolean isOffScreen(android.view.View) -> do
    boolean isViewDescendantOf(android.view.View,android.view.View) -> do
    boolean isWithinDeltaOfScreen(android.view.View,int,int) -> do
    void onNestedPreScroll(android.view.View,int,int,int[],int) -> do
    void onNestedScroll(android.view.View,int,int,int,int,int) -> do
    void onNestedScroll(android.view.View,int,int,int,int,int,int[]) -> do
    void onNestedScrollAccepted(android.view.View,android.view.View,int,int) -> do
    void onNestedScrollInternal(int,int,int[]) -> do
    void onSecondaryPointerUp(android.view.MotionEvent) -> do
    void onStopNestedScroll(android.view.View,int) -> do
    boolean overScrollByCompat(int,int,int,int,int,int,int,int,boolean) -> do
    void runAnimatedScroll(boolean) -> do
    boolean scrollToChildRect(android.graphics.Rect,boolean) -> do
    void smoothScrollBy(int,int) -> do
    void endDrag() -> for
    boolean fullScroll(int) -> for
    boolean startNestedScroll(int,int) -> for
    boolean canScroll() -> if
    void fling(int) -> if
    boolean onStartNestedScroll(android.view.View,android.view.View,int,int) -> if
    boolean scrollAndFocus(int,int,int) -> if
    void scrollToChild(android.view.View) -> if
    void smoothScrollTo(int,int) -> if
    void ensureGlows() -> int
    boolean hasNestedScrollingParent(int) -> int
    boolean inChild(int,int) -> int
    void initOrResetVelocityTracker() -> new
    boolean pageScroll(int) -> new
    void initScrollView() -> try
    void stopNestedScroll(int) -> try
androidx.core.widget.NestedScrollView$AccessibilityDelegate -> androidx.core.widget.NestedScrollView$do:
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> do
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> if
androidx.core.widget.NestedScrollView$OnScrollChangeListener -> androidx.core.widget.NestedScrollView$if:
    void onScrollChange(androidx.core.widget.NestedScrollView,int,int,int,int) -> do
androidx.core.widget.NestedScrollView$SavedState -> androidx.core.widget.NestedScrollView$for:
    int scrollPosition -> if
androidx.core.widget.NestedScrollView$SavedState$1 -> androidx.core.widget.NestedScrollView$for$do:
androidx.core.widget.PopupWindowCompat -> androidx.core.widget.case:
    java.lang.reflect.Field sOverlapAnchorField -> for
    boolean sOverlapAnchorFieldAttempted -> int
    boolean sSetWindowLayoutTypeMethodAttempted -> if
    java.lang.reflect.Method sSetWindowLayoutTypeMethod -> do
    void setOverlapAnchor(android.widget.PopupWindow,boolean) -> do
    void setWindowLayoutType(android.widget.PopupWindow,int) -> do
    void showAsDropDown(android.widget.PopupWindow,android.view.View,int,int,int) -> do
androidx.core.widget.TextViewCompat -> androidx.core.widget.char:
    android.graphics.drawable.Drawable[] getCompoundDrawablesRelative(android.widget.TextView) -> do
    int getTextDirection(android.text.TextDirectionHeuristic) -> do
    void setCompoundDrawableTintList(android.widget.TextView,android.content.res.ColorStateList) -> do
    void setCompoundDrawableTintMode(android.widget.TextView,android.graphics.PorterDuff$Mode) -> do
    void setCompoundDrawablesRelative(android.widget.TextView,android.graphics.drawable.Drawable,android.graphics.drawable.Drawable,android.graphics.drawable.Drawable,android.graphics.drawable.Drawable) -> do
    void setFirstBaselineToTopHeight(android.widget.TextView,int) -> do
    void setPrecomputedText(android.widget.TextView,androidx.core.text.PrecomputedTextCompat) -> do
    void setTextMetricsParams(android.widget.TextView,androidx.core.text.PrecomputedTextCompat$Params) -> do
    android.view.ActionMode$Callback wrapCustomSelectionActionModeCallback(android.widget.TextView,android.view.ActionMode$Callback) -> do
    int getLastBaselineToBottomHeight(android.widget.TextView) -> for
    void setLineHeight(android.widget.TextView,int) -> for
    int getFirstBaselineToTopHeight(android.widget.TextView) -> if
    void setLastBaselineToBottomHeight(android.widget.TextView,int) -> if
    android.text.TextDirectionHeuristic getTextDirectionHeuristic(android.widget.TextView) -> int
    void setTextAppearance(android.widget.TextView,int) -> int
    androidx.core.text.PrecomputedTextCompat$Params getTextMetricsParams(android.widget.TextView) -> new
androidx.core.widget.TextViewCompat$OreoCallback -> androidx.core.widget.char$do:
    android.view.ActionMode$Callback mCallback -> do
    java.lang.Class mMenuBuilderClass -> for
    boolean mCanUseMenuBuilderReferences -> new
    java.lang.reflect.Method mMenuBuilderRemoveItemAtMethod -> int
    boolean mInitializedMenuBuilderReferences -> try
    android.widget.TextView mTextView -> if
    android.content.Intent createProcessTextIntent() -> do
    android.content.Intent createProcessTextIntentForResolveInfo(android.content.pm.ResolveInfo,android.widget.TextView) -> do
    java.util.List getSupportedActivities(android.content.Context,android.content.pm.PackageManager) -> do
    boolean isEditable(android.widget.TextView) -> do
    boolean isSupportedActivity(android.content.pm.ResolveInfo,android.content.Context) -> do
    void recomputeProcessTextMenuItems(android.view.Menu) -> do
androidx.core.widget.TintableCompoundButton -> androidx.core.widget.else:
androidx.core.widget.TintableCompoundDrawablesView -> androidx.core.widget.goto:
androidx.core.widget.TintableImageSourceView -> androidx.core.widget.long:
androidx.cursoradapter.widget.CursorAdapter -> if.byte.do.do:
    androidx.cursoradapter.widget.CursorFilter mCursorFilter -> char
    android.database.DataSetObserver mDataSetObserver -> case
    boolean mAutoRequery -> for
    android.content.Context mContext -> new
    boolean mDataValid -> if
    int mRowIDColumn -> try
    android.database.Cursor mCursor -> int
    androidx.cursoradapter.widget.CursorAdapter$ChangeObserver mChangeObserver -> byte
    void bindView(android.view.View,android.content.Context,android.database.Cursor) -> do
    java.lang.CharSequence convertToString(android.database.Cursor) -> do
    android.database.Cursor getCursor() -> do
    void init(android.content.Context,android.database.Cursor,int) -> do
    android.view.View newDropDownView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> do
    android.database.Cursor swapCursor(android.database.Cursor) -> for
    void changeCursor(android.database.Cursor) -> if
    android.view.View newView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> if
    void onContentChanged() -> if
androidx.cursoradapter.widget.CursorAdapter$ChangeObserver -> if.byte.do.do$do:
    androidx.cursoradapter.widget.CursorAdapter this$0 -> do
androidx.cursoradapter.widget.CursorAdapter$MyDataSetObserver -> if.byte.do.do$if:
    androidx.cursoradapter.widget.CursorAdapter this$0 -> do
androidx.cursoradapter.widget.CursorFilter -> if.byte.do.if:
    androidx.cursoradapter.widget.CursorFilter$CursorFilterClient mClient -> do
androidx.cursoradapter.widget.CursorFilter$CursorFilterClient -> if.byte.do.if$do:
    java.lang.CharSequence convertToString(android.database.Cursor) -> do
    android.database.Cursor getCursor() -> do
    android.database.Cursor runQueryOnBackgroundThread(java.lang.CharSequence) -> do
    void changeCursor(android.database.Cursor) -> if
androidx.cursoradapter.widget.ResourceCursorAdapter -> if.byte.do.for:
    int mLayout -> else
    android.view.LayoutInflater mInflater -> long
    int mDropDownLayout -> goto
    android.view.View newDropDownView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> do
    android.view.View newView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> if
androidx.customview.view.AbsSavedState -> if.case.do.do:
    androidx.customview.view.AbsSavedState EMPTY_STATE -> for
    android.os.Parcelable mSuperState -> if
    android.os.Parcelable getSuperState() -> int
androidx.customview.view.AbsSavedState$1 -> if.case.do.do$do:
androidx.customview.view.AbsSavedState$2 -> if.case.do.do$if:
androidx.customview.widget.ExploreByTouchHelper -> if.case.if.do:
    android.view.View mHost -> char
    androidx.customview.widget.FocusStrategy$CollectionAdapter SPARSE_VALUES_ADAPTER -> catch
    android.graphics.Rect mTempScreenRect -> int
    int mHoveredVirtualViewId -> this
    android.view.accessibility.AccessibilityManager mManager -> case
    android.graphics.Rect INVALID_PARENT_BOUNDS -> void
    int mAccessibilityFocusedVirtualViewId -> goto
    int[] mTempGlobalRect -> byte
    android.graphics.Rect mTempVisibleRect -> try
    android.graphics.Rect mTempParentRect -> new
    int mKeyboardFocusedVirtualViewId -> long
    androidx.customview.widget.FocusStrategy$BoundsAdapter NODE_ADAPTER -> break
    androidx.customview.widget.ExploreByTouchHelper$MyNodeProvider mNodeProvider -> else
    int keyToDirection(int) -> byte
    boolean requestAccessibilityFocus(int) -> case
    void updateHoveredVirtualView(int) -> char
    boolean clearKeyboardFocusForVirtualView(int) -> do
    boolean dispatchHoverEvent(android.view.MotionEvent) -> do
    boolean dispatchKeyEvent(android.view.KeyEvent) -> do
    androidx.core.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> do
    void getBoundsInParent(int,android.graphics.Rect) -> do
    int getVirtualViewAt(float,float) -> do
    void getVisibleVirtualViews(java.util.List) -> do
    android.graphics.Rect guessPreviouslyFocusedRect(android.view.View,int,android.graphics.Rect) -> do
    boolean isVisibleToUser(android.graphics.Rect) -> do
    void onFocusChanged(boolean,int,android.graphics.Rect) -> do
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean onPerformActionForVirtualView(int,int,android.os.Bundle) -> do
    void onPopulateEventForHost(android.view.accessibility.AccessibilityEvent) -> do
    void onPopulateEventForVirtualView(int,android.view.accessibility.AccessibilityEvent) -> do
    void onPopulateNodeForHost(androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onPopulateNodeForVirtualView(int,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onVirtualViewKeyboardFocusChanged(int,boolean) -> do
    boolean performActionForHost(int,android.os.Bundle) -> do
    boolean sendEventForVirtualView(int,int) -> do
    android.view.accessibility.AccessibilityEvent createEventForChild(int,int) -> for
    int getKeyboardFocusedVirtualViewId() -> for
    boolean performActionForChild(int,int,android.os.Bundle) -> for
    boolean requestKeyboardFocusForVirtualView(int) -> for
    android.view.accessibility.AccessibilityEvent createEvent(int,int) -> if
    int getAccessibilityFocusedVirtualViewId() -> if
    boolean moveFocus(int,android.graphics.Rect) -> if
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat obtainAccessibilityNodeInfo(int) -> if
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> if
    boolean performAction(int,int,android.os.Bundle) -> if
    boolean clearAccessibilityFocus(int) -> int
    boolean clickKeyboardFocusedVirtualView() -> int
    android.view.accessibility.AccessibilityEvent createEventForHost(int) -> new
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat createNodeForHost() -> new
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat createNodeForChild(int) -> try
    androidx.collection.SparseArrayCompat getAllNodes() -> try
androidx.customview.widget.ExploreByTouchHelper$1 -> if.case.if.do$do:
    void obtainBounds(androidx.core.view.accessibility.AccessibilityNodeInfoCompat,android.graphics.Rect) -> do
    void obtainBounds(java.lang.Object,android.graphics.Rect) -> do
androidx.customview.widget.ExploreByTouchHelper$2 -> if.case.if.do$if:
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat get(androidx.collection.SparseArrayCompat,int) -> do
    java.lang.Object get(java.lang.Object,int) -> do
    int size(androidx.collection.SparseArrayCompat) -> do
    int size(java.lang.Object) -> do
androidx.customview.widget.ExploreByTouchHelper$MyNodeProvider -> if.case.if.do$for:
    androidx.customview.widget.ExploreByTouchHelper this$0 -> if
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat createAccessibilityNodeInfo(int) -> do
    boolean performAction(int,int,android.os.Bundle) -> do
    androidx.core.view.accessibility.AccessibilityNodeInfoCompat findFocus(int) -> if
androidx.customview.widget.FocusStrategy -> if.case.if.if:
    int minorAxisDistance(int,android.graphics.Rect,android.graphics.Rect) -> byte
    boolean beamBeats(int,android.graphics.Rect,android.graphics.Rect,android.graphics.Rect) -> do
    boolean beamsOverlap(int,android.graphics.Rect,android.graphics.Rect) -> do
    java.lang.Object findNextFocusInAbsoluteDirection(java.lang.Object,androidx.customview.widget.FocusStrategy$CollectionAdapter,androidx.customview.widget.FocusStrategy$BoundsAdapter,java.lang.Object,android.graphics.Rect,int) -> do
    java.lang.Object findNextFocusInRelativeDirection(java.lang.Object,androidx.customview.widget.FocusStrategy$CollectionAdapter,androidx.customview.widget.FocusStrategy$BoundsAdapter,java.lang.Object,int,boolean,boolean) -> do
    java.lang.Object getNextFocusable(java.lang.Object,java.util.ArrayList,boolean) -> do
    int getWeightedDistanceFor(int,int) -> do
    boolean isCandidate(android.graphics.Rect,android.graphics.Rect,int) -> do
    int majorAxisDistance(int,android.graphics.Rect,android.graphics.Rect) -> for
    java.lang.Object getPreviousFocusable(java.lang.Object,java.util.ArrayList,boolean) -> if
    boolean isBetterCandidate(int,android.graphics.Rect,android.graphics.Rect,android.graphics.Rect) -> if
    boolean isToDirectionOf(int,android.graphics.Rect,android.graphics.Rect) -> if
    int majorAxisDistanceRaw(int,android.graphics.Rect,android.graphics.Rect) -> int
    int majorAxisDistanceToFarEdge(int,android.graphics.Rect,android.graphics.Rect) -> new
    int majorAxisDistanceToFarEdgeRaw(int,android.graphics.Rect,android.graphics.Rect) -> try
androidx.customview.widget.FocusStrategy$BoundsAdapter -> if.case.if.if$do:
    void obtainBounds(java.lang.Object,android.graphics.Rect) -> do
androidx.customview.widget.FocusStrategy$CollectionAdapter -> if.case.if.if$if:
    java.lang.Object get(java.lang.Object,int) -> do
    int size(java.lang.Object) -> do
androidx.customview.widget.FocusStrategy$SequentialComparator -> if.case.if.if$for:
    android.graphics.Rect mTemp1 -> if
    boolean mIsLayoutRtl -> int
    android.graphics.Rect mTemp2 -> for
    androidx.customview.widget.FocusStrategy$BoundsAdapter mAdapter -> new
androidx.customview.widget.ViewDragHelper -> if.case.if.for:
    int mEdgeSize -> break
    boolean mReleaseInProgress -> float
    float[] mLastMotionX -> try
    int[] mEdgeDragsInProgress -> char
    int[] mEdgeDragsLocked -> else
    android.view.View mCapturedView -> final
    int mDragState -> do
    java.lang.Runnable mSetIdleRunnable -> super
    android.widget.OverScroller mScroller -> class
    android.view.animation.Interpolator sInterpolator -> throw
    int mTrackingEdges -> catch
    float mMinVelocity -> void
    float[] mInitialMotionX -> int
    int mPointersDown -> goto
    int mTouchSlop -> if
    android.view.VelocityTracker mVelocityTracker -> long
    int mActivePointerId -> for
    float[] mLastMotionY -> byte
    float[] mInitialMotionY -> new
    int[] mInitialEdgesTouched -> case
    float mMaxVelocity -> this
    android.view.ViewGroup mParentView -> short
    androidx.customview.widget.ViewDragHelper$Callback mCallback -> const
    boolean isValidPointerForActionMove(int) -> byte
    void releaseViewForPointerUp() -> byte
    void cancel() -> do
    void captureChildView(android.view.View,int) -> do
    boolean checkNewEdgeDrag(float,float,int,int) -> do
    boolean checkTouchSlop(int) -> do
    boolean checkTouchSlop(int,int) -> do
    boolean checkTouchSlop(android.view.View,float,float) -> do
    float clampMag(float,float,float) -> do
    int clampMag(int,int,int) -> do
    int computeSettleDuration(android.view.View,int,int,int,int) -> do
    boolean continueSettling(boolean) -> do
    androidx.customview.widget.ViewDragHelper create(android.view.ViewGroup,float,androidx.customview.widget.ViewDragHelper$Callback) -> do
    androidx.customview.widget.ViewDragHelper create(android.view.ViewGroup,androidx.customview.widget.ViewDragHelper$Callback) -> do
    void dispatchViewReleased(float,float) -> do
    void dragTo(int,int,int,int) -> do
    boolean isViewUnder(android.view.View,int,int) -> do
    void processTouchEvent(android.view.MotionEvent) -> do
    void reportNewEdgeDrags(float,float,int) -> do
    void setMinVelocity(float) -> do
    int getEdgeSize() -> for
    boolean isCapturedViewUnder(int,int) -> for
    void saveLastMotion(android.view.MotionEvent) -> for
    void setDragState(int) -> for
    int computeAxisDuration(int,int,int) -> if
    float distanceInfluenceForSnapDuration(float) -> if
    android.view.View findTopChildUnder(int,int) -> if
    boolean forceSettleCapturedViewAt(int,int,int,int) -> if
    android.view.View getCapturedView() -> if
    boolean isPointerDown(int) -> if
    void saveInitialMotion(float,float,int) -> if
    boolean shouldInterceptTouchEvent(android.view.MotionEvent) -> if
    boolean smoothSlideViewTo(android.view.View,int,int) -> if
    boolean tryCaptureViewForDrag(android.view.View,int) -> if
    int getTouchSlop() -> int
    void setEdgeTrackingEnabled(int) -> int
    boolean settleCapturedViewAt(int,int) -> int
    void clearMotionHistory(int) -> new
    int getEdgesTouched(int,int) -> new
    int getViewDragState() -> new
    void clearMotionHistory() -> try
    void ensureMotionHistorySizeForId(int) -> try
androidx.customview.widget.ViewDragHelper$1 -> if.case.if.for$do:
androidx.customview.widget.ViewDragHelper$2 -> if.case.if.for$if:
    androidx.customview.widget.ViewDragHelper this$0 -> if
androidx.customview.widget.ViewDragHelper$Callback -> if.case.if.for$for:
    int clampViewPositionHorizontal(android.view.View,int,int) -> do
    int getOrderedChildIndex(int) -> do
    int getViewHorizontalDragRange(android.view.View) -> do
    void onEdgeDragStarted(int,int) -> do
    void onViewCaptured(android.view.View,int) -> do
    void onViewPositionChanged(android.view.View,int,int,int,int) -> do
    void onViewReleased(android.view.View,float,float) -> do
    void onViewDragStateChanged(int) -> for
    int clampViewPositionVertical(android.view.View,int,int) -> if
    int getViewVerticalDragRange(android.view.View) -> if
    boolean onEdgeLock(int) -> if
    void onEdgeTouched(int,int) -> if
    boolean tryCaptureView(android.view.View,int) -> if
androidx.drawerlayout.widget.DrawerLayout -> androidx.drawerlayout.widget.DrawerLayout:
    int[] LAYOUT_ATTRS -> abstract
    java.lang.Object mLastInsets -> return
    float mScrimOpacity -> try
    float mInitialMotionY -> throw
    android.graphics.drawable.Drawable mShadowRight -> default
    androidx.customview.widget.ViewDragHelper mRightDragger -> char
    boolean SET_DRAWER_SHADOW_FROM_ELEVATION -> strictfp
    android.graphics.Rect mChildHitRect -> finally
    android.graphics.drawable.Drawable mShadowRightResolved -> import
    android.graphics.drawable.Drawable mShadowEnd -> throws
    java.util.ArrayList mNonDrawerViews -> extends
    int mMinDrawerMargin -> int
    androidx.customview.widget.ViewDragHelper mLeftDragger -> case
    int mDrawerState -> long
    android.graphics.drawable.Drawable mShadowStart -> switch
    boolean mChildrenCanceledTouch -> final
    boolean mFirstLayout -> void
    androidx.drawerlayout.widget.DrawerLayout$ChildAccessibilityDelegate mChildAccessibilityDelegate -> if
    int mLockModeLeft -> break
    androidx.drawerlayout.widget.DrawerLayout$ViewDragCallback mRightCallback -> goto
    java.lang.CharSequence mTitleLeft -> native
    boolean mInLayout -> this
    android.graphics.Matrix mChildInvertedMatrix -> package
    int mLockModeStart -> class
    android.graphics.drawable.Drawable mShadowLeftResolved -> double
    int mLockModeRight -> catch
    java.lang.CharSequence mTitleRight -> public
    android.graphics.Paint mScrimPaint -> byte
    int mLockModeEnd -> const
    boolean CAN_HIDE_DESCENDANTS -> continue
    int[] THEME_ATTRS -> private
    float mDrawerElevation -> for
    float mInitialMotionX -> super
    java.util.List mListeners -> short
    androidx.drawerlayout.widget.DrawerLayout$DrawerListener mListener -> float
    int mScrimColor -> new
    android.graphics.drawable.Drawable mStatusBarBackground -> while
    android.graphics.drawable.Drawable mShadowLeft -> boolean
    androidx.drawerlayout.widget.DrawerLayout$ViewDragCallback mLeftCallback -> else
    boolean mDrawStatusBarBackground -> static
    boolean isContentView(android.view.View) -> byte
    void openDrawer(int) -> byte
    android.graphics.drawable.Drawable resolveLeftShadow() -> byte
    java.lang.String gravityToString(int) -> case
    boolean isDrawerOpen(android.view.View) -> case
    android.graphics.drawable.Drawable resolveRightShadow() -> case
    boolean isDrawerView(android.view.View) -> char
    void resolveShadowDrawables() -> char
    void addDrawerListener(androidx.drawerlayout.widget.DrawerLayout$DrawerListener) -> do
    void cancelChildViewTouch() -> do
    boolean checkDrawerViewAbsoluteGravity(android.view.View,int) -> do
    void closeDrawer(int) -> do
    void closeDrawer(int,boolean) -> do
    void closeDrawer(android.view.View) -> do
    void closeDrawer(android.view.View,boolean) -> do
    void closeDrawers(boolean) -> do
    void dispatchOnDrawerSlide(android.view.View,float) -> do
    boolean dispatchTransformedGenericPointerEvent(android.view.MotionEvent,android.view.View) -> do
    boolean isInBoundsOfChild(float,float,android.view.View) -> do
    boolean mirror(android.graphics.drawable.Drawable,int) -> do
    void setChildInsets(java.lang.Object,boolean) -> do
    void setDrawerLockMode(int,int) -> do
    void updateDrawerState(int,int,android.view.View) -> do
    boolean isDrawerVisible(android.view.View) -> else
    void dispatchOnDrawerOpened(android.view.View) -> for
    android.view.View findOpenDrawer() -> for
    int getDrawerLockMode(int) -> for
    void setDrawerViewOffset(android.view.View,float) -> for
    void updateChildrenImportantForAccessibility(android.view.View,boolean) -> for
    void openDrawer(android.view.View) -> goto
    void closeDrawers() -> if
    void dispatchOnDrawerClosed(android.view.View) -> if
    android.view.View findDrawerWithGravity(int) -> if
    android.view.MotionEvent getTransformedMotionEvent(android.view.MotionEvent,android.view.View) -> if
    void moveDrawerToOffset(android.view.View,float) -> if
    void openDrawer(int,boolean) -> if
    void openDrawer(android.view.View,boolean) -> if
    void removeDrawerListener(androidx.drawerlayout.widget.DrawerLayout$DrawerListener) -> if
    android.view.View findVisibleDrawer() -> int
    int getDrawerLockMode(android.view.View) -> int
    java.lang.CharSequence getDrawerTitle(int) -> int
    boolean hasOpaqueBackground(android.view.View) -> long
    int getDrawerViewAbsoluteGravity(android.view.View) -> new
    boolean hasPeekingDrawer() -> new
    boolean isDrawerOpen(int) -> new
    boolean includeChildForAccessibility(android.view.View) -> this
    float getDrawerViewOffset(android.view.View) -> try
    boolean hasVisibleDrawer() -> try
    boolean isDrawerVisible(int) -> try
androidx.drawerlayout.widget.DrawerLayout$1 -> androidx.drawerlayout.widget.DrawerLayout$do:
androidx.drawerlayout.widget.DrawerLayout$AccessibilityDelegate -> androidx.drawerlayout.widget.DrawerLayout$if:
    android.graphics.Rect mTmpRect -> int
    androidx.drawerlayout.widget.DrawerLayout this$0 -> new
    void addChildrenForAccessibility(androidx.core.view.accessibility.AccessibilityNodeInfoCompat,android.view.ViewGroup) -> do
    void copyNodeInfoNoChildren(androidx.core.view.accessibility.AccessibilityNodeInfoCompat,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> do
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> do
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> if
androidx.drawerlayout.widget.DrawerLayout$ChildAccessibilityDelegate -> androidx.drawerlayout.widget.DrawerLayout$for:
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
androidx.drawerlayout.widget.DrawerLayout$DrawerListener -> androidx.drawerlayout.widget.DrawerLayout$int:
    void onDrawerOpened(android.view.View) -> do
    void onDrawerSlide(android.view.View,float) -> do
    void onDrawerStateChanged(int) -> do
    void onDrawerClosed(android.view.View) -> if
androidx.drawerlayout.widget.DrawerLayout$LayoutParams -> androidx.drawerlayout.widget.DrawerLayout$new:
    int openState -> int
    boolean isPeeking -> for
    int gravity -> do
    float onScreen -> if
androidx.drawerlayout.widget.DrawerLayout$SavedState -> androidx.drawerlayout.widget.DrawerLayout$try:
    int openDrawerGravity -> int
    int lockModeStart -> byte
    int lockModeLeft -> new
    int lockModeRight -> try
    int lockModeEnd -> case
androidx.drawerlayout.widget.DrawerLayout$SavedState$1 -> androidx.drawerlayout.widget.DrawerLayout$try$do:
androidx.drawerlayout.widget.DrawerLayout$ViewDragCallback -> androidx.drawerlayout.widget.DrawerLayout$byte:
    java.lang.Runnable mPeekRunnable -> for
    int mAbsGravity -> do
    androidx.customview.widget.ViewDragHelper mDragger -> if
    androidx.drawerlayout.widget.DrawerLayout this$0 -> int
    int clampViewPositionHorizontal(android.view.View,int,int) -> do
    int getViewHorizontalDragRange(android.view.View) -> do
    void onEdgeDragStarted(int,int) -> do
    void onViewCaptured(android.view.View,int) -> do
    void onViewPositionChanged(android.view.View,int,int,int,int) -> do
    void onViewReleased(android.view.View,float,float) -> do
    void peekDrawer() -> do
    void setDragger(androidx.customview.widget.ViewDragHelper) -> do
    void closeOtherDrawer() -> for
    void onViewDragStateChanged(int) -> for
    int clampViewPositionVertical(android.view.View,int,int) -> if
    boolean onEdgeLock(int) -> if
    void onEdgeTouched(int,int) -> if
    void removeCallbacks() -> if
    boolean tryCaptureView(android.view.View,int) -> if
androidx.drawerlayout.widget.DrawerLayout$ViewDragCallback$1 -> androidx.drawerlayout.widget.DrawerLayout$byte$do:
    androidx.drawerlayout.widget.DrawerLayout$ViewDragCallback this$1 -> if
androidx.fragment.app.BackStackRecord -> androidx.fragment.app.do:
    androidx.fragment.app.FragmentManagerImpl mManager -> const
    boolean mCommitted -> final
    int mIndex -> float
    void bumpBackStackNesting(int) -> do
    int commit() -> do
    int commitInternal(boolean) -> do
    void doAddOp(int,androidx.fragment.app.Fragment,java.lang.String,int) -> do
    void dump(java.lang.String,java.io.PrintWriter) -> do
    void dump(java.lang.String,java.io.PrintWriter,boolean) -> do
    androidx.fragment.app.Fragment expandOps(java.util.ArrayList,androidx.fragment.app.Fragment) -> do
    boolean generateOps(java.util.ArrayList,java.util.ArrayList) -> do
    boolean interactsWith(java.util.ArrayList,int,int) -> do
    void setOnStartPostponedListener(androidx.fragment.app.Fragment$OnStartEnterTransitionListener) -> do
    java.lang.String getName() -> for
    void executeOps() -> if
    void executePopOps(boolean) -> if
    boolean interactsWith(int) -> if
    boolean isFragmentPostponed(androidx.fragment.app.FragmentTransaction$Op) -> if
    androidx.fragment.app.Fragment trackAddedFragmentsInPop(java.util.ArrayList,androidx.fragment.app.Fragment) -> if
    boolean isPostponed() -> int
    void runOnCommitRunnables() -> new
androidx.fragment.app.BackStackState -> androidx.fragment.app.if:
    java.util.ArrayList mFragmentWhos -> for
    java.lang.CharSequence mBreadCrumbTitleText -> goto
    int[] mOps -> if
    java.util.ArrayList mSharedElementSourceNames -> void
    java.lang.String mName -> case
    int mTransition -> try
    int[] mOldMaxLifecycleStates -> int
    java.lang.CharSequence mBreadCrumbShortTitleText -> this
    java.util.ArrayList mSharedElementTargetNames -> break
    int mBreadCrumbShortTitleRes -> long
    int mBreadCrumbTitleRes -> else
    boolean mReorderingAllowed -> catch
    int mTransitionStyle -> byte
    int mIndex -> char
    int[] mCurrentMaxLifecycleStates -> new
    androidx.fragment.app.BackStackRecord instantiate(androidx.fragment.app.FragmentManagerImpl) -> do
androidx.fragment.app.BackStackState$1 -> androidx.fragment.app.if$do:
androidx.fragment.app.DialogFragment -> androidx.fragment.app.for:
androidx.fragment.app.Fragment -> androidx.fragment.app.Fragment:
    java.lang.String mTag -> double
    boolean mInLayout -> break
    boolean mIsNewlyAdded -> abstract
    androidx.fragment.app.Fragment mParentFragment -> super
    boolean mHidden -> import
    boolean mRetainInstance -> public
    boolean mDetached -> native
    android.view.View mView -> default
    int mTargetRequestCode -> else
    boolean mRestored -> catch
    int mContentLayoutId -> ʻ
    boolean mFromLayout -> void
    androidx.fragment.app.FragmentManagerImpl mChildFragmentManager -> short
    android.view.View mInnerView -> extends
    float mPostponedAlpha -> strictfp
    boolean mIsCreated -> interface
    boolean mMenuVisible -> switch
    int mContainerId -> while
    boolean mRemoving -> this
    int mFragmentId -> throw
    boolean mRetainInstanceChangedWhileDetached -> return
    java.lang.String mTargetWho -> char
    boolean mAdded -> long
    int mBackStackNesting -> const
    boolean mHiddenChanged -> continue
    android.view.ViewGroup mContainer -> boolean
    java.lang.Boolean mIsPrimaryNavigationFragment -> goto
    boolean mHasMenu -> static
    java.lang.Object USE_DEFAULT_TRANSITION -> ʼ
    androidx.fragment.app.FragmentManagerImpl mFragmentManager -> final
    boolean mUserVisibleHint -> package
    androidx.savedstate.SavedStateRegistryController mSavedStateRegistryController -> synchronized
    boolean mDeferStart -> finally
    androidx.fragment.app.Fragment mTarget -> case
    androidx.fragment.app.FragmentHostCallback mHost -> float
    android.util.SparseArray mSavedViewState -> int
    android.os.Bundle mSavedFragmentState -> for
    boolean mPerformedCreateView -> class
    boolean mCalled -> throws
    androidx.lifecycle.LifecycleRegistry mLifecycleRegistry -> transient
    android.view.LayoutInflater mLayoutInflater -> volatile
    android.os.Bundle mArguments -> byte
    androidx.fragment.app.FragmentViewLifecycleOwner mViewLifecycleOwner -> implements
    androidx.lifecycle.MutableLiveData mViewLifecycleOwnerLiveData -> instanceof
    androidx.lifecycle.Lifecycle$State mMaxState -> protected
    int mState -> if
    java.lang.Boolean mSavedUserVisibleHint -> new
    androidx.fragment.app.Fragment$AnimationInfo mAnimationInfo -> private
    java.lang.String mWho -> try
    boolean isPostponed() -> abstract
    android.view.View getView() -> boolean
    androidx.core.app.SharedElementCallback getEnterTransitionCallback() -> break
    boolean getAllowEnterTransitionOverlap() -> byte
    void performActivityCreated(android.os.Bundle) -> byte
    void setHasOptionsMenu(boolean) -> byte
    boolean getAllowReturnTransitionOverlap() -> case
    void performCreate(android.os.Bundle) -> case
    void setHideReplaced(boolean) -> case
    java.lang.Object getExitTransition() -> catch
    android.view.View getAnimatingAway() -> char
    android.view.LayoutInflater performGetLayoutInflater(android.os.Bundle) -> char
    androidx.core.app.SharedElementCallback getExitTransitionCallback() -> class
    androidx.fragment.app.FragmentManager getFragmentManager() -> const
    boolean isStateSaved() -> continue
    void initState() -> default
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    androidx.fragment.app.Fragment findFragmentByWho(java.lang.String) -> do
    android.view.LayoutInflater getLayoutInflater(android.os.Bundle) -> do
    androidx.lifecycle.Lifecycle getLifecycle() -> do
    java.lang.String getString(int) -> do
    java.lang.String getString(int,java.lang.Object[]) -> do
    androidx.fragment.app.Fragment instantiate(android.content.Context,java.lang.String,android.os.Bundle) -> do
    void onActivityResult(int,int,android.content.Intent) -> do
    void onAttach(android.app.Activity) -> do
    void onAttach(android.content.Context) -> do
    void onAttachFragment(androidx.fragment.app.Fragment) -> do
    boolean onContextItemSelected(android.view.MenuItem) -> do
    android.view.animation.Animation onCreateAnimation(int,boolean,int) -> do
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> do
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> do
    void onHiddenChanged(boolean) -> do
    void onInflate(android.app.Activity,android.util.AttributeSet,android.os.Bundle) -> do
    void onInflate(android.content.Context,android.util.AttributeSet,android.os.Bundle) -> do
    void onOptionsMenuClosed(android.view.Menu) -> do
    void onRequestPermissionsResult(int,java.lang.String[],int[]) -> do
    void onViewCreated(android.view.View,android.os.Bundle) -> do
    void performConfigurationChanged(android.content.res.Configuration) -> do
    void setAnimatingAway(android.view.View) -> do
    void setAnimator(android.animation.Animator) -> do
    void setNextTransition(int,int) -> do
    void setOnStartEnterTransitionListener(androidx.fragment.app.Fragment$OnStartEnterTransitionListener) -> do
    void startActivity(android.content.Intent) -> do
    void startActivity(android.content.Intent,android.os.Bundle) -> do
    java.lang.Object getReenterTransition() -> double
    android.animation.Animator getAnimator() -> else
    void performSaveInstanceState(android.os.Bundle) -> else
    boolean isAdded() -> extends
    java.lang.Object getHost() -> final
    boolean isHidden() -> finally
    int getId() -> float
    androidx.savedstate.SavedStateRegistry getSavedStateRegistry() -> for
    void onCreate(android.os.Bundle) -> for
    void onPictureInPictureModeChanged(boolean) -> for
    boolean performContextItemSelected(android.view.MenuItem) -> for
    void performOptionsMenuClosed(android.view.Menu) -> for
    void setStateAfterAnimating(int) -> for
    android.os.Bundle getArguments() -> goto
    void restoreChildFragmentState(android.os.Bundle) -> goto
    void onActivityCreated(android.os.Bundle) -> if
    android.animation.Animator onCreateAnimator(int,boolean,int) -> if
    void onMultiWindowModeChanged(boolean) -> if
    boolean onOptionsItemSelected(android.view.MenuItem) -> if
    void onPrepareOptionsMenu(android.view.Menu) -> if
    boolean performCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> if
    void performCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> if
    void setNextAnim(int) -> if
    void onPause() -> implements
    android.content.res.Resources getResources() -> import
    void onResume() -> instanceof
    void callStartTransitionListener() -> int
    android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle) -> int
    void onPrimaryNavigationFragmentChanged(boolean) -> int
    boolean performOptionsItemSelected(android.view.MenuItem) -> int
    boolean performPrepareOptionsMenu(android.view.Menu) -> int
    void onDestroyOptionsMenu() -> interface
    androidx.fragment.app.FragmentManager getChildFragmentManager() -> long
    void restoreViewState(android.os.Bundle) -> long
    boolean getRetainInstance() -> native
    androidx.lifecycle.ViewModelStore getViewModelStore() -> new
    void onSaveInstanceState(android.os.Bundle) -> new
    void performMultiWindowModeChanged(boolean) -> new
    boolean isHideReplaced() -> package
    boolean isInBackStack() -> private
    void onDestroyView() -> protected
    java.lang.Object getReturnTransition() -> public
    java.lang.Object getSharedElementEnterTransition() -> return
    int getNextAnim() -> short
    java.lang.Object getSharedElementReturnTransition() -> static
    void noteStateNotSaved() -> strictfp
    int getNextTransition() -> super
    int getStateAfterAnimating() -> switch
    void onStart() -> synchronized
    android.content.Context getContext() -> this
    void setArguments(android.os.Bundle) -> this
    int getNextTransitionStyle() -> throw
    androidx.fragment.app.Fragment getTargetFragment() -> throws
    void onDetach() -> transient
    androidx.fragment.app.FragmentActivity getActivity() -> try
    void onViewStateRestored(android.os.Bundle) -> try
    void performPictureInPictureModeChanged(boolean) -> try
    java.lang.Object getEnterTransition() -> void
    void onDestroy() -> volatile
    androidx.fragment.app.Fragment getParentFragment() -> while
    void onStop() -> ʻ
    void performAttach() -> ʼ
    void performDestroy() -> ʽ
    void performDestroyView() -> ʾ
    void performDetach() -> ʿ
    void performLowMemory() -> ˆ
    void performPause() -> ˈ
    void performPrimaryNavigationFragmentChanged() -> ˉ
    void performResume() -> ˊ
    void performStart() -> ˋ
    void performStop() -> ˎ
    androidx.fragment.app.FragmentActivity requireActivity() -> ˏ
    android.content.Context requireContext() -> ˑ
    android.view.View requireView() -> י
    void startPostponedEnterTransition() -> ـ
    androidx.fragment.app.Fragment$AnimationInfo ensureAnimationInfo() -> ٴ
    void initLifecycle() -> ᐧ
androidx.fragment.app.Fragment$1 -> androidx.fragment.app.Fragment$do:
    androidx.fragment.app.Fragment this$0 -> if
androidx.fragment.app.Fragment$2 -> androidx.fragment.app.Fragment$2:
    androidx.fragment.app.Fragment this$0 -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.fragment.app.Fragment$3 -> androidx.fragment.app.Fragment$if:
    androidx.fragment.app.Fragment this$0 -> if
androidx.fragment.app.Fragment$4 -> androidx.fragment.app.Fragment$for:
    androidx.fragment.app.Fragment this$0 -> do
    android.view.View onFindViewById(int) -> do
    boolean onHasView() -> int
androidx.fragment.app.Fragment$AnimationInfo -> androidx.fragment.app.Fragment$int:
    java.lang.Boolean mAllowEnterTransitionOverlap -> void
    androidx.fragment.app.Fragment$OnStartEnterTransitionListener mStartEnterTransitionListener -> const
    androidx.core.app.SharedElementCallback mEnterTransitionCallback -> break
    androidx.core.app.SharedElementCallback mExitTransitionCallback -> catch
    java.lang.Object mReturnTransition -> case
    int mNextTransitionStyle -> try
    java.lang.Object mEnterTransition -> byte
    android.animation.Animator mAnimator -> if
    java.lang.Object mExitTransition -> char
    java.lang.Object mReenterTransition -> else
    int mNextAnim -> int
    android.view.View mAnimatingAway -> do
    java.lang.Boolean mAllowReturnTransitionOverlap -> this
    boolean mIsHideReplaced -> final
    int mStateAfterAnimating -> for
    java.lang.Object mSharedElementReturnTransition -> long
    java.lang.Object mSharedElementEnterTransition -> goto
    int mNextTransition -> new
    boolean mEnterTransitionPostponed -> class
androidx.fragment.app.Fragment$InstantiationException -> androidx.fragment.app.Fragment$new:
androidx.fragment.app.Fragment$OnStartEnterTransitionListener -> androidx.fragment.app.Fragment$try:
    void onStartEnterTransition() -> do
    void startListening() -> if
androidx.fragment.app.FragmentActivity -> androidx.fragment.app.int:
    boolean mCreated -> else
    int mNextCandidateRequestIndex -> break
    androidx.collection.SparseArrayCompat mPendingFragmentActivityResults -> catch
    boolean mStartedIntentSenderFromFragment -> this
    boolean mStartedActivityFromFragment -> void
    boolean mStopped -> long
    androidx.fragment.app.FragmentController mFragments -> case
    boolean mResumed -> goto
    androidx.lifecycle.LifecycleRegistry mFragmentLifecycleRegistry -> char
    androidx.fragment.app.FragmentManager getSupportFragmentManager() -> case
    void onResumeFragments() -> char
    void checkForValidRequestCode(int) -> do
    android.view.View dispatchFragmentsOnCreateView(android.view.View,java.lang.String,android.content.Context,android.util.AttributeSet) -> do
    boolean markState(androidx.fragment.app.FragmentManager,androidx.lifecycle.Lifecycle$State) -> do
    void onAttachFragment(androidx.fragment.app.Fragment) -> do
    boolean onPrepareOptionsPanel(android.view.View,android.view.Menu) -> do
    void startActivityFromFragment(androidx.fragment.app.Fragment,android.content.Intent,int,android.os.Bundle) -> do
    void supportInvalidateOptionsMenu() -> else
    void markFragmentsCreated() -> goto
    int allocateRequestIndex(androidx.fragment.app.Fragment) -> if
androidx.fragment.app.FragmentActivity$HostCallbacks -> androidx.fragment.app.int$do:
    androidx.fragment.app.FragmentActivity this$0 -> byte
    androidx.fragment.app.FragmentActivity onGetHost() -> char
    java.lang.Object onGetHost() -> char
    androidx.lifecycle.Lifecycle getLifecycle() -> do
    void onAttachFragment(androidx.fragment.app.Fragment) -> do
    void onDump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    android.view.View onFindViewById(int) -> do
    void onStartActivityFromFragment(androidx.fragment.app.Fragment,android.content.Intent,int,android.os.Bundle) -> do
    android.view.LayoutInflater onGetLayoutInflater() -> else
    int onGetWindowAnimations() -> goto
    androidx.activity.OnBackPressedDispatcher getOnBackPressedDispatcher() -> if
    boolean onShouldSaveFragmentState(androidx.fragment.app.Fragment) -> if
    boolean onHasView() -> int
    boolean onHasWindowAnimations() -> long
    androidx.lifecycle.ViewModelStore getViewModelStore() -> new
    void onSupportInvalidateOptionsMenu() -> this
androidx.fragment.app.FragmentContainer -> androidx.fragment.app.new:
    androidx.fragment.app.Fragment instantiate(android.content.Context,java.lang.String,android.os.Bundle) -> do
    android.view.View onFindViewById(int) -> do
    boolean onHasView() -> int
androidx.fragment.app.FragmentController -> androidx.fragment.app.try:
    androidx.fragment.app.FragmentHostCallback mHost -> do
    void dispatchStart() -> byte
    void dispatchStop() -> case
    boolean execPendingActions() -> char
    void attachHost(androidx.fragment.app.Fragment) -> do
    androidx.fragment.app.FragmentController createController(androidx.fragment.app.FragmentHostCallback) -> do
    void dispatchActivityCreated() -> do
    void dispatchConfigurationChanged(android.content.res.Configuration) -> do
    boolean dispatchContextItemSelected(android.view.MenuItem) -> do
    boolean dispatchCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> do
    void dispatchMultiWindowModeChanged(boolean) -> do
    void dispatchOptionsMenuClosed(android.view.Menu) -> do
    androidx.fragment.app.Fragment findFragmentByWho(java.lang.String) -> do
    android.view.View onCreateView(android.view.View,java.lang.String,android.content.Context,android.util.AttributeSet) -> do
    void restoreSaveState(android.os.Parcelable) -> do
    androidx.fragment.app.FragmentManager getSupportFragmentManager() -> else
    void dispatchDestroy() -> for
    void noteStateNotSaved() -> goto
    void dispatchCreate() -> if
    boolean dispatchOptionsItemSelected(android.view.MenuItem) -> if
    void dispatchPictureInPictureModeChanged(boolean) -> if
    boolean dispatchPrepareOptionsMenu(android.view.Menu) -> if
    void dispatchLowMemory() -> int
    android.os.Parcelable saveAllState() -> long
    void dispatchPause() -> new
    void dispatchResume() -> try
androidx.fragment.app.FragmentFactory -> androidx.fragment.app.byte:
    androidx.collection.SimpleArrayMap sClassMap -> do
    androidx.fragment.app.Fragment instantiate(java.lang.ClassLoader,java.lang.String) -> do
    java.lang.Class loadClass(java.lang.ClassLoader,java.lang.String) -> for
    boolean isFragmentClass(java.lang.ClassLoader,java.lang.String) -> if
    java.lang.Class loadFragmentClass(java.lang.ClassLoader,java.lang.String) -> int
androidx.fragment.app.FragmentHostCallback -> androidx.fragment.app.case:
    androidx.fragment.app.FragmentManagerImpl mFragmentManager -> try
    android.app.Activity mActivity -> if
    android.content.Context mContext -> for
    android.os.Handler mHandler -> int
    int mWindowAnimations -> new
    android.content.Context getContext() -> byte
    android.os.Handler getHandler() -> case
    java.lang.Object onGetHost() -> char
    void onAttachFragment(androidx.fragment.app.Fragment) -> do
    void onDump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    android.view.View onFindViewById(int) -> do
    void onStartActivityFromFragment(androidx.fragment.app.Fragment,android.content.Intent,int,android.os.Bundle) -> do
    android.view.LayoutInflater onGetLayoutInflater() -> else
    int onGetWindowAnimations() -> goto
    boolean onShouldSaveFragmentState(androidx.fragment.app.Fragment) -> if
    boolean onHasView() -> int
    boolean onHasWindowAnimations() -> long
    void onSupportInvalidateOptionsMenu() -> this
    android.app.Activity getActivity() -> try
androidx.fragment.app.FragmentManager -> androidx.fragment.app.char:
    androidx.fragment.app.FragmentFactory DEFAULT_FACTORY -> for
    androidx.fragment.app.FragmentFactory mFragmentFactory -> if
    androidx.fragment.app.FragmentTransaction beginTransaction() -> do
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    void setFragmentFactory(androidx.fragment.app.FragmentFactory) -> do
    java.util.List getFragments() -> for
    androidx.fragment.app.FragmentFactory getFragmentFactory() -> if
    boolean popBackStackImmediate() -> int
androidx.fragment.app.FragmentManager$FragmentLifecycleCallbacks -> androidx.fragment.app.char$do:
    void onFragmentViewDestroyed(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment) -> byte
    void onFragmentActivityCreated(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment,android.os.Bundle) -> do
    void onFragmentAttached(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment,android.content.Context) -> do
    void onFragmentDestroyed(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment) -> do
    void onFragmentViewCreated(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment,android.view.View,android.os.Bundle) -> do
    void onFragmentPaused(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment) -> for
    void onFragmentPreCreated(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment,android.os.Bundle) -> for
    void onFragmentCreated(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment,android.os.Bundle) -> if
    void onFragmentDetached(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment) -> if
    void onFragmentPreAttached(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment,android.content.Context) -> if
    void onFragmentResumed(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment) -> int
    void onFragmentSaveInstanceState(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment,android.os.Bundle) -> int
    void onFragmentStarted(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment) -> new
    void onFragmentStopped(androidx.fragment.app.FragmentManager,androidx.fragment.app.Fragment) -> try
androidx.fragment.app.FragmentManager$OnBackStackChangedListener -> androidx.fragment.app.char$if:
    void onBackStackChanged() -> do
androidx.fragment.app.FragmentManagerImpl -> androidx.fragment.app.else:
    androidx.fragment.app.FragmentContainer mContainer -> final
    boolean mStopped -> while
    java.util.ArrayList mPendingActions -> int
    androidx.fragment.app.FragmentHostCallback mHost -> const
    boolean mExecutingActions -> new
    java.util.ArrayList mAvailBackStackIndices -> void
    boolean mHavePendingDeferredStart -> import
    java.util.concurrent.CopyOnWriteArrayList mLifecycleCallbacks -> catch
    java.util.ArrayList mBackStackIndices -> this
    androidx.activity.OnBackPressedDispatcher mOnBackPressedDispatcher -> goto
    android.view.animation.Interpolator DECELERATE_QUINT -> finally
    java.util.ArrayList mTmpIsPop -> public
    android.util.SparseArray mStateArray -> switch
    androidx.fragment.app.Fragment mPrimaryNav -> short
    java.util.ArrayList mCreatedMenus -> else
    boolean mDestroyed -> double
    android.os.Bundle mStateBundle -> static
    int mCurState -> class
    android.view.animation.Interpolator DECELERATE_CUBIC -> package
    androidx.fragment.app.FragmentManagerViewModel mNonConfig -> boolean
    int mNextFragmentIndex -> try
    androidx.activity.OnBackPressedCallback mOnBackPressedCallback -> long
    java.util.ArrayList mBackStackChangeListeners -> break
    boolean mNeedMenuInvalidate -> super
    java.lang.Runnable mExecCommit -> default
    java.util.ArrayList mTmpAddedFragments -> return
    java.util.ArrayList mPostponedTransactions -> throws
    androidx.fragment.app.Fragment mParent -> float
    java.util.ArrayList mAdded -> byte
    java.util.HashMap mActive -> case
    boolean DEBUG -> extends
    java.util.ArrayList mBackStack -> char
    boolean mStateSaved -> throw
    java.util.ArrayList mTmpRecords -> native
    void forcePostponedTransactions() -> boolean
    void dispatchStop() -> break
    void removeFragment(androidx.fragment.app.Fragment) -> break
    void dispatchCreate() -> byte
    void dispatchOnFragmentStopped(androidx.fragment.app.Fragment,boolean) -> byte
    androidx.lifecycle.ViewModelStore getViewModelStore(androidx.fragment.app.Fragment) -> byte
    void dispatchDestroy() -> case
    void dispatchOnFragmentViewDestroyed(androidx.fragment.app.Fragment,boolean) -> case
    void hideFragment(androidx.fragment.app.Fragment) -> case
    void doPendingDeferredStart() -> catch
    void removeRetainedFragment(androidx.fragment.app.Fragment) -> catch
    void dispatchDestroyView() -> char
    boolean isPrimaryNavigation(androidx.fragment.app.Fragment) -> char
    boolean execPendingActions() -> class
    android.os.Bundle saveFragmentBasicState(androidx.fragment.app.Fragment) -> class
    int getBackStackEntryCount() -> const
    void saveFragmentViewState(androidx.fragment.app.Fragment) -> const
    void updateOnBackPressedCallbackEnabled() -> default
    void addAddedFragments(androidx.collection.ArraySet) -> do
    void addBackStackState(androidx.fragment.app.BackStackRecord) -> do
    void addFragment(androidx.fragment.app.Fragment,boolean) -> do
    void addRetainedFragment(androidx.fragment.app.Fragment) -> do
    void animateRemoveFragment(androidx.fragment.app.Fragment,androidx.fragment.app.FragmentManagerImpl$AnimationOrAnimator,int) -> do
    void attachController(androidx.fragment.app.FragmentHostCallback,androidx.fragment.app.FragmentContainer,androidx.fragment.app.Fragment) -> do
    androidx.fragment.app.FragmentTransaction beginTransaction() -> do
    void completeExecute(androidx.fragment.app.BackStackRecord,boolean,boolean,boolean) -> do
    void dispatchConfigurationChanged(android.content.res.Configuration) -> do
    boolean dispatchContextItemSelected(android.view.MenuItem) -> do
    boolean dispatchCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> do
    void dispatchMultiWindowModeChanged(boolean) -> do
    void dispatchOnFragmentActivityCreated(androidx.fragment.app.Fragment,android.os.Bundle,boolean) -> do
    void dispatchOnFragmentAttached(androidx.fragment.app.Fragment,android.content.Context,boolean) -> do
    void dispatchOnFragmentViewCreated(androidx.fragment.app.Fragment,android.view.View,android.os.Bundle,boolean) -> do
    void dispatchOptionsMenuClosed(android.view.Menu) -> do
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    void enqueueAction(androidx.fragment.app.FragmentManagerImpl$OpGenerator,boolean) -> do
    void executeOps(java.util.ArrayList,java.util.ArrayList,int,int) -> do
    void executePostponedTransaction(java.util.ArrayList,java.util.ArrayList) -> do
    androidx.fragment.app.Fragment findFragmentById(int) -> do
    androidx.fragment.app.Fragment findFragmentByTag(java.lang.String) -> do
    androidx.fragment.app.Fragment getFragment(android.os.Bundle,java.lang.String) -> do
    androidx.fragment.app.FragmentManagerImpl$AnimationOrAnimator loadAnimation(androidx.fragment.app.Fragment,int,boolean,int) -> do
    androidx.fragment.app.FragmentManagerImpl$AnimationOrAnimator makeFadeAnimation(float,float) -> do
    androidx.fragment.app.FragmentManagerImpl$AnimationOrAnimator makeOpenCloseAnimation(float,float,float,float) -> do
    void moveToState(int,boolean) -> do
    void moveToState(androidx.fragment.app.Fragment,int,int,int,boolean) -> do
    boolean popBackStackImmediate(java.lang.String,int,int) -> do
    boolean popBackStackState(java.util.ArrayList,java.util.ArrayList,java.lang.String,int,int) -> do
    int postponePostponableTransactions(java.util.ArrayList,java.util.ArrayList,int,int,androidx.collection.ArraySet) -> do
    void putFragment(android.os.Bundle,java.lang.String,androidx.fragment.app.Fragment) -> do
    void restoreSaveState(android.os.Parcelable) -> do
    void setBackStackIndex(int,androidx.fragment.app.BackStackRecord) -> do
    void setMaxLifecycle(androidx.fragment.app.Fragment,androidx.lifecycle.Lifecycle$State) -> do
    void throwException(java.lang.RuntimeException) -> do
    void reportBackStackChanged() -> double
    void dispatchLowMemory() -> else
    void makeActive(androidx.fragment.app.Fragment) -> else
    android.view.LayoutInflater$Factory2 getLayoutInflaterFactory() -> final
    void setPrimaryNavigationFragment(androidx.fragment.app.Fragment) -> final
    androidx.fragment.app.Fragment getPrimaryNavigationFragment() -> float
    void showFragment(androidx.fragment.app.Fragment) -> float
    void completeShowHideFragment(androidx.fragment.app.Fragment) -> for
    void dispatchOnFragmentDetached(androidx.fragment.app.Fragment,boolean) -> for
    void dispatchOnFragmentPreCreated(androidx.fragment.app.Fragment,android.os.Bundle,boolean) -> for
    void ensureExecReady(boolean) -> for
    java.util.List getFragments() -> for
    boolean isStateAtLeast(int) -> for
    void removeRedundantOperationsAndExecute(java.util.ArrayList,java.util.ArrayList) -> for
    void dispatchPause() -> goto
    void makeInactive(androidx.fragment.app.Fragment) -> goto
    int allocBackStackIndex(androidx.fragment.app.BackStackRecord) -> if
    void attachFragment(androidx.fragment.app.Fragment) -> if
    void dispatchOnFragmentCreated(androidx.fragment.app.Fragment,android.os.Bundle,boolean) -> if
    void dispatchOnFragmentDestroyed(androidx.fragment.app.Fragment,boolean) -> if
    void dispatchOnFragmentPreAttached(androidx.fragment.app.Fragment,android.content.Context,boolean) -> if
    boolean dispatchOptionsItemSelected(android.view.MenuItem) -> if
    void dispatchPictureInPictureModeChanged(boolean) -> if
    boolean dispatchPrepareOptionsMenu(android.view.Menu) -> if
    void executeOpsTogether(java.util.ArrayList,java.util.ArrayList,int,int) -> if
    androidx.fragment.app.Fragment findFragmentByWho(java.lang.String) -> if
    void freeBackStackIndex(int) -> if
    boolean generateOpsForPendingActions(java.util.ArrayList,java.util.ArrayList) -> if
    androidx.fragment.app.FragmentFactory getFragmentFactory() -> if
    void makeRemovedFragmentsInvisible(androidx.collection.ArraySet) -> if
    int transitToStyleIndex(int,boolean) -> if
    android.os.Parcelable saveAllState() -> import
    void detachFragment(androidx.fragment.app.Fragment) -> int
    void dispatchOnFragmentPaused(androidx.fragment.app.Fragment,boolean) -> int
    void dispatchOnFragmentSaveInstanceState(androidx.fragment.app.Fragment,android.os.Bundle,boolean) -> int
    void dispatchStateChange(int) -> int
    boolean popBackStackImmediate() -> int
    void dispatchPrimaryNavigationFragmentChanged() -> long
    void moveFragmentToExpectedState(androidx.fragment.app.Fragment) -> long
    void scheduleCommit() -> native
    boolean checkForMenus() -> new
    void dispatchOnFragmentResumed(androidx.fragment.app.Fragment,boolean) -> new
    void ensureInflatedFragmentView(androidx.fragment.app.Fragment) -> new
    int reverseTransit(int) -> new
    void startPendingDeferredFragments() -> public
    void burpActive() -> return
    void dispatchParentPrimaryNavigationFragmentChanged(androidx.fragment.app.Fragment) -> short
    void handleOnBackPressed() -> short
    void checkStateLoss() -> static
    androidx.fragment.app.Fragment findFragmentUnder(androidx.fragment.app.Fragment) -> super
    boolean isDestroyed() -> super
    void cleanupExec() -> switch
    void dispatchResume() -> this
    void moveToState(androidx.fragment.app.Fragment) -> this
    boolean isMenuAvailable(androidx.fragment.app.Fragment) -> throw
    boolean isStateSaved() -> throw
    void endAnimatingAwayFragments() -> throws
    void dispatchActivityCreated() -> try
    void dispatchOnFragmentStarted(androidx.fragment.app.Fragment,boolean) -> try
    androidx.fragment.app.FragmentManagerViewModel getChildNonConfig(androidx.fragment.app.Fragment) -> try
    void dispatchStart() -> void
    void performPendingDeferredStart(androidx.fragment.app.Fragment) -> void
    void noteStateNotSaved() -> while
androidx.fragment.app.FragmentManagerImpl$1 -> androidx.fragment.app.else$do:
    androidx.fragment.app.FragmentManagerImpl this$0 -> for
    void handleOnBackPressed() -> do
androidx.fragment.app.FragmentManagerImpl$2 -> androidx.fragment.app.else$if:
    androidx.fragment.app.FragmentManagerImpl this$0 -> if
androidx.fragment.app.FragmentManagerImpl$3 -> androidx.fragment.app.else$for:
    androidx.fragment.app.FragmentManagerImpl this$0 -> for
    androidx.fragment.app.Fragment val$fragment -> if
    android.view.ViewGroup val$container -> do
androidx.fragment.app.FragmentManagerImpl$3$1 -> androidx.fragment.app.else$for$do:
    androidx.fragment.app.FragmentManagerImpl$3 this$1 -> if
androidx.fragment.app.FragmentManagerImpl$4 -> androidx.fragment.app.else$int:
    androidx.fragment.app.Fragment val$fragment -> for
    android.view.View val$viewToAnimate -> if
    android.view.ViewGroup val$container -> do
    androidx.fragment.app.FragmentManagerImpl this$0 -> int
androidx.fragment.app.FragmentManagerImpl$5 -> androidx.fragment.app.else$new:
    androidx.fragment.app.Fragment val$fragment -> for
    android.view.View val$animatingView -> if
    android.view.ViewGroup val$container -> do
androidx.fragment.app.FragmentManagerImpl$6 -> androidx.fragment.app.else$try:
    androidx.fragment.app.FragmentManagerImpl this$0 -> if
    androidx.fragment.app.Fragment instantiate(java.lang.ClassLoader,java.lang.String) -> do
androidx.fragment.app.FragmentManagerImpl$AnimationOrAnimator -> androidx.fragment.app.else$byte:
    android.view.animation.Animation animation -> do
    android.animation.Animator animator -> if
androidx.fragment.app.FragmentManagerImpl$EndViewTransitionAnimation -> androidx.fragment.app.else$case:
    android.view.View mChild -> for
    boolean mEnded -> int
    boolean mTransitionEnded -> new
    android.view.ViewGroup mParent -> if
    boolean mAnimating -> try
androidx.fragment.app.FragmentManagerImpl$FragmentLifecycleCallbacksHolder -> androidx.fragment.app.else$char:
    boolean mRecursive -> if
    androidx.fragment.app.FragmentManager$FragmentLifecycleCallbacks mCallback -> do
androidx.fragment.app.FragmentManagerImpl$FragmentTag -> androidx.fragment.app.else$else:
    int[] Fragment -> do
androidx.fragment.app.FragmentManagerImpl$OpGenerator -> androidx.fragment.app.else$goto:
    boolean generateOps(java.util.ArrayList,java.util.ArrayList) -> do
androidx.fragment.app.FragmentManagerImpl$StartEnterTransitionListener -> androidx.fragment.app.else$long:
    boolean mIsBack -> do
    int mNumPostponed -> for
    androidx.fragment.app.BackStackRecord mRecord -> if
    void onStartEnterTransition() -> do
    void cancelTransaction() -> for
    void startListening() -> if
    void completeTransaction() -> int
    boolean isReady() -> new
androidx.fragment.app.FragmentManagerState -> androidx.fragment.app.goto:
    androidx.fragment.app.BackStackState[] mBackStack -> int
    java.util.ArrayList mActive -> if
    java.lang.String mPrimaryNavActiveWho -> new
    java.util.ArrayList mAdded -> for
    int mNextFragmentIndex -> try
androidx.fragment.app.FragmentManagerState$1 -> androidx.fragment.app.goto$do:
androidx.fragment.app.FragmentManagerViewModel -> androidx.fragment.app.long:
    java.util.HashMap mChildNonConfigs -> for
    java.util.HashSet mRetainedFragments -> if
    boolean mStateAutomaticallySaved -> new
    boolean mHasSavedSnapshot -> byte
    java.util.HashMap mViewModelStores -> int
    boolean mHasBeenCleared -> try
    androidx.lifecycle.ViewModelProvider$Factory FACTORY -> case
    boolean addRetainedFragment(androidx.fragment.app.Fragment) -> do
    androidx.fragment.app.FragmentManagerViewModel getInstance(androidx.lifecycle.ViewModelStore) -> do
    androidx.fragment.app.FragmentManagerViewModel getChildNonConfig(androidx.fragment.app.Fragment) -> for
    java.util.Collection getRetainedFragments() -> for
    void clearNonConfigState(androidx.fragment.app.Fragment) -> if
    void onCleared() -> if
    androidx.lifecycle.ViewModelStore getViewModelStore(androidx.fragment.app.Fragment) -> int
    boolean isCleared() -> int
    boolean removeRetainedFragment(androidx.fragment.app.Fragment) -> new
    boolean shouldDestroy(androidx.fragment.app.Fragment) -> try
androidx.fragment.app.FragmentManagerViewModel$1 -> androidx.fragment.app.long$do:
    androidx.lifecycle.ViewModel create(java.lang.Class) -> do
androidx.fragment.app.FragmentState -> androidx.fragment.app.this:
    boolean mRetainInstance -> case
    android.os.Bundle mArguments -> goto
    int mMaxLifecycleState -> this
    java.lang.String mTag -> byte
    androidx.fragment.app.Fragment mInstance -> break
    int mContainerId -> try
    boolean mRemoving -> char
    boolean mHidden -> long
    java.lang.String mWho -> for
    boolean mDetached -> else
    boolean mFromLayout -> int
    java.lang.String mClassName -> if
    android.os.Bundle mSavedFragmentState -> void
    int mFragmentId -> new
    androidx.fragment.app.Fragment instantiate(java.lang.ClassLoader,androidx.fragment.app.FragmentFactory) -> do
androidx.fragment.app.FragmentState$1 -> androidx.fragment.app.this$do:
androidx.fragment.app.FragmentTransaction -> androidx.fragment.app.void:
    boolean mAddToBackStack -> case
    java.lang.CharSequence mBreadCrumbTitleText -> goto
    java.util.ArrayList mSharedElementSourceNames -> void
    int mTransition -> try
    java.lang.String mName -> char
    java.lang.CharSequence mBreadCrumbShortTitleText -> this
    java.util.ArrayList mSharedElementTargetNames -> break
    int mEnterAnim -> if
    int mPopEnterAnim -> int
    int mBreadCrumbShortTitleRes -> long
    java.util.ArrayList mOps -> do
    int mBreadCrumbTitleRes -> else
    boolean mReorderingAllowed -> catch
    int mExitAnim -> for
    int mTransitionStyle -> byte
    java.util.ArrayList mCommitRunnables -> class
    int mPopExitAnim -> new
    androidx.fragment.app.FragmentTransaction add(int,androidx.fragment.app.Fragment) -> do
    void addOp(androidx.fragment.app.FragmentTransaction$Op) -> do
    int commit() -> do
    void doAddOp(int,androidx.fragment.app.Fragment,java.lang.String,int) -> do
    androidx.fragment.app.FragmentTransaction replace(int,androidx.fragment.app.Fragment,java.lang.String) -> do
    androidx.fragment.app.FragmentTransaction replace(int,androidx.fragment.app.Fragment) -> if
androidx.fragment.app.FragmentTransaction$Op -> androidx.fragment.app.void$do:
    int mExitAnim -> int
    androidx.lifecycle.Lifecycle$State mCurrentMaxState -> case
    int mCmd -> do
    int mEnterAnim -> for
    androidx.fragment.app.Fragment mFragment -> if
    int mPopEnterAnim -> new
    int mPopExitAnim -> try
    androidx.lifecycle.Lifecycle$State mOldMaxState -> byte
androidx.fragment.app.FragmentTransition -> androidx.fragment.app.break:
    androidx.fragment.app.FragmentTransitionImpl PLATFORM_IMPL -> if
    int[] INVERSE_OPS -> do
    androidx.fragment.app.FragmentTransitionImpl SUPPORT_IMPL -> for
    void addSharedElementsWithMatchingNames(java.util.ArrayList,androidx.collection.ArrayMap,java.util.Collection) -> do
    void addToFirstInLastOut(androidx.fragment.app.BackStackRecord,androidx.fragment.app.FragmentTransaction$Op,android.util.SparseArray,boolean,boolean) -> do
    void calculateFragments(androidx.fragment.app.BackStackRecord,android.util.SparseArray,boolean) -> do
    androidx.collection.ArrayMap calculateNameOverrides(int,java.util.ArrayList,java.util.ArrayList,int,int) -> do
    void callSharedElementStartEnd(androidx.fragment.app.Fragment,androidx.fragment.app.Fragment,boolean,androidx.collection.ArrayMap,boolean) -> do
    boolean canHandleAll(androidx.fragment.app.FragmentTransitionImpl,java.util.List) -> do
    androidx.collection.ArrayMap captureInSharedElements(androidx.fragment.app.FragmentTransitionImpl,androidx.collection.ArrayMap,java.lang.Object,androidx.fragment.app.FragmentTransition$FragmentContainerTransition) -> do
    androidx.fragment.app.FragmentTransitionImpl chooseImpl(androidx.fragment.app.Fragment,androidx.fragment.app.Fragment) -> do
    java.util.ArrayList configureEnteringExitingViews(androidx.fragment.app.FragmentTransitionImpl,java.lang.Object,androidx.fragment.app.Fragment,java.util.ArrayList,android.view.View) -> do
    java.lang.Object configureSharedElementsOrdered(androidx.fragment.app.FragmentTransitionImpl,android.view.ViewGroup,android.view.View,androidx.collection.ArrayMap,androidx.fragment.app.FragmentTransition$FragmentContainerTransition,java.util.ArrayList,java.util.ArrayList,java.lang.Object,java.lang.Object) -> do
    void configureTransitionsOrdered(androidx.fragment.app.FragmentManagerImpl,int,androidx.fragment.app.FragmentTransition$FragmentContainerTransition,android.view.View,androidx.collection.ArrayMap) -> do
    androidx.fragment.app.FragmentTransition$FragmentContainerTransition ensureContainer(androidx.fragment.app.FragmentTransition$FragmentContainerTransition,android.util.SparseArray,int) -> do
    java.lang.String findKeyForValue(androidx.collection.ArrayMap,java.lang.String) -> do
    java.lang.Object getEnterTransition(androidx.fragment.app.FragmentTransitionImpl,androidx.fragment.app.Fragment,boolean) -> do
    android.view.View getInEpicenterView(androidx.collection.ArrayMap,androidx.fragment.app.FragmentTransition$FragmentContainerTransition,java.lang.Object,boolean) -> do
    java.lang.Object getSharedElementTransition(androidx.fragment.app.FragmentTransitionImpl,androidx.fragment.app.Fragment,androidx.fragment.app.Fragment,boolean) -> do
    java.lang.Object mergeTransitions(androidx.fragment.app.FragmentTransitionImpl,java.lang.Object,java.lang.Object,java.lang.Object,androidx.fragment.app.Fragment,boolean) -> do
    void replaceHide(androidx.fragment.app.FragmentTransitionImpl,java.lang.Object,androidx.fragment.app.Fragment,java.util.ArrayList) -> do
    androidx.fragment.app.FragmentTransitionImpl resolveSupportImpl() -> do
    void retainValues(androidx.collection.ArrayMap,androidx.collection.ArrayMap) -> do
    void scheduleTargetChange(androidx.fragment.app.FragmentTransitionImpl,android.view.ViewGroup,androidx.fragment.app.Fragment,android.view.View,java.util.ArrayList,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList) -> do
    void setOutEpicenter(androidx.fragment.app.FragmentTransitionImpl,java.lang.Object,java.lang.Object,androidx.collection.ArrayMap,boolean,androidx.fragment.app.BackStackRecord) -> do
    void setViewVisibility(java.util.ArrayList,int) -> do
    void startTransitions(androidx.fragment.app.FragmentManagerImpl,java.util.ArrayList,java.util.ArrayList,int,int,boolean) -> do
    void calculatePopFragments(androidx.fragment.app.BackStackRecord,android.util.SparseArray,boolean) -> if
    androidx.collection.ArrayMap captureOutSharedElements(androidx.fragment.app.FragmentTransitionImpl,androidx.collection.ArrayMap,java.lang.Object,androidx.fragment.app.FragmentTransition$FragmentContainerTransition) -> if
    java.lang.Object configureSharedElementsReordered(androidx.fragment.app.FragmentTransitionImpl,android.view.ViewGroup,android.view.View,androidx.collection.ArrayMap,androidx.fragment.app.FragmentTransition$FragmentContainerTransition,java.util.ArrayList,java.util.ArrayList,java.lang.Object,java.lang.Object) -> if
    void configureTransitionsReordered(androidx.fragment.app.FragmentManagerImpl,int,androidx.fragment.app.FragmentTransition$FragmentContainerTransition,android.view.View,androidx.collection.ArrayMap) -> if
    java.lang.Object getExitTransition(androidx.fragment.app.FragmentTransitionImpl,androidx.fragment.app.Fragment,boolean) -> if
androidx.fragment.app.FragmentTransition$1 -> androidx.fragment.app.break$do:
    java.util.ArrayList val$exitingViews -> if
androidx.fragment.app.FragmentTransition$2 -> androidx.fragment.app.break$if:
    java.lang.Object val$exitTransition -> char
    java.util.ArrayList val$sharedElementsIn -> try
    androidx.fragment.app.Fragment val$inFragment -> new
    android.view.View val$nonExistentView -> int
    java.util.ArrayList val$enteringViews -> byte
    java.lang.Object val$enterTransition -> if
    java.util.ArrayList val$exitingViews -> case
    androidx.fragment.app.FragmentTransitionImpl val$impl -> for
androidx.fragment.app.FragmentTransition$3 -> androidx.fragment.app.break$for:
    android.graphics.Rect val$epicenter -> case
    androidx.fragment.app.Fragment val$outFragment -> for
    boolean val$inIsPop -> int
    android.view.View val$epicenterView -> try
    androidx.fragment.app.FragmentTransitionImpl val$impl -> byte
    androidx.fragment.app.Fragment val$inFragment -> if
    androidx.collection.ArrayMap val$inSharedElements -> new
androidx.fragment.app.FragmentTransition$4 -> androidx.fragment.app.break$int:
    androidx.fragment.app.FragmentTransitionImpl val$impl -> if
    java.util.ArrayList val$sharedElementsIn -> try
    androidx.fragment.app.Fragment val$outFragment -> char
    boolean val$inIsPop -> else
    java.util.ArrayList val$sharedElementsOut -> goto
    androidx.collection.ArrayMap val$nameOverrides -> for
    androidx.fragment.app.FragmentTransition$FragmentContainerTransition val$fragments -> new
    android.view.View val$nonExistentView -> byte
    android.graphics.Rect val$inEpicenter -> this
    java.lang.Object val$enterTransition -> long
    androidx.fragment.app.Fragment val$inFragment -> case
    java.lang.Object val$finalSharedElementTransition -> int
androidx.fragment.app.FragmentTransition$FragmentContainerTransition -> androidx.fragment.app.break$new:
    androidx.fragment.app.Fragment lastIn -> do
    boolean lastInIsPop -> if
    boolean firstOutIsPop -> new
    androidx.fragment.app.BackStackRecord lastInTransaction -> for
    androidx.fragment.app.Fragment firstOut -> int
    androidx.fragment.app.BackStackRecord firstOutTransaction -> try
androidx.fragment.app.FragmentTransitionCompat21 -> androidx.fragment.app.catch:
    void addTarget(java.lang.Object,android.view.View) -> do
    void addTargets(java.lang.Object,java.util.ArrayList) -> do
    void beginDelayedTransition(android.view.ViewGroup,java.lang.Object) -> do
    boolean canHandle(java.lang.Object) -> do
    boolean hasSimpleTarget(android.transition.Transition) -> do
    java.lang.Object mergeTransitionsInSequence(java.lang.Object,java.lang.Object,java.lang.Object) -> do
    void replaceTargets(java.lang.Object,java.util.ArrayList,java.util.ArrayList) -> do
    void scheduleHideFragmentView(java.lang.Object,android.view.View,java.util.ArrayList) -> do
    void scheduleRemoveTargets(java.lang.Object,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList) -> do
    void setEpicenter(java.lang.Object,android.graphics.Rect) -> do
    void setEpicenter(java.lang.Object,android.view.View) -> for
    java.lang.Object wrapTransitionInSet(java.lang.Object) -> for
    java.lang.Object cloneTransition(java.lang.Object) -> if
    java.lang.Object mergeTransitionsTogether(java.lang.Object,java.lang.Object,java.lang.Object) -> if
    void removeTarget(java.lang.Object,android.view.View) -> if
    void setSharedElementTargets(java.lang.Object,android.view.View,java.util.ArrayList) -> if
    void swapSharedElementTargets(java.lang.Object,java.util.ArrayList,java.util.ArrayList) -> if
androidx.fragment.app.FragmentTransitionCompat21$1 -> androidx.fragment.app.catch$do:
    android.graphics.Rect val$epicenter -> do
androidx.fragment.app.FragmentTransitionCompat21$2 -> androidx.fragment.app.catch$if:
    android.view.View val$fragmentView -> do
    java.util.ArrayList val$exitingViews -> if
androidx.fragment.app.FragmentTransitionCompat21$3 -> androidx.fragment.app.catch$for:
    java.util.ArrayList val$exitingViews -> int
    java.lang.Object val$enterTransition -> do
    java.util.ArrayList val$sharedElementsIn -> try
    java.util.ArrayList val$enteringViews -> if
    java.lang.Object val$exitTransition -> for
    androidx.fragment.app.FragmentTransitionCompat21 this$0 -> byte
    java.lang.Object val$sharedElementTransition -> new
androidx.fragment.app.FragmentTransitionCompat21$4 -> androidx.fragment.app.catch$int:
    android.graphics.Rect val$epicenter -> do
androidx.fragment.app.FragmentTransitionImpl -> androidx.fragment.app.class:
    void addTarget(java.lang.Object,android.view.View) -> do
    void addTargets(java.lang.Object,java.util.ArrayList) -> do
    void beginDelayedTransition(android.view.ViewGroup,java.lang.Object) -> do
    void bfsAddViewChildren(java.util.List,android.view.View) -> do
    boolean canHandle(java.lang.Object) -> do
    void captureTransitioningViews(java.util.ArrayList,android.view.View) -> do
    boolean containedBeforeIndex(java.util.List,android.view.View,int) -> do
    java.lang.String findKeyForValue(java.util.Map,java.lang.String) -> do
    void findNamedViews(java.util.Map,android.view.View) -> do
    void getBoundsOnScreen(android.view.View,android.graphics.Rect) -> do
    boolean isNullOrEmpty(java.util.List) -> do
    java.lang.Object mergeTransitionsInSequence(java.lang.Object,java.lang.Object,java.lang.Object) -> do
    java.util.ArrayList prepareSetNameOverridesReordered(java.util.ArrayList) -> do
    void replaceTargets(java.lang.Object,java.util.ArrayList,java.util.ArrayList) -> do
    void scheduleHideFragmentView(java.lang.Object,android.view.View,java.util.ArrayList) -> do
    void scheduleNameReset(android.view.ViewGroup,java.util.ArrayList,java.util.Map) -> do
    void scheduleRemoveTargets(java.lang.Object,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList) -> do
    void setEpicenter(java.lang.Object,android.graphics.Rect) -> do
    void setNameOverridesOrdered(android.view.View,java.util.ArrayList,java.util.Map) -> do
    void setNameOverridesReordered(android.view.View,java.util.ArrayList,java.util.ArrayList,java.util.ArrayList,java.util.Map) -> do
    void setEpicenter(java.lang.Object,android.view.View) -> for
    java.lang.Object wrapTransitionInSet(java.lang.Object) -> for
    java.lang.Object cloneTransition(java.lang.Object) -> if
    java.lang.Object mergeTransitionsTogether(java.lang.Object,java.lang.Object,java.lang.Object) -> if
    void removeTarget(java.lang.Object,android.view.View) -> if
    void setSharedElementTargets(java.lang.Object,android.view.View,java.util.ArrayList) -> if
    void swapSharedElementTargets(java.lang.Object,java.util.ArrayList,java.util.ArrayList) -> if
androidx.fragment.app.FragmentTransitionImpl$1 -> androidx.fragment.app.class$do:
    int val$numSharedElements -> if
    java.util.ArrayList val$inNames -> int
    java.util.ArrayList val$outNames -> try
    java.util.ArrayList val$sharedElementsIn -> for
    java.util.ArrayList val$sharedElementsOut -> new
androidx.fragment.app.FragmentTransitionImpl$2 -> androidx.fragment.app.class$if:
    java.util.ArrayList val$sharedElementsIn -> if
    java.util.Map val$nameOverrides -> for
androidx.fragment.app.FragmentTransitionImpl$3 -> androidx.fragment.app.class$for:
    java.util.ArrayList val$sharedElementsIn -> if
    java.util.Map val$nameOverrides -> for
androidx.fragment.app.FragmentViewLifecycleOwner -> androidx.fragment.app.const:
    androidx.lifecycle.LifecycleRegistry mLifecycleRegistry -> if
    androidx.lifecycle.Lifecycle getLifecycle() -> do
    void handleLifecycleEvent(androidx.lifecycle.Lifecycle$Event) -> do
    void initialize() -> int
    boolean isInitialized() -> new
androidx.fragment.app.SuperNotCalledException -> androidx.fragment.app.final:
androidx.interpolator.view.animation.FastOutLinearInInterpolator -> if.char.do.do.do:
    float[] VALUES -> for
androidx.interpolator.view.animation.FastOutSlowInInterpolator -> if.char.do.do.if:
    float[] VALUES -> for
androidx.interpolator.view.animation.LinearOutSlowInInterpolator -> if.char.do.do.for:
    float[] VALUES -> for
androidx.interpolator.view.animation.LookupTableInterpolator -> if.char.do.do.int:
    float[] mValues -> do
    float mStepSize -> if
androidx.lifecycle.ClassesInfoCache -> androidx.lifecycle.do:
    java.util.Map mHasLifecycleMethods -> if
    androidx.lifecycle.ClassesInfoCache sInstance -> for
    java.util.Map mCallbackMap -> do
    androidx.lifecycle.ClassesInfoCache$CallbackInfo createInfo(java.lang.Class,java.lang.reflect.Method[]) -> do
    androidx.lifecycle.ClassesInfoCache$CallbackInfo getInfo(java.lang.Class) -> do
    void verifyAndPutHandler(java.util.Map,androidx.lifecycle.ClassesInfoCache$MethodReference,androidx.lifecycle.Lifecycle$Event,java.lang.Class) -> do
    java.lang.reflect.Method[] getDeclaredMethods(java.lang.Class) -> for
    boolean hasLifecycleMethods(java.lang.Class) -> if
androidx.lifecycle.ClassesInfoCache$CallbackInfo -> androidx.lifecycle.do$do:
    java.util.Map mHandlerToEvent -> if
    java.util.Map mEventToHandlers -> do
    void invokeCallbacks(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event,java.lang.Object) -> do
    void invokeMethodsForEvent(java.util.List,androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event,java.lang.Object) -> do
androidx.lifecycle.ClassesInfoCache$MethodReference -> androidx.lifecycle.do$if:
    java.lang.reflect.Method mMethod -> if
    int mCallType -> do
    void invokeCallback(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event,java.lang.Object) -> do
androidx.lifecycle.CompositeGeneratedAdaptersObserver -> androidx.lifecycle.CompositeGeneratedAdaptersObserver:
    androidx.lifecycle.GeneratedAdapter[] mGeneratedAdapters -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.lifecycle.FullLifecycleObserver -> androidx.lifecycle.if:
    void onResume(androidx.lifecycle.LifecycleOwner) -> do
    void onDestroy(androidx.lifecycle.LifecycleOwner) -> for
    void onPause(androidx.lifecycle.LifecycleOwner) -> if
    void onStop(androidx.lifecycle.LifecycleOwner) -> int
    void onCreate(androidx.lifecycle.LifecycleOwner) -> new
    void onStart(androidx.lifecycle.LifecycleOwner) -> try
androidx.lifecycle.FullLifecycleObserverAdapter -> androidx.lifecycle.FullLifecycleObserverAdapter:
    androidx.lifecycle.LifecycleEventObserver mLifecycleEventObserver -> if
    androidx.lifecycle.FullLifecycleObserver mFullLifecycleObserver -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.lifecycle.FullLifecycleObserverAdapter$1 -> androidx.lifecycle.FullLifecycleObserverAdapter$do:
    int[] $SwitchMap$androidx$lifecycle$Lifecycle$Event -> do
androidx.lifecycle.GeneratedAdapter -> androidx.lifecycle.for:
    void callMethods(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event,boolean,androidx.lifecycle.MethodCallsLogger) -> do
androidx.lifecycle.GenericLifecycleObserver -> androidx.lifecycle.int:
androidx.lifecycle.Lifecycle -> androidx.lifecycle.new:
    void addObserver(androidx.lifecycle.LifecycleObserver) -> do
    androidx.lifecycle.Lifecycle$State getCurrentState() -> do
    void removeObserver(androidx.lifecycle.LifecycleObserver) -> if
androidx.lifecycle.Lifecycle$Event -> androidx.lifecycle.new$do:
androidx.lifecycle.Lifecycle$State -> androidx.lifecycle.new$if:
    androidx.lifecycle.Lifecycle$State RESUMED -> try
    androidx.lifecycle.Lifecycle$State CREATED -> int
    androidx.lifecycle.Lifecycle$State[] $VALUES -> byte
    androidx.lifecycle.Lifecycle$State INITIALIZED -> for
    androidx.lifecycle.Lifecycle$State STARTED -> new
    androidx.lifecycle.Lifecycle$State DESTROYED -> if
    boolean isAtLeast(androidx.lifecycle.Lifecycle$State) -> do
androidx.lifecycle.LifecycleEventObserver -> androidx.lifecycle.try:
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.lifecycle.LifecycleObserver -> androidx.lifecycle.byte:
androidx.lifecycle.LifecycleOwner -> androidx.lifecycle.case:
    androidx.lifecycle.Lifecycle getLifecycle() -> do
androidx.lifecycle.LifecycleRegistry -> androidx.lifecycle.char:
    int mAddingObserverCounter -> int
    java.lang.ref.WeakReference mLifecycleOwner -> for
    boolean mHandlingEvent -> new
    androidx.arch.core.internal.FastSafeIterableMap mObserverMap -> do
    java.util.ArrayList mParentStates -> byte
    boolean mNewEventOccurred -> try
    androidx.lifecycle.Lifecycle$State mState -> if
    void addObserver(androidx.lifecycle.LifecycleObserver) -> do
    void backwardPass(androidx.lifecycle.LifecycleOwner) -> do
    androidx.lifecycle.Lifecycle$State getCurrentState() -> do
    void handleLifecycleEvent(androidx.lifecycle.Lifecycle$Event) -> do
    void markState(androidx.lifecycle.Lifecycle$State) -> do
    androidx.lifecycle.Lifecycle$State min(androidx.lifecycle.Lifecycle$State,androidx.lifecycle.Lifecycle$State) -> do
    androidx.lifecycle.Lifecycle$State calculateTargetState(androidx.lifecycle.LifecycleObserver) -> for
    androidx.lifecycle.Lifecycle$Event downEvent(androidx.lifecycle.Lifecycle$State) -> for
    void popParentState() -> for
    void forwardPass(androidx.lifecycle.LifecycleOwner) -> if
    androidx.lifecycle.Lifecycle$State getStateAfter(androidx.lifecycle.Lifecycle$Event) -> if
    boolean isSynced() -> if
    void removeObserver(androidx.lifecycle.LifecycleObserver) -> if
    void setCurrentState(androidx.lifecycle.Lifecycle$State) -> if
    void moveToState(androidx.lifecycle.Lifecycle$State) -> int
    void sync() -> int
    void pushParentState(androidx.lifecycle.Lifecycle$State) -> new
    androidx.lifecycle.Lifecycle$Event upEvent(androidx.lifecycle.Lifecycle$State) -> try
androidx.lifecycle.LifecycleRegistry$1 -> androidx.lifecycle.char$do:
    int[] $SwitchMap$androidx$lifecycle$Lifecycle$State -> if
    int[] $SwitchMap$androidx$lifecycle$Lifecycle$Event -> do
androidx.lifecycle.LifecycleRegistry$ObserverWithState -> androidx.lifecycle.char$if:
    androidx.lifecycle.LifecycleEventObserver mLifecycleObserver -> if
    androidx.lifecycle.Lifecycle$State mState -> do
    void dispatchEvent(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.lifecycle.LifecycleRegistryOwner -> androidx.lifecycle.else:
    androidx.lifecycle.LifecycleRegistry getLifecycle() -> do
androidx.lifecycle.Lifecycling -> androidx.lifecycle.goto:
    java.util.Map sClassToAdapters -> if
    java.util.Map sCallbackCache -> do
    androidx.lifecycle.GeneratedAdapter createGeneratedAdapter(java.lang.reflect.Constructor,java.lang.Object) -> do
    java.lang.reflect.Constructor generatedConstructor(java.lang.Class) -> do
    java.lang.String getAdapterName(java.lang.String) -> do
    androidx.lifecycle.LifecycleEventObserver lifecycleEventObserver(java.lang.Object) -> do
    boolean isLifecycleParent(java.lang.Class) -> for
    int getObserverConstructorType(java.lang.Class) -> if
    int resolveObserverCallbackType(java.lang.Class) -> int
androidx.lifecycle.Lifecycling$1 -> androidx.lifecycle.Lifecycling$1:
    androidx.lifecycle.LifecycleEventObserver val$observer -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.lifecycle.LiveData -> androidx.lifecycle.LiveData:
    java.lang.Object NOT_SET -> char
    java.lang.Object mDataLock -> do
    androidx.arch.core.internal.SafeIterableMap mObservers -> if
    boolean mDispatchInvalidated -> case
    int mActiveCount -> for
    boolean mDispatchingValue -> byte
    int mVersion -> try
    java.lang.Object mData -> int
    java.lang.Object mPendingData -> new
    void assertMainThread(java.lang.String) -> do
    void dispatchingValue(androidx.lifecycle.LiveData$ObserverWrapper) -> do
    void observe(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Observer) -> do
    void onActive() -> do
    void removeObserver(androidx.lifecycle.Observer) -> do
    void setValue(java.lang.Object) -> do
    void considerNotify(androidx.lifecycle.LiveData$ObserverWrapper) -> if
    void onInactive() -> if
androidx.lifecycle.LiveData$1 -> androidx.lifecycle.LiveData$do:
    androidx.lifecycle.LiveData this$0 -> if
androidx.lifecycle.LiveData$LifecycleBoundObserver -> androidx.lifecycle.LiveData$LifecycleBoundObserver:
    androidx.lifecycle.LiveData this$0 -> try
    androidx.lifecycle.LifecycleOwner mOwner -> new
    boolean isAttachedTo(androidx.lifecycle.LifecycleOwner) -> byte
    void detachObserver() -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
    boolean shouldBeActive() -> if
androidx.lifecycle.LiveData$ObserverWrapper -> androidx.lifecycle.LiveData$if:
    androidx.lifecycle.LiveData this$0 -> int
    boolean mActive -> if
    int mLastVersion -> for
    androidx.lifecycle.Observer mObserver -> do
    boolean isAttachedTo(androidx.lifecycle.LifecycleOwner) -> byte
    void activeStateChanged(boolean) -> do
    void detachObserver() -> do
    boolean shouldBeActive() -> if
androidx.lifecycle.MethodCallsLogger -> androidx.lifecycle.long:
androidx.lifecycle.MutableLiveData -> androidx.lifecycle.this:
    void setValue(java.lang.Object) -> do
androidx.lifecycle.Observer -> androidx.lifecycle.void:
    void onChanged(java.lang.Object) -> do
androidx.lifecycle.OnLifecycleEvent -> androidx.lifecycle.break:
androidx.lifecycle.ReflectiveGenericLifecycleObserver -> androidx.lifecycle.ReflectiveGenericLifecycleObserver:
    java.lang.Object mWrapped -> do
    androidx.lifecycle.ClassesInfoCache$CallbackInfo mInfo -> if
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.lifecycle.ReportFragment -> androidx.lifecycle.catch:
    androidx.lifecycle.ReportFragment$ActivityInitializationListener mProcessListener -> if
    void dispatch(androidx.lifecycle.Lifecycle$Event) -> do
    void dispatchCreate(androidx.lifecycle.ReportFragment$ActivityInitializationListener) -> do
    void injectIfNeededIn(android.app.Activity) -> do
    void dispatchStart(androidx.lifecycle.ReportFragment$ActivityInitializationListener) -> for
    void dispatchResume(androidx.lifecycle.ReportFragment$ActivityInitializationListener) -> if
androidx.lifecycle.ReportFragment$ActivityInitializationListener -> androidx.lifecycle.catch$do:
    void onCreate() -> do
    void onStart() -> for
    void onResume() -> if
androidx.lifecycle.SingleGeneratedAdapterObserver -> androidx.lifecycle.SingleGeneratedAdapterObserver:
    androidx.lifecycle.GeneratedAdapter mGeneratedAdapter -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.lifecycle.ViewModel -> androidx.lifecycle.class:
    java.util.Map mBagOfTags -> do
    void clear() -> do
    void closeWithRuntimeException(java.lang.Object) -> do
    void onCleared() -> if
androidx.lifecycle.ViewModelProvider -> androidx.lifecycle.const:
    androidx.lifecycle.ViewModelStore mViewModelStore -> if
    androidx.lifecycle.ViewModelProvider$Factory mFactory -> do
    androidx.lifecycle.ViewModel get(java.lang.Class) -> do
    androidx.lifecycle.ViewModel get(java.lang.String,java.lang.Class) -> do
androidx.lifecycle.ViewModelProvider$Factory -> androidx.lifecycle.const$do:
    androidx.lifecycle.ViewModel create(java.lang.Class) -> do
androidx.lifecycle.ViewModelProvider$KeyedFactory -> androidx.lifecycle.const$if:
    androidx.lifecycle.ViewModel create(java.lang.Class) -> do
    androidx.lifecycle.ViewModel create(java.lang.String,java.lang.Class) -> do
androidx.lifecycle.ViewModelStore -> androidx.lifecycle.final:
    java.util.HashMap mMap -> do
    void clear() -> do
    androidx.lifecycle.ViewModel get(java.lang.String) -> do
    void put(java.lang.String,androidx.lifecycle.ViewModel) -> do
androidx.lifecycle.ViewModelStoreOwner -> androidx.lifecycle.float:
    androidx.lifecycle.ViewModelStore getViewModelStore() -> new
androidx.loader.app.LoaderManager -> if.else.do.do:
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    androidx.loader.app.LoaderManager getInstance(androidx.lifecycle.LifecycleOwner) -> do
    void markForRedelivery() -> do
androidx.loader.app.LoaderManagerImpl -> if.else.do.if:
    boolean DEBUG -> for
    androidx.loader.app.LoaderManagerImpl$LoaderViewModel mLoaderViewModel -> if
    androidx.lifecycle.LifecycleOwner mLifecycleOwner -> do
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    void markForRedelivery() -> do
androidx.loader.app.LoaderManagerImpl$LoaderInfo -> if.else.do.if$do:
    android.os.Bundle mArgs -> goto
    int mId -> else
    androidx.loader.app.LoaderManagerImpl$LoaderObserver mObserver -> void
    androidx.loader.content.Loader mLoader -> long
    androidx.loader.content.Loader mPriorLoader -> break
    androidx.lifecycle.LifecycleOwner mLifecycleOwner -> this
    androidx.loader.content.Loader destroy(boolean) -> do
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    void onActive() -> do
    void removeObserver(androidx.lifecycle.Observer) -> do
    void setValue(java.lang.Object) -> do
    void markForRedelivery() -> for
    void onInactive() -> if
androidx.loader.app.LoaderManagerImpl$LoaderObserver -> if.else.do.if$if:
androidx.loader.app.LoaderManagerImpl$LoaderViewModel -> if.else.do.if$for:
    androidx.lifecycle.ViewModelProvider$Factory FACTORY -> for
    androidx.collection.SparseArrayCompat mLoaders -> if
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    androidx.loader.app.LoaderManagerImpl$LoaderViewModel getInstance(androidx.lifecycle.ViewModelStore) -> do
    void markForRedelivery() -> for
    void onCleared() -> if
androidx.loader.app.LoaderManagerImpl$LoaderViewModel$1 -> if.else.do.if$for$do:
    androidx.lifecycle.ViewModel create(java.lang.Class) -> do
androidx.loader.content.Loader -> if.else.if.do:
    boolean cancelLoad() -> do
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> do
    void startLoading() -> for
    void reset() -> if
    void stopLoading() -> int
androidx.media.AudioAttributesCompat -> androidx.media.AudioAttributesCompat:
    android.util.SparseIntArray SUPPRESSIBLE_USAGES -> if
    androidx.media.AudioAttributesImpl mImpl -> do
    int toVolumeStreamType(boolean,int,int) -> do
    java.lang.String usageToString(int) -> do
androidx.media.AudioAttributesImpl -> androidx.media.do:
androidx.media.AudioAttributesImplApi21 -> androidx.media.if:
    int mLegacyStreamType -> if
    android.media.AudioAttributes mAudioAttributes -> do
androidx.media.AudioAttributesImplBase -> androidx.media.for:
    int mContentType -> if
    int mLegacyStream -> int
    int mUsage -> do
    int mFlags -> for
    int getContentType() -> do
    int getLegacyStreamType() -> for
    int getFlags() -> if
    int getUsage() -> int
androidx.recyclerview.R$attr -> if.goto.do:
androidx.recyclerview.R$dimen -> if.goto.if:
androidx.recyclerview.R$styleable -> if.goto.for:
androidx.recyclerview.widget.AdapterHelper -> androidx.recyclerview.widget.do:
    androidx.core.util.Pools$Pool mUpdateOpPool -> do
    java.util.ArrayList mPendingUpdates -> if
    androidx.recyclerview.widget.AdapterHelper$Callback mCallback -> int
    androidx.recyclerview.widget.OpReorderer mOpReorderer -> byte
    java.util.ArrayList mPostponedList -> for
    boolean mDisableRecycler -> try
    int mExistingUpdateTypes -> case
    java.lang.Runnable mOnItemProcessedCallback -> new
    void postponeAndUpdateViewHolders(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> byte
    int applyPendingUpdatesToPosition(int) -> do
    void consumePostponedUpdates() -> do
    void dispatchFirstPassAndUpdateViewHolders(androidx.recyclerview.widget.AdapterHelper$UpdateOp,int) -> do
    int findPositionOffset(int,int) -> do
    androidx.recyclerview.widget.AdapterHelper$UpdateOp obtainUpdateOp(int,int,int,java.lang.Object) -> do
    void recycleUpdateOp(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> do
    void recycleUpdateOpsAndClearList(java.util.List) -> do
    void applyMove(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> for
    boolean hasAnyUpdateTypes(int) -> for
    boolean hasPendingUpdates() -> for
    void applyAdd(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> if
    void consumeUpdatesInOnePass() -> if
    int findPositionOffset(int) -> if
    int updatePositionWithPostponed(int,int) -> if
    void applyRemove(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> int
    boolean canFindInPreLayout(int) -> int
    boolean hasUpdates() -> int
    void applyUpdate(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> new
    void preProcess() -> new
    void dispatchAndUpdateViewHolders(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> try
    void reset() -> try
androidx.recyclerview.widget.AdapterHelper$Callback -> androidx.recyclerview.widget.do$do:
    androidx.recyclerview.widget.RecyclerView$ViewHolder findViewHolder(int) -> do
    void markViewHoldersUpdated(int,int,java.lang.Object) -> do
    void offsetPositionsForMove(int,int) -> do
    void onDispatchSecondPass(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> do
    void offsetPositionsForRemovingInvisible(int,int) -> for
    void offsetPositionsForAdd(int,int) -> if
    void onDispatchFirstPass(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> if
    void offsetPositionsForRemovingLaidOutOrNewView(int,int) -> int
androidx.recyclerview.widget.AdapterHelper$UpdateOp -> androidx.recyclerview.widget.do$if:
    int positionStart -> if
    int itemCount -> int
    java.lang.Object payload -> for
    int cmd -> do
    java.lang.String cmdToString() -> do
androidx.recyclerview.widget.ChildHelper -> androidx.recyclerview.widget.if:
    androidx.recyclerview.widget.ChildHelper$Callback mCallback -> do
    java.util.List mHiddenViews -> for
    androidx.recyclerview.widget.ChildHelper$Bucket mBucket -> if
    void hideViewInternal(android.view.View) -> byte
    boolean unhideViewInternal(android.view.View) -> case
    void addView(android.view.View,int,boolean) -> do
    void addView(android.view.View,boolean) -> do
    void attachViewToParent(android.view.View,int,android.view.ViewGroup$LayoutParams,boolean) -> do
    void detachViewFromParent(int) -> do
    int getChildCount() -> do
    void hide(android.view.View) -> do
    android.view.View getChildAt(int) -> for
    boolean isHidden(android.view.View) -> for
    void removeAllViewsUnfiltered() -> for
    android.view.View findHiddenNonRemovedView(int) -> if
    int getUnfilteredChildCount() -> if
    int indexOfChild(android.view.View) -> if
    android.view.View getUnfilteredChildAt(int) -> int
    void removeView(android.view.View) -> int
    void removeViewAt(int) -> new
    boolean removeViewIfHidden(android.view.View) -> new
    int getOffset(int) -> try
    void unhide(android.view.View) -> try
androidx.recyclerview.widget.ChildHelper$Bucket -> androidx.recyclerview.widget.if$do:
    long mData -> do
    androidx.recyclerview.widget.ChildHelper$Bucket mNext -> if
    void clear(int) -> do
    void insert(int,boolean) -> do
    void reset() -> do
    boolean get(int) -> for
    int countOnesBefore(int) -> if
    void ensureNext() -> if
    boolean remove(int) -> int
    void set(int) -> new
androidx.recyclerview.widget.ChildHelper$Callback -> androidx.recyclerview.widget.if$if:
    void addView(android.view.View,int) -> do
    void attachViewToParent(android.view.View,int,android.view.ViewGroup$LayoutParams) -> do
    android.view.View getChildAt(int) -> do
    int getChildCount() -> do
    void onLeftHiddenState(android.view.View) -> do
    int indexOfChild(android.view.View) -> for
    void removeViewAt(int) -> for
    void detachViewFromParent(int) -> if
    void onEnteredHiddenState(android.view.View) -> if
    void removeAllViews() -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder getChildViewHolder(android.view.View) -> int
androidx.recyclerview.widget.DefaultItemAnimator -> androidx.recyclerview.widget.for:
    java.util.ArrayList mAddAnimations -> break
    java.util.ArrayList mMovesList -> this
    java.util.ArrayList mPendingChanges -> goto
    java.util.ArrayList mChangeAnimations -> const
    java.util.ArrayList mPendingMoves -> else
    java.util.ArrayList mAdditionsList -> long
    java.util.ArrayList mChangesList -> void
    java.util.ArrayList mRemoveAnimations -> class
    java.util.ArrayList mMoveAnimations -> catch
    java.util.ArrayList mPendingAdditions -> char
    java.util.ArrayList mPendingRemovals -> case
    android.animation.TimeInterpolator sDefaultInterpolator -> final
    boolean animateRemove(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> byte
    boolean isRunning() -> byte
    void runPendingAnimations() -> char
    boolean animateChange(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ViewHolder,int,int,int,int) -> do
    void animateChangeImpl(androidx.recyclerview.widget.DefaultItemAnimator$ChangeInfo) -> do
    boolean animateMove(androidx.recyclerview.widget.RecyclerView$ViewHolder,int,int,int,int) -> do
    boolean canReuseUpdatedViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder,java.util.List) -> do
    void cancelAll(java.util.List) -> do
    void endChangeAnimation(java.util.List,androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    boolean endChangeAnimationIfNecessary(androidx.recyclerview.widget.DefaultItemAnimator$ChangeInfo,androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    void dispatchFinishedWhenDone() -> else
    void animateAddImpl(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> float
    void endAnimation(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> for
    void animateMoveImpl(androidx.recyclerview.widget.RecyclerView$ViewHolder,int,int,int,int) -> if
    void endAnimations() -> if
    void endChangeAnimationIfNecessary(androidx.recyclerview.widget.DefaultItemAnimator$ChangeInfo) -> if
    void animateRemoveImpl(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> short
    void resetAnimation(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> super
    boolean animateAdd(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> try
androidx.recyclerview.widget.DefaultItemAnimator$1 -> androidx.recyclerview.widget.for$do:
    java.util.ArrayList val$moves -> if
    androidx.recyclerview.widget.DefaultItemAnimator this$0 -> for
androidx.recyclerview.widget.DefaultItemAnimator$2 -> androidx.recyclerview.widget.for$if:
    java.util.ArrayList val$changes -> if
    androidx.recyclerview.widget.DefaultItemAnimator this$0 -> for
androidx.recyclerview.widget.DefaultItemAnimator$3 -> androidx.recyclerview.widget.for$for:
    java.util.ArrayList val$additions -> if
    androidx.recyclerview.widget.DefaultItemAnimator this$0 -> for
androidx.recyclerview.widget.DefaultItemAnimator$4 -> androidx.recyclerview.widget.for$int:
    android.view.View val$view -> for
    androidx.recyclerview.widget.DefaultItemAnimator this$0 -> int
    android.view.ViewPropertyAnimator val$animation -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder val$holder -> do
androidx.recyclerview.widget.DefaultItemAnimator$5 -> androidx.recyclerview.widget.for$new:
    androidx.recyclerview.widget.DefaultItemAnimator this$0 -> int
    android.view.ViewPropertyAnimator val$animation -> for
    android.view.View val$view -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder val$holder -> do
androidx.recyclerview.widget.DefaultItemAnimator$6 -> androidx.recyclerview.widget.for$try:
    android.view.View val$view -> for
    int val$deltaX -> if
    int val$deltaY -> int
    androidx.recyclerview.widget.DefaultItemAnimator this$0 -> try
    androidx.recyclerview.widget.RecyclerView$ViewHolder val$holder -> do
    android.view.ViewPropertyAnimator val$animation -> new
androidx.recyclerview.widget.DefaultItemAnimator$7 -> androidx.recyclerview.widget.for$byte:
    android.view.View val$view -> for
    androidx.recyclerview.widget.DefaultItemAnimator this$0 -> int
    androidx.recyclerview.widget.DefaultItemAnimator$ChangeInfo val$changeInfo -> do
    android.view.ViewPropertyAnimator val$oldViewAnim -> if
androidx.recyclerview.widget.DefaultItemAnimator$8 -> androidx.recyclerview.widget.for$case:
    android.view.View val$newView -> for
    androidx.recyclerview.widget.DefaultItemAnimator this$0 -> int
    androidx.recyclerview.widget.DefaultItemAnimator$ChangeInfo val$changeInfo -> do
    android.view.ViewPropertyAnimator val$newViewAnimation -> if
androidx.recyclerview.widget.DefaultItemAnimator$ChangeInfo -> androidx.recyclerview.widget.for$char:
    androidx.recyclerview.widget.RecyclerView$ViewHolder newHolder -> if
    int fromY -> int
    int fromX -> for
    int toX -> new
    int toY -> try
    androidx.recyclerview.widget.RecyclerView$ViewHolder oldHolder -> do
androidx.recyclerview.widget.DefaultItemAnimator$MoveInfo -> androidx.recyclerview.widget.for$else:
    int fromX -> if
    int toX -> int
    int fromY -> for
    int toY -> new
    androidx.recyclerview.widget.RecyclerView$ViewHolder holder -> do
androidx.recyclerview.widget.FastScroller -> androidx.recyclerview.widget.int:
    android.graphics.drawable.Drawable mVerticalTrackDrawable -> int
    boolean mNeedVerticalScrollbar -> float
    int[] PRESSED_STATE_SET -> static
    androidx.recyclerview.widget.RecyclerView$OnScrollListener mOnScrollListener -> return
    int mScrollbarMinimumRange -> do
    android.graphics.drawable.StateListDrawable mHorizontalThumbDrawable -> byte
    float mHorizontalDragX -> catch
    int mVerticalThumbHeight -> goto
    androidx.recyclerview.widget.RecyclerView mRecyclerView -> final
    int[] mHorizontalRange -> double
    int mVerticalThumbCenterY -> long
    int mHorizontalTrackHeight -> else
    java.lang.Runnable mHideRunnable -> public
    float mVerticalDragY -> this
    android.graphics.drawable.StateListDrawable mVerticalThumbDrawable -> for
    int mHorizontalThumbCenterX -> break
    int mRecyclerViewWidth -> class
    boolean mNeedHorizontalScrollbar -> short
    int[] EMPTY_STATE_SET -> switch
    int mDragState -> throw
    int mVerticalTrackWidth -> try
    int mRecyclerViewHeight -> const
    int mHorizontalThumbWidth -> void
    int mState -> super
    int mMargin -> if
    int mAnimationState -> native
    android.graphics.drawable.Drawable mHorizontalTrackDrawable -> case
    int[] mVerticalRange -> while
    android.animation.ValueAnimator mShowHideAnimator -> import
    int mVerticalThumbWidth -> new
    int mHorizontalThumbHeight -> char
    boolean isLayoutRTL() -> byte
    void setupCallbacks() -> case
    void attachToRecyclerView(androidx.recyclerview.widget.RecyclerView) -> do
    void drawHorizontalScrollbar(android.graphics.Canvas) -> do
    void hide(int) -> do
    void horizontalScrollTo(float) -> do
    boolean isPointInsideHorizontalThumb(float,float) -> do
    boolean onInterceptTouchEvent(androidx.recyclerview.widget.RecyclerView,android.view.MotionEvent) -> do
    void onRequestDisallowInterceptTouchEvent(boolean) -> do
    void requestRedraw() -> do
    int scrollTo(float,float,int[],int,int,int) -> do
    void updateScrollPosition(int,int) -> do
    void cancelHide() -> for
    void resetHideDelay(int) -> for
    void drawVerticalScrollbar(android.graphics.Canvas) -> if
    boolean isPointInsideVerticalThumb(float,float) -> if
    void onDrawOver(android.graphics.Canvas,androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State) -> if
    void onTouchEvent(androidx.recyclerview.widget.RecyclerView,android.view.MotionEvent) -> if
    void setState(int) -> if
    void show() -> if
    void verticalScrollTo(float) -> if
    void destroyCallbacks() -> int
    int[] getHorizontalRange() -> new
    int[] getVerticalRange() -> try
androidx.recyclerview.widget.FastScroller$1 -> androidx.recyclerview.widget.int$do:
    androidx.recyclerview.widget.FastScroller this$0 -> if
androidx.recyclerview.widget.FastScroller$2 -> androidx.recyclerview.widget.int$if:
    androidx.recyclerview.widget.FastScroller this$0 -> do
    void onScrolled(androidx.recyclerview.widget.RecyclerView,int,int) -> do
androidx.recyclerview.widget.FastScroller$AnimatorListener -> androidx.recyclerview.widget.int$for:
    boolean mCanceled -> do
    androidx.recyclerview.widget.FastScroller this$0 -> if
androidx.recyclerview.widget.FastScroller$AnimatorUpdater -> androidx.recyclerview.widget.int$int:
    androidx.recyclerview.widget.FastScroller this$0 -> do
androidx.recyclerview.widget.GapWorker -> androidx.recyclerview.widget.new:
    long mPostTimeNs -> for
    java.util.ArrayList mRecyclerViews -> if
    java.util.Comparator sTaskComparator -> byte
    java.lang.ThreadLocal sGapWorker -> try
    long mFrameIntervalNs -> int
    java.util.ArrayList mTasks -> new
    void add(androidx.recyclerview.widget.RecyclerView) -> do
    void buildTaskList() -> do
    void flushTaskWithDeadline(androidx.recyclerview.widget.GapWorker$Task,long) -> do
    boolean isPrefetchPositionAttached(androidx.recyclerview.widget.RecyclerView,int) -> do
    void postFromTraversal(androidx.recyclerview.widget.RecyclerView,int,int) -> do
    void prefetch(long) -> do
    void prefetchInnerRecyclerViewWithDeadline(androidx.recyclerview.widget.RecyclerView,long) -> do
    androidx.recyclerview.widget.RecyclerView$ViewHolder prefetchPositionWithDeadline(androidx.recyclerview.widget.RecyclerView,int,long) -> do
    void flushTasksWithDeadline(long) -> if
    void remove(androidx.recyclerview.widget.RecyclerView) -> if
androidx.recyclerview.widget.GapWorker$1 -> androidx.recyclerview.widget.new$do:
    int compare(androidx.recyclerview.widget.GapWorker$Task,androidx.recyclerview.widget.GapWorker$Task) -> do
androidx.recyclerview.widget.GapWorker$LayoutPrefetchRegistryImpl -> androidx.recyclerview.widget.new$if:
    int mPrefetchDy -> if
    int mCount -> int
    int[] mPrefetchArray -> for
    int mPrefetchDx -> do
    void addPosition(int,int) -> do
    void clearPrefetchPositions() -> do
    void collectPrefetchPositionsFromView(androidx.recyclerview.widget.RecyclerView,boolean) -> do
    boolean lastPrefetchIncludedPosition(int) -> do
    void setPrefetchVector(int,int) -> if
androidx.recyclerview.widget.GapWorker$Task -> androidx.recyclerview.widget.new$for:
    boolean immediate -> do
    int viewVelocity -> if
    int distanceToItem -> for
    int position -> new
    androidx.recyclerview.widget.RecyclerView view -> int
    void clear() -> do
androidx.recyclerview.widget.GridLayoutManager -> androidx.recyclerview.widget.GridLayoutManager:
    android.util.SparseIntArray mPreLayoutSpanSizeCache -> abstract
    int[] mCachedBorders -> package
    android.util.SparseIntArray mPreLayoutSpanIndexCache -> continue
    int mSpanCount -> finally
    android.view.View[] mSet -> private
    boolean mUsingSpansToEstimateScrollBarDimensions -> interface
    boolean mPendingSpanCountChange -> extends
    android.graphics.Rect mDecorInsets -> volatile
    androidx.recyclerview.widget.GridLayoutManager$SpanSizeLookup mSpanSizeLookup -> strictfp
    void onLayoutCompleted(androidx.recyclerview.widget.RecyclerView$State) -> byte
    int getSpaceForSpanRange(int,int) -> case
    void assignSpans(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int,boolean) -> do
    int[] calculateItemBorders(int[],int,int) -> do
    boolean checkLayoutParams(androidx.recyclerview.widget.RecyclerView$LayoutParams) -> do
    void collectPrefetchPositionsForLayoutState(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$LayoutState,androidx.recyclerview.widget.RecyclerView$LayoutManager$LayoutPrefetchRegistry) -> do
    android.view.View findReferenceChild(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int,int,int) -> do
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateLayoutParams(android.content.Context,android.util.AttributeSet) -> do
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> do
    int getColumnCountForAccessibility(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    int getSpanGroupIndex(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int) -> do
    void guessMeasurement(float,int) -> do
    void layoutChunk(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$LayoutState,androidx.recyclerview.widget.LinearLayoutManager$LayoutChunkResult) -> do
    void measureChildWithDecorationsAndMargin(android.view.View,int,int,boolean) -> do
    void onAnchorReady(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo,int) -> do
    android.view.View onFocusSearchFailed(android.view.View,int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    void onInitializeAccessibilityNodeInfoForItem(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onItemsAdded(androidx.recyclerview.widget.RecyclerView,int,int) -> do
    void onItemsMoved(androidx.recyclerview.widget.RecyclerView,int,int,int) -> do
    void onItemsUpdated(androidx.recyclerview.widget.RecyclerView,int,int,java.lang.Object) -> do
    int scrollHorizontallyBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    void setMeasuredDimension(android.graphics.Rect,int,int) -> do
    int computeHorizontalScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> for
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateDefaultLayoutParams() -> for
    int getSpanSize(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int) -> for
    int computeHorizontalScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> if
    void ensureAnchorIsInCorrectSpan(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo,int) -> if
    int getRowCountForAccessibility(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> if
    int getSpanIndex(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int) -> if
    void measureChild(android.view.View,int,boolean) -> if
    void onItemsRemoved(androidx.recyclerview.widget.RecyclerView,int,int) -> if
    int scrollVerticallyBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> if
    void setStackFromEnd(boolean) -> if
    int getSpanCount() -> implements
    void cachePreLayoutSpanMapping() -> instanceof
    void onItemsChanged(androidx.recyclerview.widget.RecyclerView) -> int
    int computeScrollOffsetWithSpanInfo(androidx.recyclerview.widget.RecyclerView$State) -> long
    void setSpanCount(int) -> long
    int computeVerticalScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> new
    void onLayoutChildren(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> new
    boolean supportsPredictiveItemAnimations() -> static
    void clearPreLayoutSpanMappingCache() -> synchronized
    void calculateItemBorders(int) -> this
    int computeScrollRangeWithSpanInfo(androidx.recyclerview.widget.RecyclerView$State) -> this
    int computeVerticalScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> try
    void ensureViewSet() -> ʻ
    void updateMeasurements() -> ʼ
androidx.recyclerview.widget.GridLayoutManager$DefaultSpanSizeLookup -> androidx.recyclerview.widget.GridLayoutManager$do:
    int getSpanSize(int) -> do
    int getSpanIndex(int,int) -> int
androidx.recyclerview.widget.GridLayoutManager$LayoutParams -> androidx.recyclerview.widget.GridLayoutManager$if:
    int mSpanIndex -> new
    int mSpanSize -> try
    int getSpanIndex() -> new
    int getSpanSize() -> try
androidx.recyclerview.widget.GridLayoutManager$SpanSizeLookup -> androidx.recyclerview.widget.GridLayoutManager$for:
    boolean mCacheSpanIndices -> for
    boolean mCacheSpanGroupIndices -> int
    android.util.SparseIntArray mSpanIndexCache -> do
    android.util.SparseIntArray mSpanGroupIndexCache -> if
    int findFirstKeyLessThan(android.util.SparseIntArray,int) -> do
    int getCachedSpanGroupIndex(int,int) -> do
    int getSpanSize(int) -> do
    void invalidateSpanGroupIndexCache() -> do
    int getSpanGroupIndex(int,int) -> for
    int getCachedSpanIndex(int,int) -> if
    void invalidateSpanIndexCache() -> if
    int getSpanIndex(int,int) -> int
androidx.recyclerview.widget.LayoutState -> androidx.recyclerview.widget.try:
    boolean mRecycle -> do
    int mAvailable -> if
    int mItemDirection -> int
    boolean mStopInFocusable -> case
    int mCurrentPosition -> for
    int mEndLine -> byte
    int mLayoutDirection -> new
    int mStartLine -> try
    boolean mInfinite -> char
    boolean hasMore(androidx.recyclerview.widget.RecyclerView$State) -> do
    android.view.View next(androidx.recyclerview.widget.RecyclerView$Recycler) -> do
androidx.recyclerview.widget.LinearLayoutManager -> androidx.recyclerview.widget.LinearLayoutManager:
    boolean mShouldReverseLayout -> while
    androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo mAnchorInfo -> switch
    boolean mStackFromEnd -> double
    androidx.recyclerview.widget.LinearLayoutManager$LayoutState mLayoutState -> float
    androidx.recyclerview.widget.OrientationHelper mOrientationHelper -> short
    boolean mSmoothScrollbarEnabled -> import
    boolean mRecycleChildrenOnDetach -> return
    androidx.recyclerview.widget.LinearLayoutManager$LayoutChunkResult mLayoutChunkResult -> throws
    boolean mLastStackFromEnd -> super
    int mPendingScrollPosition -> native
    int mOrientation -> final
    int[] mReusableIntPair -> default
    int mInitialPrefetchItemCount -> boolean
    int mPendingScrollPositionOffset -> public
    boolean mReverseLayout -> throw
    androidx.recyclerview.widget.LinearLayoutManager$SavedState mPendingSavedState -> static
    android.view.View findFirstPartiallyOrCompletelyInvisibleChild() -> abstract
    int findFirstVisibleItemPosition() -> boolean
    android.view.View findLastReferenceChild(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> byte
    void onLayoutCompleted(androidx.recyclerview.widget.RecyclerView$State) -> byte
    void updateLayoutStateToFillStart(int,int) -> byte
    android.view.View findReferenceChildClosestToEnd(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> case
    int getExtraLayoutSpace(androidx.recyclerview.widget.RecyclerView$State) -> case
    int computeScrollExtent(androidx.recyclerview.widget.RecyclerView$State) -> char
    android.view.View findReferenceChildClosestToStart(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> char
    void scrollToPosition(int) -> char
    android.view.View findLastPartiallyOrCompletelyInvisibleChild() -> continue
    int findLastVisibleItemPosition() -> default
    void assertNotInLayoutOrScroll(java.lang.String) -> do
    void calculateExtraLayoutSpace(androidx.recyclerview.widget.RecyclerView$State,int[]) -> do
    boolean canScrollHorizontally() -> do
    void collectAdjacentPrefetchPositions(int,int,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$LayoutManager$LayoutPrefetchRegistry) -> do
    void collectInitialPrefetchPositions(int,androidx.recyclerview.widget.RecyclerView$LayoutManager$LayoutPrefetchRegistry) -> do
    void collectPrefetchPositionsForLayoutState(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$LayoutState,androidx.recyclerview.widget.RecyclerView$LayoutManager$LayoutPrefetchRegistry) -> do
    int computeHorizontalScrollExtent(androidx.recyclerview.widget.RecyclerView$State) -> do
    android.graphics.PointF computeScrollVectorForPosition(int) -> do
    int fill(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.LinearLayoutManager$LayoutState,androidx.recyclerview.widget.RecyclerView$State,boolean) -> do
    android.view.View findFirstVisibleChildClosestToEnd(boolean,boolean) -> do
    android.view.View findOneVisibleChild(int,int,boolean,boolean) -> do
    android.view.View findReferenceChild(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int,int,int) -> do
    int fixLayoutEndGap(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,boolean) -> do
    void layoutChunk(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$LayoutState,androidx.recyclerview.widget.LinearLayoutManager$LayoutChunkResult) -> do
    void onAnchorReady(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo,int) -> do
    android.view.View onFocusSearchFailed(android.view.View,int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    void onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    void recycleByLayoutState(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.LinearLayoutManager$LayoutState) -> do
    void recycleChildren(androidx.recyclerview.widget.RecyclerView$Recycler,int,int) -> do
    int scrollHorizontallyBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    void setReverseLayout(boolean) -> do
    void smoothScrollToPosition(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State,int) -> do
    boolean updateAnchorFromChildren(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo) -> do
    boolean updateAnchorFromPendingData(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo) -> do
    void updateLayoutState(int,int,boolean,androidx.recyclerview.widget.RecyclerView$State) -> do
    void updateLayoutStateToFillEnd(androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo) -> do
    android.os.Parcelable onSaveInstanceState() -> double
    int computeScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> else
    int convertFocusDirectionToLayoutDirection(int) -> else
    int getOrientation() -> extends
    boolean isLayoutRTL() -> finally
    int computeHorizontalScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> for
    android.view.View findViewByPosition(int) -> for
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateDefaultLayoutParams() -> for
    void recycleViewsFromStart(androidx.recyclerview.widget.RecyclerView$Recycler,int,int) -> for
    int scrollBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> for
    int computeScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> goto
    void setOrientation(int) -> goto
    boolean canScrollVertically() -> if
    int computeHorizontalScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> if
    android.view.View findFirstVisibleChildClosestToStart(boolean,boolean) -> if
    int fixLayoutStartGap(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,boolean) -> if
    void layoutForPredictiveAnimations(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int,int) -> if
    void onDetachedFromWindow(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$Recycler) -> if
    void recycleViewsFromEnd(androidx.recyclerview.widget.RecyclerView$Recycler,int,int) -> if
    int scrollVerticallyBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> if
    void setStackFromEnd(boolean) -> if
    void updateAnchorInfoForLayout(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo) -> if
    void updateLayoutStateToFillStart(androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo) -> if
    int computeVerticalScrollExtent(androidx.recyclerview.widget.RecyclerView$State) -> int
    android.view.View getChildClosestToEnd() -> interface
    int computeVerticalScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> new
    android.view.View findOnePartiallyOrCompletelyInvisibleChild(int,int) -> new
    void onLayoutChildren(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> new
    boolean isSmoothScrollbarEnabled() -> package
    boolean resolveIsInfinite() -> private
    android.view.View getChildClosestToStart() -> protected
    boolean shouldMeasureTwice() -> public
    boolean supportsPredictiveItemAnimations() -> static
    android.view.View findPartiallyOrCompletelyInvisibleChildClosestToEnd() -> strictfp
    boolean isAutoMeasureEnabled() -> super
    androidx.recyclerview.widget.LinearLayoutManager$LayoutState createLayoutState() -> switch
    void ensureLayoutState() -> throws
    void resolveShouldLayoutReverse() -> transient
    int computeVerticalScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> try
    android.view.View findFirstReferenceChild(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> try
    void updateLayoutStateToFillEnd(int,int) -> try
    android.view.View findPartiallyOrCompletelyInvisibleChildClosestToStart() -> volatile
androidx.recyclerview.widget.LinearLayoutManager$AnchorInfo -> androidx.recyclerview.widget.LinearLayoutManager$do:
    int mPosition -> if
    androidx.recyclerview.widget.OrientationHelper mOrientationHelper -> do
    boolean mLayoutFromEnd -> int
    boolean mValid -> new
    int mCoordinate -> for
    void assignCoordinateFromPadding() -> do
    void assignFromView(android.view.View,int) -> do
    boolean isViewValidAsAnchor(android.view.View,androidx.recyclerview.widget.RecyclerView$State) -> do
    void assignFromViewAndKeepVisibleRect(android.view.View,int) -> if
    void reset() -> if
androidx.recyclerview.widget.LinearLayoutManager$LayoutChunkResult -> androidx.recyclerview.widget.LinearLayoutManager$if:
    boolean mIgnoreConsumed -> for
    boolean mFocusable -> int
    boolean mFinished -> if
    int mConsumed -> do
    void resetInternal() -> do
androidx.recyclerview.widget.LinearLayoutManager$LayoutState -> androidx.recyclerview.widget.LinearLayoutManager$for:
    boolean mRecycle -> do
    boolean mInfinite -> this
    int mLayoutDirection -> try
    int mLastScrollDelta -> goto
    java.util.List mScrapList -> long
    int mOffset -> if
    int mCurrentPosition -> int
    boolean mIsPreLayout -> else
    int mAvailable -> for
    int mScrollingOffset -> byte
    int mItemDirection -> new
    int mNoRecycleSpace -> char
    int mExtraFillSpace -> case
    void assignPositionFromScrapList() -> do
    void assignPositionFromScrapList(android.view.View) -> do
    boolean hasMore(androidx.recyclerview.widget.RecyclerView$State) -> do
    android.view.View next(androidx.recyclerview.widget.RecyclerView$Recycler) -> do
    android.view.View nextViewFromScrapList() -> if
    android.view.View nextViewInLimitedList(android.view.View) -> if
androidx.recyclerview.widget.LinearLayoutManager$SavedState -> androidx.recyclerview.widget.LinearLayoutManager$int:
    int mAnchorPosition -> if
    boolean mAnchorLayoutFromEnd -> int
    int mAnchorOffset -> for
    boolean hasValidAnchor() -> int
    void invalidateAnchor() -> new
androidx.recyclerview.widget.LinearLayoutManager$SavedState$1 -> androidx.recyclerview.widget.LinearLayoutManager$int$do:
androidx.recyclerview.widget.LinearSmoothScroller -> androidx.recyclerview.widget.byte:
    android.view.animation.LinearInterpolator mLinearInterpolator -> char
    int mInterimTargetDx -> break
    android.util.DisplayMetrics mDisplayMetrics -> long
    boolean mHasCalculatedMillisPerPixel -> this
    android.view.animation.DecelerateInterpolator mDecelerateInterpolator -> else
    int mInterimTargetDy -> catch
    float mMillisPerPixel -> void
    android.graphics.PointF mTargetVector -> goto
    void onStop() -> byte
    int getHorizontalSnapPreference() -> char
    int calculateDtToFit(int,int,int,int,int) -> do
    int calculateDxToMakeVisible(android.view.View,int) -> do
    float calculateSpeedPerPixel(android.util.DisplayMetrics) -> do
    void onSeekTargetStep(int,int,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$SmoothScroller$Action) -> do
    void onTargetFound(android.view.View,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$SmoothScroller$Action) -> do
    void updateActionForInterimTarget(androidx.recyclerview.widget.RecyclerView$SmoothScroller$Action) -> do
    int getVerticalSnapPreference() -> else
    float getSpeedPerPixel() -> goto
    int calculateDyToMakeVisible(android.view.View,int) -> if
    int clampApplyScroll(int,int) -> if
    int calculateTimeForDeceleration(int) -> int
    int calculateTimeForScrolling(int) -> new
    void onStart() -> try
androidx.recyclerview.widget.LinearSnapHelper -> androidx.recyclerview.widget.case:
    androidx.recyclerview.widget.OrientationHelper mHorizontalHelper -> new
    androidx.recyclerview.widget.OrientationHelper mVerticalHelper -> int
    int[] calculateDistanceToFinalSnap(androidx.recyclerview.widget.RecyclerView$LayoutManager,android.view.View) -> do
    float computeDistancePerChild(androidx.recyclerview.widget.RecyclerView$LayoutManager,androidx.recyclerview.widget.OrientationHelper) -> do
    int distanceToCenter(androidx.recyclerview.widget.RecyclerView$LayoutManager,android.view.View,androidx.recyclerview.widget.OrientationHelper) -> do
    int estimateNextPositionDiffForFling(androidx.recyclerview.widget.RecyclerView$LayoutManager,androidx.recyclerview.widget.OrientationHelper,int,int) -> do
    int findTargetSnapPosition(androidx.recyclerview.widget.RecyclerView$LayoutManager,int,int) -> do
    android.view.View findSnapView(androidx.recyclerview.widget.RecyclerView$LayoutManager) -> for
    android.view.View findCenterView(androidx.recyclerview.widget.RecyclerView$LayoutManager,androidx.recyclerview.widget.OrientationHelper) -> if
    androidx.recyclerview.widget.OrientationHelper getHorizontalHelper(androidx.recyclerview.widget.RecyclerView$LayoutManager) -> int
    androidx.recyclerview.widget.OrientationHelper getVerticalHelper(androidx.recyclerview.widget.RecyclerView$LayoutManager) -> new
androidx.recyclerview.widget.OpReorderer -> androidx.recyclerview.widget.char:
    androidx.recyclerview.widget.OpReorderer$Callback mCallback -> do
    void reorderOps(java.util.List) -> do
    void swapMoveOp(java.util.List,int,int) -> do
    void swapMoveRemove(java.util.List,int,androidx.recyclerview.widget.AdapterHelper$UpdateOp,int,androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> do
    void swapMoveAdd(java.util.List,int,androidx.recyclerview.widget.AdapterHelper$UpdateOp,int,androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> for
    int getLastMoveOutOfOrder(java.util.List) -> if
    void swapMoveUpdate(java.util.List,int,androidx.recyclerview.widget.AdapterHelper$UpdateOp,int,androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> if
androidx.recyclerview.widget.OpReorderer$Callback -> androidx.recyclerview.widget.char$do:
    androidx.recyclerview.widget.AdapterHelper$UpdateOp obtainUpdateOp(int,int,int,java.lang.Object) -> do
    void recycleUpdateOp(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> do
androidx.recyclerview.widget.OrientationHelper -> androidx.recyclerview.widget.else:
    androidx.recyclerview.widget.RecyclerView$LayoutManager mLayoutManager -> do
    int mLastTotalSpace -> if
    android.graphics.Rect mTmpRect -> for
    int getTotalSpace() -> byte
    int getTotalSpaceChange() -> case
    void onLayoutComplete() -> char
    androidx.recyclerview.widget.OrientationHelper createHorizontalHelper(androidx.recyclerview.widget.RecyclerView$LayoutManager) -> do
    androidx.recyclerview.widget.OrientationHelper createOrientationHelper(androidx.recyclerview.widget.RecyclerView$LayoutManager,int) -> do
    int getDecoratedEnd(android.view.View) -> do
    int getEnd() -> do
    void offsetChildren(int) -> do
    int getDecoratedMeasurementInOther(android.view.View) -> for
    int getEndPadding() -> for
    androidx.recyclerview.widget.OrientationHelper createVerticalHelper(androidx.recyclerview.widget.RecyclerView$LayoutManager) -> if
    int getDecoratedMeasurement(android.view.View) -> if
    int getEndAfterPadding() -> if
    int getDecoratedStart(android.view.View) -> int
    int getMode() -> int
    int getModeInOther() -> new
    int getTransformedEndWithDecoration(android.view.View) -> new
    int getStartAfterPadding() -> try
    int getTransformedStartWithDecoration(android.view.View) -> try
androidx.recyclerview.widget.OrientationHelper$1 -> androidx.recyclerview.widget.else$do:
    int getTotalSpace() -> byte
    int getDecoratedEnd(android.view.View) -> do
    int getEnd() -> do
    void offsetChildren(int) -> do
    int getDecoratedMeasurementInOther(android.view.View) -> for
    int getEndPadding() -> for
    int getDecoratedMeasurement(android.view.View) -> if
    int getEndAfterPadding() -> if
    int getDecoratedStart(android.view.View) -> int
    int getMode() -> int
    int getModeInOther() -> new
    int getTransformedEndWithDecoration(android.view.View) -> new
    int getStartAfterPadding() -> try
    int getTransformedStartWithDecoration(android.view.View) -> try
androidx.recyclerview.widget.OrientationHelper$2 -> androidx.recyclerview.widget.else$if:
    int getTotalSpace() -> byte
    int getDecoratedEnd(android.view.View) -> do
    int getEnd() -> do
    void offsetChildren(int) -> do
    int getDecoratedMeasurementInOther(android.view.View) -> for
    int getEndPadding() -> for
    int getDecoratedMeasurement(android.view.View) -> if
    int getEndAfterPadding() -> if
    int getDecoratedStart(android.view.View) -> int
    int getMode() -> int
    int getModeInOther() -> new
    int getTransformedEndWithDecoration(android.view.View) -> new
    int getStartAfterPadding() -> try
    int getTransformedStartWithDecoration(android.view.View) -> try
androidx.recyclerview.widget.RecyclerView$1 -> androidx.recyclerview.widget.RecyclerView$do:
    androidx.recyclerview.widget.RecyclerView this$0 -> if
androidx.recyclerview.widget.RecyclerView$2 -> androidx.recyclerview.widget.RecyclerView$if:
    androidx.recyclerview.widget.RecyclerView this$0 -> if
androidx.recyclerview.widget.RecyclerView$3 -> androidx.recyclerview.widget.RecyclerView$for:
androidx.recyclerview.widget.RecyclerView$4 -> androidx.recyclerview.widget.RecyclerView$int:
    androidx.recyclerview.widget.RecyclerView this$0 -> do
    void processDisappeared(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> do
    void unused(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    void processAppeared(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> for
    void processPersistent(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> if
androidx.recyclerview.widget.RecyclerView$5 -> androidx.recyclerview.widget.RecyclerView$new:
    androidx.recyclerview.widget.RecyclerView this$0 -> do
    void addView(android.view.View,int) -> do
    void attachViewToParent(android.view.View,int,android.view.ViewGroup$LayoutParams) -> do
    android.view.View getChildAt(int) -> do
    int getChildCount() -> do
    void onLeftHiddenState(android.view.View) -> do
    int indexOfChild(android.view.View) -> for
    void removeViewAt(int) -> for
    void detachViewFromParent(int) -> if
    void onEnteredHiddenState(android.view.View) -> if
    void removeAllViews() -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder getChildViewHolder(android.view.View) -> int
androidx.recyclerview.widget.RecyclerView$6 -> androidx.recyclerview.widget.RecyclerView$try:
    androidx.recyclerview.widget.RecyclerView this$0 -> do
    androidx.recyclerview.widget.RecyclerView$ViewHolder findViewHolder(int) -> do
    void markViewHoldersUpdated(int,int,java.lang.Object) -> do
    void offsetPositionsForMove(int,int) -> do
    void onDispatchSecondPass(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> do
    void dispatchUpdate(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> for
    void offsetPositionsForRemovingInvisible(int,int) -> for
    void offsetPositionsForAdd(int,int) -> if
    void onDispatchFirstPass(androidx.recyclerview.widget.AdapterHelper$UpdateOp) -> if
    void offsetPositionsForRemovingLaidOutOrNewView(int,int) -> int
androidx.recyclerview.widget.RecyclerView$Adapter -> androidx.recyclerview.widget.RecyclerView$byte:
    boolean mHasStableIds -> if
    androidx.recyclerview.widget.RecyclerView$AdapterDataObservable mObservable -> do
    void bindViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder,int) -> do
    androidx.recyclerview.widget.RecyclerView$ViewHolder createViewHolder(android.view.ViewGroup,int) -> do
    int getItemCount() -> do
    long getItemId(int) -> do
    void onAttachedToRecyclerView(androidx.recyclerview.widget.RecyclerView) -> do
    void onBindViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder,int,java.util.List) -> do
    boolean onFailedToRecycleView(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    void registerAdapterDataObserver(androidx.recyclerview.widget.RecyclerView$AdapterDataObserver) -> do
    void setHasStableIds(boolean) -> do
    boolean hasStableIds() -> for
    void onViewDetachedFromWindow(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> for
    int getItemViewType(int) -> if
    boolean hasObservers() -> if
    void onBindViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder,int) -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder onCreateViewHolder(android.view.ViewGroup,int) -> if
    void onDetachedFromRecyclerView(androidx.recyclerview.widget.RecyclerView) -> if
    void onViewAttachedToWindow(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> if
    void unregisterAdapterDataObserver(androidx.recyclerview.widget.RecyclerView$AdapterDataObserver) -> if
    void notifyDataSetChanged() -> int
    void onViewRecycled(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> int
androidx.recyclerview.widget.RecyclerView$AdapterDataObservable -> androidx.recyclerview.widget.RecyclerView$case:
    boolean hasObservers() -> do
    void notifyChanged() -> if
androidx.recyclerview.widget.RecyclerView$AdapterDataObserver -> androidx.recyclerview.widget.RecyclerView$char:
    void onChanged() -> do
androidx.recyclerview.widget.RecyclerView$ChildDrawingOrderCallback -> androidx.recyclerview.widget.RecyclerView$else:
    int onGetChildDrawingOrder(int,int) -> do
androidx.recyclerview.widget.RecyclerView$EdgeEffectFactory -> androidx.recyclerview.widget.RecyclerView$goto:
    android.widget.EdgeEffect createEdgeEffect(androidx.recyclerview.widget.RecyclerView,int) -> do
androidx.recyclerview.widget.RecyclerView$ItemAnimator -> androidx.recyclerview.widget.RecyclerView$long:
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemAnimatorListener mListener -> do
    long mAddDuration -> for
    java.util.ArrayList mFinishedListeners -> if
    long mChangeDuration -> try
    long mRemoveDuration -> int
    long mMoveDuration -> new
    boolean isRunning() -> byte
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo obtainHolderInfo() -> case
    void runPendingAnimations() -> char
    boolean animateAppearance(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> do
    boolean animateChange(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> do
    boolean canReuseUpdatedViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    boolean canReuseUpdatedViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder,java.util.List) -> do
    void dispatchAnimationsFinished() -> do
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo recordPostLayoutInformation(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo recordPreLayoutInformation(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$ViewHolder,int,java.util.List) -> do
    void setListener(androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemAnimatorListener) -> do
    boolean animatePersistence(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> for
    void endAnimation(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> for
    long getAddDuration() -> for
    boolean animateDisappearance(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> if
    void dispatchAnimationFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> if
    void endAnimations() -> if
    long getChangeDuration() -> int
    void onAnimationFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> int
    int buildAdapterChangeFlagsForAnimations(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> new
    long getMoveDuration() -> new
    long getRemoveDuration() -> try
androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemAnimatorFinishedListener -> androidx.recyclerview.widget.RecyclerView$long$do:
    void onAnimationsFinished() -> do
androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemAnimatorListener -> androidx.recyclerview.widget.RecyclerView$long$if:
    void onAnimationFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo -> androidx.recyclerview.widget.RecyclerView$long$for:
    int top -> if
    int left -> do
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo setFrom(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo setFrom(androidx.recyclerview.widget.RecyclerView$ViewHolder,int) -> do
androidx.recyclerview.widget.RecyclerView$ItemAnimatorRestoreListener -> androidx.recyclerview.widget.RecyclerView$this:
    androidx.recyclerview.widget.RecyclerView this$0 -> do
    void onAnimationFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
androidx.recyclerview.widget.RecyclerView$ItemDecoration -> androidx.recyclerview.widget.RecyclerView$void:
    void getItemOffsets(android.graphics.Rect,int,androidx.recyclerview.widget.RecyclerView) -> do
    void getItemOffsets(android.graphics.Rect,android.view.View,androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State) -> do
    void onDraw(android.graphics.Canvas,androidx.recyclerview.widget.RecyclerView) -> do
    void onDraw(android.graphics.Canvas,androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State) -> do
    void onDrawOver(android.graphics.Canvas,androidx.recyclerview.widget.RecyclerView) -> if
    void onDrawOver(android.graphics.Canvas,androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State) -> if
androidx.recyclerview.widget.RecyclerView$LayoutManager -> androidx.recyclerview.widget.RecyclerView$break:
    int mWidthMode -> break
    androidx.recyclerview.widget.RecyclerView$SmoothScroller mSmoothScroller -> byte
    boolean mRequestedSimpleAnimations -> case
    int mPrefetchMaxCountObserved -> this
    int mWidth -> class
    androidx.recyclerview.widget.ViewBoundsCheck mHorizontalBoundCheck -> new
    int mHeightMode -> catch
    androidx.recyclerview.widget.ViewBoundsCheck mVerticalBoundCheck -> try
    boolean mIsAttachedToWindow -> char
    boolean mItemPrefetchEnabled -> long
    int mHeight -> const
    boolean mAutoMeasure -> else
    androidx.recyclerview.widget.ChildHelper mChildHelper -> do
    androidx.recyclerview.widget.RecyclerView mRecyclerView -> if
    androidx.recyclerview.widget.ViewBoundsCheck$Callback mHorizontalBoundCheckCallback -> for
    boolean mPrefetchMaxObservedInInitialPrefetch -> void
    androidx.recyclerview.widget.ViewBoundsCheck$Callback mVerticalBoundCheckCallback -> int
    boolean mMeasurementCacheEnabled -> goto
    int getPaddingLeft() -> break
    void removeView(android.view.View) -> break
    int getDecoratedMeasuredHeight(android.view.View) -> byte
    android.view.View getFocusedChild() -> byte
    void onLayoutCompleted(androidx.recyclerview.widget.RecyclerView$State) -> byte
    void onScrollStateChanged(int) -> byte
    int getDecoratedMeasuredWidth(android.view.View) -> case
    int getHeight() -> case
    void removeViewAt(int) -> case
    int getPaddingRight() -> catch
    int getDecoratedRight(android.view.View) -> char
    int getHeightMode() -> char
    void scrollToPosition(int) -> char
    int getPaddingTop() -> class
    int getWidth() -> const
    void addDisappearingView(android.view.View) -> do
    void addDisappearingView(android.view.View,int) -> do
    void addViewInt(android.view.View,int,boolean) -> do
    void assertNotInLayoutOrScroll(java.lang.String) -> do
    void attachView(android.view.View,int,androidx.recyclerview.widget.RecyclerView$LayoutParams) -> do
    void calculateItemDecorationsForChild(android.view.View,android.graphics.Rect) -> do
    boolean canScrollHorizontally() -> do
    boolean checkLayoutParams(androidx.recyclerview.widget.RecyclerView$LayoutParams) -> do
    int chooseSize(int,int,int) -> do
    void collectAdjacentPrefetchPositions(int,int,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$LayoutManager$LayoutPrefetchRegistry) -> do
    void collectInitialPrefetchPositions(int,androidx.recyclerview.widget.RecyclerView$LayoutManager$LayoutPrefetchRegistry) -> do
    int computeHorizontalScrollExtent(androidx.recyclerview.widget.RecyclerView$State) -> do
    void detachAndScrapAttachedViews(androidx.recyclerview.widget.RecyclerView$Recycler) -> do
    void detachViewInternal(int,android.view.View) -> do
    void dispatchAttachedToWindow(androidx.recyclerview.widget.RecyclerView) -> do
    void dispatchDetachedFromWindow(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$Recycler) -> do
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateLayoutParams(android.content.Context,android.util.AttributeSet) -> do
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> do
    int getChildMeasureSpec(int,int,int,int,boolean) -> do
    int getColumnCountForAccessibility(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    androidx.recyclerview.widget.RecyclerView$LayoutManager$Properties getProperties(android.content.Context,android.util.AttributeSet,int,int) -> do
    void getTransformedBoundingBox(android.view.View,boolean,android.graphics.Rect) -> do
    boolean isViewPartiallyVisible(android.view.View,boolean,boolean) -> do
    void layoutDecoratedWithMargins(android.view.View,int,int,int,int) -> do
    void measureChildWithMargins(android.view.View,int,int) -> do
    void moveView(int,int) -> do
    void onAdapterChanged(androidx.recyclerview.widget.RecyclerView$Adapter,androidx.recyclerview.widget.RecyclerView$Adapter) -> do
    boolean onAddFocusables(androidx.recyclerview.widget.RecyclerView,java.util.ArrayList,int,int) -> do
    android.view.View onFocusSearchFailed(android.view.View,int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    void onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent) -> do
    void onInitializeAccessibilityEvent(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,android.view.accessibility.AccessibilityEvent) -> do
    void onInitializeAccessibilityNodeInfo(androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onInitializeAccessibilityNodeInfo(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onInitializeAccessibilityNodeInfoForItem(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onInitializeAccessibilityNodeInfoForItem(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onItemsAdded(androidx.recyclerview.widget.RecyclerView,int,int) -> do
    void onItemsMoved(androidx.recyclerview.widget.RecyclerView,int,int,int) -> do
    void onItemsUpdated(androidx.recyclerview.widget.RecyclerView,int,int,java.lang.Object) -> do
    void onMeasure(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int,int) -> do
    boolean onRequestChildFocus(androidx.recyclerview.widget.RecyclerView,android.view.View,android.view.View) -> do
    boolean onRequestChildFocus(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State,android.view.View,android.view.View) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    void onSmoothScrollerStopped(androidx.recyclerview.widget.RecyclerView$SmoothScroller) -> do
    boolean performAccessibilityAction(int,android.os.Bundle) -> do
    boolean performAccessibilityAction(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,int,android.os.Bundle) -> do
    boolean performAccessibilityActionForItem(android.view.View,int,android.os.Bundle) -> do
    boolean performAccessibilityActionForItem(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,android.view.View,int,android.os.Bundle) -> do
    void removeAndRecycleView(android.view.View,androidx.recyclerview.widget.RecyclerView$Recycler) -> do
    void removeAndRecycleViewAt(int,androidx.recyclerview.widget.RecyclerView$Recycler) -> do
    boolean removeCallbacks(java.lang.Runnable) -> do
    boolean requestChildRectangleOnScreen(androidx.recyclerview.widget.RecyclerView,android.view.View,android.graphics.Rect,boolean) -> do
    boolean requestChildRectangleOnScreen(androidx.recyclerview.widget.RecyclerView,android.view.View,android.graphics.Rect,boolean,boolean) -> do
    void scrapOrRecycleView(androidx.recyclerview.widget.RecyclerView$Recycler,int,android.view.View) -> do
    int scrollHorizontallyBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    void setMeasuredDimension(android.graphics.Rect,int,int) -> do
    boolean shouldMeasureChild(android.view.View,int,int,androidx.recyclerview.widget.RecyclerView$LayoutParams) -> do
    void smoothScrollToPosition(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State,int) -> do
    android.os.Parcelable onSaveInstanceState() -> double
    int getDecoratedTop(android.view.View) -> else
    int getItemCount() -> else
    int getWidthMode() -> final
    boolean hasFlexibleChildInBothOrientations() -> float
    void attachView(android.view.View,int) -> for
    int computeHorizontalScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> for
    android.view.View findContainingItemView(android.view.View) -> for
    android.view.View findViewByPosition(int) -> for
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateDefaultLayoutParams() -> for
    int[] getChildRectangleOnScreenScrollAmount(android.view.View,android.graphics.Rect) -> for
    int getSelectionModeForAccessibility(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> for
    void onDetachedFromWindow(androidx.recyclerview.widget.RecyclerView) -> for
    void onItemsUpdated(androidx.recyclerview.widget.RecyclerView,int,int) -> for
    void removeAndRecycleScrapInt(androidx.recyclerview.widget.RecyclerView$Recycler) -> for
    void setMeasuredDimension(int,int) -> for
    int getLayoutDirection() -> goto
    int getLeftDecorationWidth(android.view.View) -> goto
    void addView(android.view.View) -> if
    void addView(android.view.View,int) -> if
    boolean canScrollVertically() -> if
    int computeHorizontalScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> if
    void detachViewAt(int) -> if
    void getDecoratedBoundsWithMargins(android.view.View,android.graphics.Rect) -> if
    int getRowCountForAccessibility(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> if
    boolean isMeasurementUpToDate(int,int,int) -> if
    void onAttachedToWindow(androidx.recyclerview.widget.RecyclerView) -> if
    void onDetachedFromWindow(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$Recycler) -> if
    void onItemsRemoved(androidx.recyclerview.widget.RecyclerView,int,int) -> if
    void removeAndRecycleAllViews(androidx.recyclerview.widget.RecyclerView$Recycler) -> if
    int scrollVerticallyBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> if
    void setMeasureSpecs(int,int) -> if
    boolean shouldReMeasureChild(android.view.View,int,int,androidx.recyclerview.widget.RecyclerView$LayoutParams) -> if
    void startSmoothScroll(androidx.recyclerview.widget.RecyclerView$SmoothScroller) -> if
    void requestLayout() -> import
    int computeVerticalScrollExtent(androidx.recyclerview.widget.RecyclerView$State) -> int
    int getBaseline() -> int
    int getBottomDecorationHeight(android.view.View) -> int
    android.view.View getChildAt(int) -> int
    boolean isFocusedChildVisibleAfterScrolling(androidx.recyclerview.widget.RecyclerView,int,int) -> int
    boolean isLayoutHierarchical(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> int
    android.view.View onInterceptFocusSearch(android.view.View,int) -> int
    void onItemsChanged(androidx.recyclerview.widget.RecyclerView) -> int
    void setMeasuredDimensionFromChildren(int,int) -> int
    int getMinimumHeight() -> long
    int getPosition(android.view.View) -> long
    void requestSimpleAnimationsInNextLayout() -> native
    int computeVerticalScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> new
    int getChildCount() -> new
    int getDecoratedBottom(android.view.View) -> new
    void offsetChildrenHorizontal(int) -> new
    void onLayoutChildren(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> new
    void setExactMeasureSpecsFrom(androidx.recyclerview.widget.RecyclerView) -> new
    boolean shouldMeasureTwice() -> public
    void stopSmoothScroller() -> return
    boolean isAttachedToWindow() -> short
    boolean supportsPredictiveItemAnimations() -> static
    boolean isAutoMeasureEnabled() -> super
    int getMinimumWidth() -> this
    int getRightDecorationWidth(android.view.View) -> this
    boolean isItemPrefetchEnabled() -> throw
    int computeVerticalScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> try
    boolean getClipToPadding() -> try
    int getDecoratedLeft(android.view.View) -> try
    void offsetChildrenVertical(int) -> try
    void setRecyclerView(androidx.recyclerview.widget.RecyclerView) -> try
    int getPaddingBottom() -> void
    int getTopDecorationHeight(android.view.View) -> void
    boolean isSmoothScrolling() -> while
androidx.recyclerview.widget.RecyclerView$LayoutManager$1 -> androidx.recyclerview.widget.RecyclerView$break$do:
    androidx.recyclerview.widget.RecyclerView$LayoutManager this$0 -> do
    android.view.View getChildAt(int) -> do
    int getChildEnd(android.view.View) -> do
    int getParentEnd() -> do
    int getChildStart(android.view.View) -> if
    int getParentStart() -> if
androidx.recyclerview.widget.RecyclerView$LayoutManager$2 -> androidx.recyclerview.widget.RecyclerView$break$if:
    androidx.recyclerview.widget.RecyclerView$LayoutManager this$0 -> do
    android.view.View getChildAt(int) -> do
    int getChildEnd(android.view.View) -> do
    int getParentEnd() -> do
    int getChildStart(android.view.View) -> if
    int getParentStart() -> if
androidx.recyclerview.widget.RecyclerView$LayoutManager$LayoutPrefetchRegistry -> androidx.recyclerview.widget.RecyclerView$break$for:
    void addPosition(int,int) -> do
androidx.recyclerview.widget.RecyclerView$LayoutManager$Properties -> androidx.recyclerview.widget.RecyclerView$break$int:
    int spanCount -> if
    boolean reverseLayout -> for
    boolean stackFromEnd -> int
    int orientation -> do
androidx.recyclerview.widget.RecyclerView$LayoutParams -> androidx.recyclerview.widget.RecyclerView$catch:
    android.graphics.Rect mDecorInsets -> if
    boolean mInsetsDirty -> for
    boolean mPendingInvalidate -> int
    androidx.recyclerview.widget.RecyclerView$ViewHolder mViewHolder -> do
    int getViewLayoutPosition() -> do
    boolean isItemRemoved() -> for
    boolean isItemChanged() -> if
    boolean isViewInvalid() -> int
androidx.recyclerview.widget.RecyclerView$OnChildAttachStateChangeListener -> androidx.recyclerview.widget.RecyclerView$class:
    void onChildViewDetachedFromWindow(android.view.View) -> do
    void onChildViewAttachedToWindow(android.view.View) -> if
androidx.recyclerview.widget.RecyclerView$OnFlingListener -> androidx.recyclerview.widget.RecyclerView$const:
    boolean onFling(int,int) -> do
androidx.recyclerview.widget.RecyclerView$OnItemTouchListener -> androidx.recyclerview.widget.RecyclerView$final:
    boolean onInterceptTouchEvent(androidx.recyclerview.widget.RecyclerView,android.view.MotionEvent) -> do
    void onRequestDisallowInterceptTouchEvent(boolean) -> do
    void onTouchEvent(androidx.recyclerview.widget.RecyclerView,android.view.MotionEvent) -> if
androidx.recyclerview.widget.RecyclerView$OnScrollListener -> androidx.recyclerview.widget.RecyclerView$float:
    void onScrollStateChanged(androidx.recyclerview.widget.RecyclerView,int) -> do
    void onScrolled(androidx.recyclerview.widget.RecyclerView,int,int) -> do
androidx.recyclerview.widget.RecyclerView$RecycledViewPool -> androidx.recyclerview.widget.RecyclerView$short:
    int mAttachCount -> if
    android.util.SparseArray mScrap -> do
    void attach() -> do
    void factorInBindTime(int,long) -> do
    androidx.recyclerview.widget.RecyclerView$ViewHolder getRecycledView(int) -> do
    void onAdapterChanged(androidx.recyclerview.widget.RecyclerView$Adapter,androidx.recyclerview.widget.RecyclerView$Adapter,boolean) -> do
    void putRecycledView(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    long runningAverage(long,long) -> do
    boolean willBindInTime(int,long,long) -> do
    void detach() -> for
    void clear() -> if
    void factorInCreateTime(int,long) -> if
    androidx.recyclerview.widget.RecyclerView$RecycledViewPool$ScrapData getScrapDataForType(int) -> if
    boolean willCreateInTime(int,long,long) -> if
androidx.recyclerview.widget.RecyclerView$RecycledViewPool$ScrapData -> androidx.recyclerview.widget.RecyclerView$short$do:
    int mMaxScrap -> if
    long mCreateRunningAverageNs -> for
    java.util.ArrayList mScrapHeap -> do
    long mBindRunningAverageNs -> int
androidx.recyclerview.widget.RecyclerView$Recycler -> androidx.recyclerview.widget.RecyclerView$super:
    java.util.List mUnmodifiableAttachedScrap -> int
    java.util.ArrayList mChangedScrap -> if
    java.util.ArrayList mAttachedScrap -> do
    androidx.recyclerview.widget.RecyclerView this$0 -> char
    java.util.ArrayList mCachedViews -> for
    androidx.recyclerview.widget.RecyclerView$ViewCacheExtension mViewCacheExtension -> case
    int mRequestedCacheMax -> new
    androidx.recyclerview.widget.RecyclerView$RecycledViewPool mRecyclerPool -> byte
    int mViewCacheMax -> try
    void markItemDecorInsetsDirty() -> byte
    void markKnownViewsInvalid() -> case
    void recycleAndClearCachedViews() -> char
    void addViewHolderToRecycledViewPool(androidx.recyclerview.widget.RecyclerView$ViewHolder,boolean) -> do
    void clear() -> do
    int convertPreLayoutPositionToPostLayout(int) -> do
    void dispatchViewRecycled(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    androidx.recyclerview.widget.RecyclerView$ViewHolder getScrapOrCachedViewForId(long,int,boolean) -> do
    androidx.recyclerview.widget.RecyclerView$ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int,boolean) -> do
    void invalidateDisplayListInt(android.view.ViewGroup,boolean) -> do
    void offsetPositionRecordsForInsert(int,int) -> do
    void offsetPositionRecordsForRemove(int,int,boolean) -> do
    void onAdapterChanged(androidx.recyclerview.widget.RecyclerView$Adapter,androidx.recyclerview.widget.RecyclerView$Adapter,boolean) -> do
    void quickRecycleScrapView(android.view.View) -> do
    void setRecycledViewPool(androidx.recyclerview.widget.RecyclerView$RecycledViewPool) -> do
    void setViewCacheExtension(androidx.recyclerview.widget.RecyclerView$ViewCacheExtension) -> do
    boolean tryBindViewHolderByDeadline(androidx.recyclerview.widget.RecyclerView$ViewHolder,int,int,long) -> do
    androidx.recyclerview.widget.RecyclerView$ViewHolder tryGetViewHolderForPositionByDeadline(int,boolean,long) -> do
    void updateViewCacheSize() -> else
    void clearScrap() -> for
    android.view.View getScrapViewAt(int) -> for
    void scrapView(android.view.View) -> for
    void unscrapView(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> for
    void viewRangeUpdate(int,int) -> for
    void clearOldPositions() -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder getChangedScrapViewForPosition(int) -> if
    android.view.View getViewForPosition(int,boolean) -> if
    void offsetPositionRecordsForMove(int,int) -> if
    void recycleView(android.view.View) -> if
    void recycleViewHolderInternal(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> if
    androidx.recyclerview.widget.RecyclerView$RecycledViewPool getRecycledViewPool() -> int
    android.view.View getViewForPosition(int) -> int
    boolean validateViewHolderForOffsetPosition(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> int
    void attachAccessibilityDelegateOnBind(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> new
    int getScrapCount() -> new
    void recycleCachedViewAt(int) -> new
    java.util.List getScrapList() -> try
    void invalidateDisplayListInt(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> try
    void setViewCacheSize(int) -> try
androidx.recyclerview.widget.RecyclerView$RecyclerListener -> androidx.recyclerview.widget.RecyclerView$throw:
    void onViewRecycled(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
androidx.recyclerview.widget.RecyclerView$RecyclerViewDataObserver -> androidx.recyclerview.widget.RecyclerView$while:
    androidx.recyclerview.widget.RecyclerView this$0 -> do
    void onChanged() -> do
androidx.recyclerview.widget.RecyclerView$SavedState -> androidx.recyclerview.widget.RecyclerView$double:
    android.os.Parcelable mLayoutState -> int
    void copyFrom(androidx.recyclerview.widget.RecyclerView$SavedState) -> do
androidx.recyclerview.widget.RecyclerView$SavedState$1 -> androidx.recyclerview.widget.RecyclerView$double$do:
androidx.recyclerview.widget.RecyclerView$SmoothScroller -> androidx.recyclerview.widget.RecyclerView$import:
    androidx.recyclerview.widget.RecyclerView$SmoothScroller$Action mRecyclingAction -> byte
    androidx.recyclerview.widget.RecyclerView$LayoutManager mLayoutManager -> for
    boolean mStarted -> case
    boolean mPendingInitialRun -> int
    boolean mRunning -> new
    int mTargetPosition -> do
    androidx.recyclerview.widget.RecyclerView mRecyclerView -> if
    android.view.View mTargetView -> try
    void onStop() -> byte
    void stop() -> case
    android.graphics.PointF computeScrollVectorForPosition(int) -> do
    int getChildCount() -> do
    int getChildPosition(android.view.View) -> do
    void normalize(android.graphics.PointF) -> do
    void onAnimation(int,int) -> do
    void onSeekTargetStep(int,int,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$SmoothScroller$Action) -> do
    void onTargetFound(android.view.View,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$SmoothScroller$Action) -> do
    void start(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$LayoutManager) -> do
    int getTargetPosition() -> for
    void setTargetPosition(int) -> for
    android.view.View findViewByPosition(int) -> if
    androidx.recyclerview.widget.RecyclerView$LayoutManager getLayoutManager() -> if
    void onChildAttachedToWindow(android.view.View) -> if
    boolean isPendingInitialRun() -> int
    boolean isRunning() -> new
    void onStart() -> try
androidx.recyclerview.widget.RecyclerView$SmoothScroller$Action -> androidx.recyclerview.widget.RecyclerView$import$do:
    int mDy -> if
    int mJumpToPosition -> int
    int mDx -> do
    int mDuration -> for
    int mConsecutiveUpdates -> byte
    android.view.animation.Interpolator mInterpolator -> new
    boolean mChanged -> try
    boolean hasJumpTarget() -> do
    void jumpTo(int) -> do
    void runIfNecessary(androidx.recyclerview.widget.RecyclerView) -> do
    void update(int,int,int,android.view.animation.Interpolator) -> do
    void validate() -> if
androidx.recyclerview.widget.RecyclerView$SmoothScroller$ScrollVectorProvider -> androidx.recyclerview.widget.RecyclerView$import$if:
    android.graphics.PointF computeScrollVectorForPosition(int) -> do
androidx.recyclerview.widget.RecyclerView$State -> androidx.recyclerview.widget.RecyclerView$native:
    int mFocusedSubChildId -> break
    boolean mInPreLayout -> case
    int mFocusedItemPosition -> this
    int mRemainingScrollVertical -> class
    int mTargetPosition -> do
    int mRemainingScrollHorizontal -> catch
    int mItemCount -> try
    boolean mTrackOldChangeHolders -> char
    boolean mRunPredictiveAnimations -> long
    long mFocusedItemId -> void
    android.util.SparseArray mData -> if
    int mDeletedInvisibleItemCountSincePreviousLayout -> int
    boolean mIsMeasuring -> else
    int mPreviousLayoutItemCount -> for
    boolean mStructureChanged -> byte
    int mLayoutStep -> new
    boolean mRunSimpleAnimations -> goto
    void assertLayoutStep(int) -> do
    int getItemCount() -> do
    void prepareForNestedPrefetch(androidx.recyclerview.widget.RecyclerView$Adapter) -> do
    boolean hasTargetScrollPosition() -> for
    int getTargetScrollPosition() -> if
    boolean isPreLayout() -> int
    boolean willRunPredictiveAnimations() -> new
androidx.recyclerview.widget.RecyclerView$ViewCacheExtension -> androidx.recyclerview.widget.RecyclerView$public:
    android.view.View getViewForPositionAndType(androidx.recyclerview.widget.RecyclerView$Recycler,int,int) -> do
androidx.recyclerview.widget.RecyclerView$ViewFlinger -> androidx.recyclerview.widget.RecyclerView$return:
    android.widget.OverScroller mOverScroller -> int
    int mLastFlingX -> if
    int mLastFlingY -> for
    boolean mReSchedulePostAnimationCallback -> byte
    android.view.animation.Interpolator mInterpolator -> new
    androidx.recyclerview.widget.RecyclerView this$0 -> case
    boolean mEatRunOnAnimationRequest -> try
    int computeScrollDuration(int,int,int,int) -> do
    float distanceInfluenceForSnapDuration(float) -> do
    void fling(int,int) -> do
    void postOnAnimation() -> do
    void smoothScrollBy(int,int,int,android.view.animation.Interpolator) -> do
    void internalPostOnAnimation() -> for
    void stop() -> if
androidx.recyclerview.widget.RecyclerView$ViewHolder -> androidx.recyclerview.widget.RecyclerView$static:
    androidx.recyclerview.widget.RecyclerView$ViewHolder mShadowedHolder -> case
    int mIsRecyclableCount -> this
    boolean mInChangeScrap -> break
    int mPendingAccessibilityState -> class
    int mWasImportantForAccessibilityBeforeHidden -> catch
    int mItemViewType -> try
    java.util.List mUnmodifiedPayloads -> long
    int mOldPosition -> int
    androidx.recyclerview.widget.RecyclerView$Recycler mScrapContainer -> void
    android.view.View itemView -> do
    androidx.recyclerview.widget.RecyclerView mOwnerRecyclerView -> const
    int mFlags -> else
    int mPosition -> for
    androidx.recyclerview.widget.RecyclerView$ViewHolder mShadowingHolder -> char
    java.util.List mPayloads -> goto
    int mPreLayoutPosition -> byte
    long mItemId -> new
    java.util.List FULLUPDATE_PAYLOADS -> final
    java.lang.ref.WeakReference mNestedRecyclerView -> if
    boolean isInvalid() -> break
    long getItemId() -> byte
    int getItemViewType() -> case
    boolean isRecyclable() -> catch
    int getLayoutPosition() -> char
    boolean isRemoved() -> class
    boolean isScrap() -> const
    void addChangePayload(java.lang.Object) -> do
    void addFlags(int) -> do
    void clearOldPosition() -> do
    void flagRemovedAndOffsetPosition(int,int,boolean) -> do
    void offsetPosition(int,boolean) -> do
    void onEnteredHiddenState(androidx.recyclerview.widget.RecyclerView) -> do
    void setFlags(int,int) -> do
    void setIsRecyclable(boolean) -> do
    void setScrapContainer(androidx.recyclerview.widget.RecyclerView$Recycler,boolean) -> do
    boolean shouldIgnore() -> double
    int getOldPosition() -> else
    boolean isTmpDetached() -> final
    boolean isUpdated() -> float
    void clearReturnedFromScrapFlag() -> for
    java.util.List getUnmodifiedPayloads() -> goto
    void clearPayload() -> if
    boolean hasAnyOfTheFlags(int) -> if
    void onLeftHiddenState(androidx.recyclerview.widget.RecyclerView) -> if
    void unScrap() -> import
    void clearTmpDetachFlag() -> int
    boolean isAdapterPositionUnknown() -> long
    boolean wasReturnedFromScrap() -> native
    boolean doesTransientStatePreventRecycling() -> new
    void createPayloadsIfNeeded() -> public
    boolean needsUpdate() -> short
    void resetInternal() -> super
    boolean isAttachedToTransitionOverlay() -> this
    void saveOldPosition() -> throw
    int getAdapterPosition() -> try
    boolean isBound() -> void
    boolean shouldBeKeptAsChild() -> while
androidx.recyclerview.widget.RecyclerViewAccessibilityDelegate -> androidx.recyclerview.widget.goto:
    androidx.recyclerview.widget.RecyclerViewAccessibilityDelegate$ItemDelegate mItemDelegate -> new
    androidx.recyclerview.widget.RecyclerView mRecyclerView -> int
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> do
    boolean shouldIgnore() -> for
    androidx.core.view.AccessibilityDelegateCompat getItemDelegate() -> if
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> if
androidx.recyclerview.widget.RecyclerViewAccessibilityDelegate$ItemDelegate -> androidx.recyclerview.widget.goto$do:
    androidx.recyclerview.widget.RecyclerViewAccessibilityDelegate mRecyclerViewDelegate -> int
    java.util.Map mOriginalItemDelegates -> new
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> do
    androidx.core.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> do
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> do
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> do
    void sendAccessibilityEvent(android.view.View,int) -> do
    androidx.core.view.AccessibilityDelegateCompat getAndRemoveOriginalDelegateForItem(android.view.View) -> for
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> for
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> if
    void saveOriginalDelegate(android.view.View) -> int
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> int
androidx.recyclerview.widget.ScrollbarHelper -> androidx.recyclerview.widget.long:
    int computeScrollExtent(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.OrientationHelper,android.view.View,android.view.View,androidx.recyclerview.widget.RecyclerView$LayoutManager,boolean) -> do
    int computeScrollOffset(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.OrientationHelper,android.view.View,android.view.View,androidx.recyclerview.widget.RecyclerView$LayoutManager,boolean,boolean) -> do
    int computeScrollRange(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.OrientationHelper,android.view.View,android.view.View,androidx.recyclerview.widget.RecyclerView$LayoutManager,boolean) -> if
androidx.recyclerview.widget.SimpleItemAnimator -> androidx.recyclerview.widget.this:
    boolean mSupportsChangeAnimations -> byte
    void onAddStarting(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> break
    boolean animateRemove(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> byte
    void dispatchAddFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> case
    void onMoveFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> catch
    void dispatchAddStarting(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> char
    void onMoveStarting(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> class
    void onRemoveFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> const
    boolean animateAppearance(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> do
    boolean animateChange(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ViewHolder,int,int,int,int) -> do
    boolean animateChange(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> do
    boolean animateMove(androidx.recyclerview.widget.RecyclerView$ViewHolder,int,int,int,int) -> do
    boolean canReuseUpdatedViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    void dispatchChangeFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder,boolean) -> do
    void dispatchMoveFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> else
    void onRemoveStarting(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> final
    boolean animatePersistence(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> for
    void onChangeFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder,boolean) -> for
    void dispatchMoveStarting(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> goto
    boolean animateDisappearance(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> if
    void dispatchChangeStarting(androidx.recyclerview.widget.RecyclerView$ViewHolder,boolean) -> if
    void onChangeStarting(androidx.recyclerview.widget.RecyclerView$ViewHolder,boolean) -> int
    void dispatchRemoveFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> long
    void dispatchRemoveStarting(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> this
    boolean animateAdd(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> try
    void onAddFinished(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> void
androidx.recyclerview.widget.SnapHelper -> androidx.recyclerview.widget.void:
    android.widget.Scroller mGravityScroller -> if
    androidx.recyclerview.widget.RecyclerView$OnScrollListener mScrollListener -> for
    androidx.recyclerview.widget.RecyclerView mRecyclerView -> do
    void attachToRecyclerView(androidx.recyclerview.widget.RecyclerView) -> do
    int[] calculateDistanceToFinalSnap(androidx.recyclerview.widget.RecyclerView$LayoutManager,android.view.View) -> do
    androidx.recyclerview.widget.RecyclerView$SmoothScroller createScroller(androidx.recyclerview.widget.RecyclerView$LayoutManager) -> do
    int findTargetSnapPosition(androidx.recyclerview.widget.RecyclerView$LayoutManager,int,int) -> do
    boolean onFling(int,int) -> do
    void snapToTargetExistingView() -> do
    android.view.View findSnapView(androidx.recyclerview.widget.RecyclerView$LayoutManager) -> for
    void setupCallbacks() -> for
    int[] calculateScrollDistance(int,int) -> if
    androidx.recyclerview.widget.LinearSmoothScroller createSnapScroller(androidx.recyclerview.widget.RecyclerView$LayoutManager) -> if
    void destroyCallbacks() -> if
    boolean snapFromFling(androidx.recyclerview.widget.RecyclerView$LayoutManager,int,int) -> if
androidx.recyclerview.widget.SnapHelper$1 -> androidx.recyclerview.widget.void$do:
    boolean mScrolled -> do
    androidx.recyclerview.widget.SnapHelper this$0 -> if
    void onScrollStateChanged(androidx.recyclerview.widget.RecyclerView,int) -> do
    void onScrolled(androidx.recyclerview.widget.RecyclerView,int,int) -> do
androidx.recyclerview.widget.SnapHelper$2 -> androidx.recyclerview.widget.void$if:
    androidx.recyclerview.widget.SnapHelper this$0 -> class
    float calculateSpeedPerPixel(android.util.DisplayMetrics) -> do
    void onTargetFound(android.view.View,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$SmoothScroller$Action) -> do
androidx.recyclerview.widget.StaggeredGridLayoutManager -> androidx.recyclerview.widget.StaggeredGridLayoutManager:
    int[] mPrefetchDistances -> strictfp
    int mSizePerSpan -> while
    int mPendingScrollPosition -> return
    int mGapStrategy -> throws
    boolean mLastLayoutRTL -> default
    android.graphics.Rect mTmpRect -> package
    boolean mLaidOutInvalidFullSpan -> abstract
    androidx.recyclerview.widget.OrientationHelper mPrimaryOrientation -> short
    androidx.recyclerview.widget.LayoutState mLayoutState -> double
    int mFullSizeSpec -> finally
    int mOrientation -> throw
    boolean mReverseLayout -> import
    java.util.BitSet mRemainingSpans -> public
    int mPendingScrollPositionOffset -> static
    boolean mLastLayoutFromEnd -> boolean
    boolean mSmoothScrollbarEnabled -> continue
    androidx.recyclerview.widget.StaggeredGridLayoutManager$AnchorInfo mAnchorInfo -> private
    androidx.recyclerview.widget.StaggeredGridLayoutManager$Span[] mSpans -> float
    androidx.recyclerview.widget.OrientationHelper mSecondaryOrientation -> super
    java.lang.Runnable mCheckForGapsRunnable -> volatile
    int mSpanCount -> final
    boolean mShouldReverseLayout -> native
    androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup mLazySpanLookup -> switch
    androidx.recyclerview.widget.StaggeredGridLayoutManager$SavedState mPendingSavedState -> extends
    boolean isLayoutRTL() -> abstract
    boolean checkForGaps() -> boolean
    androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup$FullSpanItem createFullSpanItemFromEnd(int) -> break
    void onLayoutCompleted(androidx.recyclerview.widget.RecyclerView$State) -> byte
    void onScrollStateChanged(int) -> byte
    int computeScrollExtent(androidx.recyclerview.widget.RecyclerView$State) -> case
    void appendViewToAllSpans(android.view.View) -> catch
    androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup$FullSpanItem createFullSpanItemFromStart(int) -> catch
    int computeScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> char
    void scrollToPosition(int) -> char
    int findFirstReferenceChildPosition(int) -> class
    void prependViewToAllSpans(android.view.View) -> class
    int findLastReferenceChildPosition(int) -> const
    void createOrientationHelpers() -> continue
    int findFirstVisibleItemPositionInt() -> default
    void applyPendingSavedState(androidx.recyclerview.widget.StaggeredGridLayoutManager$AnchorInfo) -> do
    void assertNotInLayoutOrScroll(java.lang.String) -> do
    void attachViewToSpans(android.view.View,androidx.recyclerview.widget.StaggeredGridLayoutManager$LayoutParams,androidx.recyclerview.widget.LayoutState) -> do
    boolean canScrollHorizontally() -> do
    boolean checkLayoutParams(androidx.recyclerview.widget.RecyclerView$LayoutParams) -> do
    boolean checkSpanForGap(androidx.recyclerview.widget.StaggeredGridLayoutManager$Span) -> do
    void collectAdjacentPrefetchPositions(int,int,androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.RecyclerView$LayoutManager$LayoutPrefetchRegistry) -> do
    int computeHorizontalScrollExtent(androidx.recyclerview.widget.RecyclerView$State) -> do
    android.graphics.PointF computeScrollVectorForPosition(int) -> do
    int fill(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.LayoutState,androidx.recyclerview.widget.RecyclerView$State) -> do
    android.view.View findFirstVisibleItemClosestToEnd(boolean) -> do
    void fixEndGap(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,boolean) -> do
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateLayoutParams(android.content.Context,android.util.AttributeSet) -> do
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> do
    int getColumnCountForAccessibility(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    androidx.recyclerview.widget.StaggeredGridLayoutManager$Span getNextSpan(androidx.recyclerview.widget.LayoutState) -> do
    void measureChildWithDecorationsAndMargin(android.view.View,int,int,boolean) -> do
    void measureChildWithDecorationsAndMargin(android.view.View,androidx.recyclerview.widget.StaggeredGridLayoutManager$LayoutParams,boolean) -> do
    android.view.View onFocusSearchFailed(android.view.View,int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    void onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent) -> do
    void onInitializeAccessibilityNodeInfoForItem(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onItemsAdded(androidx.recyclerview.widget.RecyclerView,int,int) -> do
    void onItemsMoved(androidx.recyclerview.widget.RecyclerView,int,int,int) -> do
    void onItemsUpdated(androidx.recyclerview.widget.RecyclerView,int,int,java.lang.Object) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    void prepareLayoutStateForDelta(int,androidx.recyclerview.widget.RecyclerView$State) -> do
    void recycle(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.LayoutState) -> do
    void recycleFromEnd(androidx.recyclerview.widget.RecyclerView$Recycler,int) -> do
    int scrollHorizontallyBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> do
    void setMeasuredDimension(android.graphics.Rect,int,int) -> do
    void smoothScrollToPosition(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State,int) -> do
    boolean updateAnchorFromPendingData(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.StaggeredGridLayoutManager$AnchorInfo) -> do
    void updateRemainingSpans(androidx.recyclerview.widget.StaggeredGridLayoutManager$Span,int,int) -> do
    android.os.Parcelable onSaveInstanceState() -> double
    int computeScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> else
    void setOrientation(int) -> else
    int getFirstChildPosition() -> extends
    int getMaxEnd(int) -> final
    int getLastChildPosition() -> finally
    int getMaxStart(int) -> float
    int computeHorizontalScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> for
    androidx.recyclerview.widget.RecyclerView$LayoutParams generateDefaultLayoutParams() -> for
    void handleUpdate(int,int,int) -> for
    void onLayoutChildren(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,boolean) -> for
    int scrollBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> for
    void setReverseLayout(boolean) -> for
    boolean updateAnchorFromChildren(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.StaggeredGridLayoutManager$AnchorInfo) -> for
    void setSpanCount(int) -> goto
    boolean canScrollVertically() -> if
    int computeHorizontalScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> if
    android.view.View findFirstVisibleItemClosestToStart(boolean) -> if
    void fixStartGap(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State,boolean) -> if
    int getRowCountForAccessibility(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> if
    void onDetachedFromWindow(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$Recycler) -> if
    void onItemsRemoved(androidx.recyclerview.widget.RecyclerView,int,int) -> if
    void recycleFromStart(androidx.recyclerview.widget.RecyclerView$Recycler,int) -> if
    int scrollVerticallyBy(int,androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> if
    void updateAnchorInfoForLayout(androidx.recyclerview.widget.RecyclerView$State,androidx.recyclerview.widget.StaggeredGridLayoutManager$AnchorInfo) -> if
    void updateLayoutState(int,androidx.recyclerview.widget.RecyclerView$State) -> if
    int computeVerticalScrollExtent(androidx.recyclerview.widget.RecyclerView$State) -> int
    void onItemsChanged(androidx.recyclerview.widget.RecyclerView) -> int
    int updateSpecWithExtra(int,int,int) -> int
    void updateMeasureSpecs(int) -> long
    int computeVerticalScrollOffset(androidx.recyclerview.widget.RecyclerView$State) -> new
    void offsetChildrenHorizontal(int) -> new
    void onLayoutChildren(androidx.recyclerview.widget.RecyclerView$Recycler,androidx.recyclerview.widget.RecyclerView$State) -> new
    void updateAllRemainingSpans(int,int) -> new
    android.view.View hasGapsToFix() -> package
    void invalidateSpanAssignments() -> private
    int getMinEnd(int) -> short
    boolean supportsPredictiveItemAnimations() -> static
    void repositionToWrapContentIfNecessary() -> strictfp
    int getMinStart(int) -> super
    boolean isAutoMeasureEnabled() -> super
    boolean areAllEndsEqual() -> switch
    int calculateScrollDirectionForPosition(int) -> this
    boolean preferLastSpan(int) -> throw
    boolean areAllStartsEqual() -> throws
    int computeVerticalScrollRange(androidx.recyclerview.widget.RecyclerView$State) -> try
    void offsetChildrenVertical(int) -> try
    int convertFocusDirectionToLayoutDirection(int) -> void
    void resolveShouldLayoutReverse() -> volatile
    void setLayoutStateDirection(int) -> while
androidx.recyclerview.widget.StaggeredGridLayoutManager$1 -> androidx.recyclerview.widget.StaggeredGridLayoutManager$do:
    androidx.recyclerview.widget.StaggeredGridLayoutManager this$0 -> if
androidx.recyclerview.widget.StaggeredGridLayoutManager$AnchorInfo -> androidx.recyclerview.widget.StaggeredGridLayoutManager$if:
    int mOffset -> if
    boolean mLayoutFromEnd -> for
    boolean mInvalidateOffsets -> int
    boolean mValid -> new
    int mPosition -> do
    int[] mSpanReferenceLines -> try
    androidx.recyclerview.widget.StaggeredGridLayoutManager this$0 -> byte
    void assignCoordinateFromPadding() -> do
    void assignCoordinateFromPadding(int) -> do
    void saveSpanReferenceLines(androidx.recyclerview.widget.StaggeredGridLayoutManager$Span[]) -> do
    void reset() -> if
androidx.recyclerview.widget.StaggeredGridLayoutManager$LayoutParams -> androidx.recyclerview.widget.StaggeredGridLayoutManager$for:
    boolean mFullSpan -> try
    androidx.recyclerview.widget.StaggeredGridLayoutManager$Span mSpan -> new
    int getSpanIndex() -> new
    boolean isFullSpan() -> try
androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup -> androidx.recyclerview.widget.StaggeredGridLayoutManager$int:
    int[] mData -> do
    java.util.List mFullSpanItems -> if
    int invalidateFullSpansAfter(int) -> byte
    void addFullSpanItem(androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup$FullSpanItem) -> do
    void clear() -> do
    void ensureSize(int) -> do
    androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup$FullSpanItem getFirstFullSpanItemInRange(int,int,int,boolean) -> do
    void offsetForAddition(int,int) -> do
    void setSpan(int,androidx.recyclerview.widget.StaggeredGridLayoutManager$Span) -> do
    androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup$FullSpanItem getFullSpanItem(int) -> for
    void offsetFullSpansForAddition(int,int) -> for
    int forceInvalidateAfter(int) -> if
    void offsetForRemoval(int,int) -> if
    int getSpan(int) -> int
    void offsetFullSpansForRemoval(int,int) -> int
    int invalidateAfter(int) -> new
    int sizeForPosition(int) -> try
androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup$FullSpanItem -> androidx.recyclerview.widget.StaggeredGridLayoutManager$int$do:
    int mPosition -> if
    boolean mHasUnwantedGapAfter -> new
    int mGapDir -> for
    int[] mGapPerSpan -> int
    int getGapForSpan(int) -> do
androidx.recyclerview.widget.StaggeredGridLayoutManager$LazySpanLookup$FullSpanItem$1 -> androidx.recyclerview.widget.StaggeredGridLayoutManager$int$do$do:
androidx.recyclerview.widget.StaggeredGridLayoutManager$SavedState -> androidx.recyclerview.widget.StaggeredGridLayoutManager$new:
    int[] mSpanLookup -> byte
    int mAnchorPosition -> if
    int mSpanOffsetsSize -> int
    boolean mAnchorLayoutFromEnd -> else
    java.util.List mFullSpanItems -> case
    int mVisibleAnchorPosition -> for
    int mSpanLookupSize -> try
    boolean mReverseLayout -> char
    boolean mLastLayoutRTL -> goto
    int[] mSpanOffsets -> new
    void invalidateAnchorPositionInfo() -> int
    void invalidateSpanInfo() -> new
androidx.recyclerview.widget.StaggeredGridLayoutManager$SavedState$1 -> androidx.recyclerview.widget.StaggeredGridLayoutManager$new$do:
androidx.recyclerview.widget.StaggeredGridLayoutManager$Span -> androidx.recyclerview.widget.StaggeredGridLayoutManager$try:
    int mCachedStart -> if
    int mDeletedSize -> int
    androidx.recyclerview.widget.StaggeredGridLayoutManager this$0 -> try
    java.util.ArrayList mViews -> do
    int mCachedEnd -> for
    int mIndex -> new
    int getEndLine() -> byte
    int getStartLine() -> case
    void invalidateCache() -> char
    void appendToSpan(android.view.View) -> do
    void cacheReferenceLineAndClear(boolean,int) -> do
    void calculateCachedEnd() -> do
    int findOnePartiallyOrCompletelyVisibleChild(int,int,boolean,boolean,boolean) -> do
    int findOnePartiallyVisibleChild(int,int,boolean) -> do
    int getEndLine(int) -> do
    android.view.View getFocusableViewAfter(int,int) -> do
    void popEnd() -> else
    void clear() -> for
    void onOffset(int) -> for
    void prependToSpan(android.view.View) -> for
    void popStart() -> goto
    void calculateCachedStart() -> if
    androidx.recyclerview.widget.StaggeredGridLayoutManager$LayoutParams getLayoutParams(android.view.View) -> if
    int getStartLine(int) -> if
    int findFirstPartiallyVisibleItemPosition() -> int
    void setLine(int) -> int
    int findLastPartiallyVisibleItemPosition() -> new
    int getDeletedSize() -> try
androidx.recyclerview.widget.ViewBoundsCheck -> androidx.recyclerview.widget.break:
    androidx.recyclerview.widget.ViewBoundsCheck$Callback mCallback -> do
    androidx.recyclerview.widget.ViewBoundsCheck$BoundFlags mBoundFlags -> if
    android.view.View findOneViewWithinBoundFlags(int,int,int,int) -> do
    boolean isViewWithinBoundFlags(android.view.View,int) -> do
androidx.recyclerview.widget.ViewBoundsCheck$BoundFlags -> androidx.recyclerview.widget.break$do:
    int mRvStart -> if
    int mChildStart -> int
    int mBoundFlags -> do
    int mRvEnd -> for
    int mChildEnd -> new
    void addFlags(int) -> do
    boolean boundsMatch() -> do
    int compare(int,int) -> do
    void setBounds(int,int,int,int) -> do
    void resetFlags() -> if
androidx.recyclerview.widget.ViewBoundsCheck$Callback -> androidx.recyclerview.widget.break$if:
    android.view.View getChildAt(int) -> do
    int getChildEnd(android.view.View) -> do
    int getParentEnd() -> do
    int getChildStart(android.view.View) -> if
    int getParentStart() -> if
androidx.recyclerview.widget.ViewInfoStore -> androidx.recyclerview.widget.catch:
    androidx.collection.SimpleArrayMap mLayoutHolderMap -> do
    androidx.collection.LongSparseArray mOldChangedHolders -> if
    void removeFromDisappearedInLayout(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> byte
    void removeViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> case
    void addToAppearedInPreLayoutHolders(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> do
    void addToDisappearedInLayout(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    void addToOldChangeHolders(long,androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    void clear() -> do
    androidx.recyclerview.widget.RecyclerView$ViewHolder getFromOldChangeHolders(long) -> do
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo popFromLayoutStep(androidx.recyclerview.widget.RecyclerView$ViewHolder,int) -> do
    void process(androidx.recyclerview.widget.ViewInfoStore$ProcessCallback) -> do
    void addToPreLayout(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> for
    boolean isInPreLayout(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> for
    void addToPostLayout(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> if
    boolean isDisappearing(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> if
    void onDetach() -> if
    void onViewDetached(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> int
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo popFromPostLayout(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> new
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo popFromPreLayout(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> try
androidx.recyclerview.widget.ViewInfoStore$InfoRecord -> androidx.recyclerview.widget.catch$do:
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo postInfo -> for
    androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo preInfo -> if
    int flags -> do
    androidx.core.util.Pools$Pool sPool -> int
    void drainCache() -> do
    void recycle(androidx.recyclerview.widget.ViewInfoStore$InfoRecord) -> do
    androidx.recyclerview.widget.ViewInfoStore$InfoRecord obtain() -> if
androidx.recyclerview.widget.ViewInfoStore$ProcessCallback -> androidx.recyclerview.widget.catch$if:
    void processDisappeared(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> do
    void unused(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> do
    void processAppeared(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> for
    void processPersistent(androidx.recyclerview.widget.RecyclerView$ViewHolder,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo,androidx.recyclerview.widget.RecyclerView$ItemAnimator$ItemHolderInfo) -> if
androidx.savedstate.Recreator -> androidx.savedstate.Recreator:
    androidx.savedstate.SavedStateRegistryOwner mOwner -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
    void reflectiveNew(java.lang.String) -> do
androidx.savedstate.SavedStateRegistry -> androidx.savedstate.SavedStateRegistry:
    android.os.Bundle mRestoredState -> if
    androidx.arch.core.internal.SafeIterableMap mComponents -> do
    boolean mRestored -> for
    boolean mAllowingSavingState -> int
    android.os.Bundle consumeRestoredStateForKey(java.lang.String) -> do
    void performRestore(androidx.lifecycle.Lifecycle,android.os.Bundle) -> do
    void performSave(android.os.Bundle) -> do
androidx.savedstate.SavedStateRegistry$1 -> androidx.savedstate.SavedStateRegistry$1:
    androidx.savedstate.SavedStateRegistry this$0 -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.savedstate.SavedStateRegistry$AutoRecreated -> androidx.savedstate.SavedStateRegistry$do:
    void onRecreated(androidx.savedstate.SavedStateRegistryOwner) -> do
androidx.savedstate.SavedStateRegistry$SavedStateProvider -> androidx.savedstate.SavedStateRegistry$if:
    android.os.Bundle saveState() -> do
androidx.savedstate.SavedStateRegistryController -> androidx.savedstate.do:
    androidx.savedstate.SavedStateRegistry mRegistry -> if
    androidx.savedstate.SavedStateRegistryOwner mOwner -> do
    androidx.savedstate.SavedStateRegistryController create(androidx.savedstate.SavedStateRegistryOwner) -> do
    androidx.savedstate.SavedStateRegistry getSavedStateRegistry() -> do
    void performRestore(android.os.Bundle) -> do
    void performSave(android.os.Bundle) -> if
androidx.savedstate.SavedStateRegistryOwner -> androidx.savedstate.if:
    androidx.savedstate.SavedStateRegistry getSavedStateRegistry() -> for
androidx.transition.AnimatorUtils -> if.long.do:
    void addPauseListener(android.animation.Animator,android.animation.AnimatorListenerAdapter) -> do
    void pause(android.animation.Animator) -> do
    void resume(android.animation.Animator) -> if
androidx.transition.AnimatorUtils$AnimatorPauseListenerCompat -> if.long.do$do:
androidx.transition.AutoTransition -> if.long.if:
    void init() -> float
androidx.transition.ChangeBounds -> if.long.for:
    android.util.Property DRAWABLE_ORIGIN_PROPERTY -> strictfp
    android.util.Property TOP_LEFT_PROPERTY -> volatile
    android.util.Property BOTTOM_RIGHT_ONLY_PROPERTY -> protected
    android.util.Property POSITION_PROPERTY -> implements
    int[] mTempLocation -> package
    android.util.Property TOP_LEFT_ONLY_PROPERTY -> transient
    boolean mReparent -> abstract
    androidx.transition.RectEvaluator sRectEvaluator -> instanceof
    boolean mResizeClip -> private
    android.util.Property BOTTOM_RIGHT_PROPERTY -> interface
    java.lang.String[] sTransitionProperties -> continue
    void captureEndValues(androidx.transition.TransitionValues) -> do
    android.animation.Animator createAnimator(android.view.ViewGroup,androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> do
    boolean parentMatches(android.view.View,android.view.View) -> do
    void captureStartValues(androidx.transition.TransitionValues) -> for
    void captureValues(androidx.transition.TransitionValues) -> int
    java.lang.String[] getTransitionProperties() -> void
androidx.transition.ChangeBounds$1 -> if.long.for$if:
    android.graphics.Rect mBounds -> do
    android.graphics.PointF get(android.graphics.drawable.Drawable) -> do
    void set(android.graphics.drawable.Drawable,android.graphics.PointF) -> do
androidx.transition.ChangeBounds$10 -> if.long.for$do:
    android.view.View val$view -> for
    android.view.ViewGroup val$sceneRoot -> do
    float val$transitionAlpha -> int
    android.graphics.drawable.BitmapDrawable val$drawable -> if
androidx.transition.ChangeBounds$2 -> if.long.for$for:
    android.graphics.PointF get(androidx.transition.ChangeBounds$ViewBounds) -> do
    void set(androidx.transition.ChangeBounds$ViewBounds,android.graphics.PointF) -> do
androidx.transition.ChangeBounds$3 -> if.long.for$int:
    android.graphics.PointF get(androidx.transition.ChangeBounds$ViewBounds) -> do
    void set(androidx.transition.ChangeBounds$ViewBounds,android.graphics.PointF) -> do
androidx.transition.ChangeBounds$4 -> if.long.for$new:
    android.graphics.PointF get(android.view.View) -> do
    void set(android.view.View,android.graphics.PointF) -> do
androidx.transition.ChangeBounds$5 -> if.long.for$try:
    android.graphics.PointF get(android.view.View) -> do
    void set(android.view.View,android.graphics.PointF) -> do
androidx.transition.ChangeBounds$6 -> if.long.for$byte:
    android.graphics.PointF get(android.view.View) -> do
    void set(android.view.View,android.graphics.PointF) -> do
androidx.transition.ChangeBounds$7 -> if.long.for$case:
    androidx.transition.ChangeBounds$ViewBounds val$viewBounds -> do
androidx.transition.ChangeBounds$8 -> if.long.for$char:
    boolean mIsCanceled -> do
    int val$endLeft -> int
    android.view.View val$view -> if
    android.graphics.Rect val$finalClip -> for
    int val$endBottom -> byte
    int val$endTop -> new
    int val$endRight -> try
androidx.transition.ChangeBounds$9 -> if.long.for$else:
    boolean mCanceled -> do
    android.view.ViewGroup val$parent -> if
    void onTransitionEnd(androidx.transition.Transition) -> for
    void onTransitionCancel(androidx.transition.Transition) -> if
    void onTransitionPause(androidx.transition.Transition) -> int
    void onTransitionResume(androidx.transition.Transition) -> new
androidx.transition.ChangeBounds$ViewBounds -> if.long.for$goto:
    int mTop -> if
    int mBottom -> int
    android.view.View mView -> new
    int mLeft -> do
    int mRight -> for
    int mBottomRightCalls -> byte
    int mTopLeftCalls -> try
    void setBottomRight(android.graphics.PointF) -> do
    void setLeftTopRightBottom() -> do
    void setTopLeft(android.graphics.PointF) -> if
androidx.transition.Fade -> if.long.int:
    android.animation.Animator createAnimation(android.view.View,float,float) -> do
    float getStartAlpha(androidx.transition.TransitionValues,float) -> do
    android.animation.Animator onAppear(android.view.ViewGroup,android.view.View,androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> do
    void captureStartValues(androidx.transition.TransitionValues) -> for
    android.animation.Animator onDisappear(android.view.ViewGroup,android.view.View,androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> if
androidx.transition.Fade$1 -> if.long.int$do:
    android.view.View val$view -> do
    void onTransitionEnd(androidx.transition.Transition) -> for
androidx.transition.Fade$FadeAnimatorListener -> if.long.int$if:
    android.view.View mView -> do
    boolean mLayerTypeChanged -> if
androidx.transition.FragmentTransitionSupport -> if.long.new:
    void addTarget(java.lang.Object,android.view.View) -> do
    void addTargets(java.lang.Object,java.util.ArrayList) -> do
    void beginDelayedTransition(android.view.ViewGroup,java.lang.Object) -> do
    boolean canHandle(java.lang.Object) -> do
    boolean hasSimpleTarget(androidx.transition.Transition) -> do
    java.lang.Object mergeTransitionsInSequence(java.lang.Object,java.lang.Object,java.lang.Object) -> do
    void replaceTargets(java.lang.Object,java.util.ArrayList,java.util.ArrayList) -> do
    void scheduleHideFragmentView(java.lang.Object,android.view.View,java.util.ArrayList) -> do
    void scheduleRemoveTargets(java.lang.Object,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList,java.lang.Object,java.util.ArrayList) -> do
    void setEpicenter(java.lang.Object,android.graphics.Rect) -> do
    void setEpicenter(java.lang.Object,android.view.View) -> for
    java.lang.Object wrapTransitionInSet(java.lang.Object) -> for
    java.lang.Object cloneTransition(java.lang.Object) -> if
    java.lang.Object mergeTransitionsTogether(java.lang.Object,java.lang.Object,java.lang.Object) -> if
    void removeTarget(java.lang.Object,android.view.View) -> if
    void setSharedElementTargets(java.lang.Object,android.view.View,java.util.ArrayList) -> if
    void swapSharedElementTargets(java.lang.Object,java.util.ArrayList,java.util.ArrayList) -> if
androidx.transition.FragmentTransitionSupport$1 -> if.long.new$do:
androidx.transition.FragmentTransitionSupport$2 -> if.long.new$if:
    android.view.View val$fragmentView -> do
    java.util.ArrayList val$exitingViews -> if
    void onTransitionStart(androidx.transition.Transition) -> do
    void onTransitionEnd(androidx.transition.Transition) -> for
    void onTransitionCancel(androidx.transition.Transition) -> if
    void onTransitionPause(androidx.transition.Transition) -> int
    void onTransitionResume(androidx.transition.Transition) -> new
androidx.transition.FragmentTransitionSupport$3 -> if.long.new$for:
    java.util.ArrayList val$exitingViews -> int
    java.lang.Object val$enterTransition -> do
    java.util.ArrayList val$sharedElementsIn -> try
    androidx.transition.FragmentTransitionSupport this$0 -> byte
    java.util.ArrayList val$enteringViews -> if
    java.lang.Object val$exitTransition -> for
    java.lang.Object val$sharedElementTransition -> new
    void onTransitionStart(androidx.transition.Transition) -> do
    void onTransitionEnd(androidx.transition.Transition) -> for
androidx.transition.FragmentTransitionSupport$4 -> if.long.new$int:
androidx.transition.ObjectAnimatorUtils -> if.long.try:
    android.animation.ObjectAnimator ofPointF(java.lang.Object,android.util.Property,android.graphics.Path) -> do
androidx.transition.PathMotion -> if.long.byte:
    android.graphics.Path getPath(float,float,float,float) -> do
androidx.transition.PathProperty -> if.long.case:
    float mPathLength -> for
    android.graphics.PointF mPointF -> new
    android.graphics.PathMeasure mPathMeasure -> if
    float mCurrentFraction -> try
    android.util.Property mProperty -> do
    float[] mPosition -> int
    void set(java.lang.Object,java.lang.Float) -> do
androidx.transition.PropertyValuesHolderUtils -> if.long.char:
    android.animation.PropertyValuesHolder ofPointF(android.util.Property,android.graphics.Path) -> do
androidx.transition.R$id -> if.long.else:
androidx.transition.RectEvaluator -> if.long.goto:
    android.graphics.Rect mRect -> do
    android.graphics.Rect evaluate(float,android.graphics.Rect,android.graphics.Rect) -> do
androidx.transition.Scene -> if.long.long:
    java.lang.Runnable mExitAction -> if
    android.view.ViewGroup mSceneRoot -> do
    void exit() -> do
    androidx.transition.Scene getCurrentScene(android.view.ViewGroup) -> do
    void setCurrentScene(android.view.ViewGroup,androidx.transition.Scene) -> do
androidx.transition.Transition -> if.long.this:
    java.util.ArrayList mEndValuesList -> super
    int mNumInstances -> double
    java.util.ArrayList mTargetIdChildExcludes -> void
    long mDuration -> int
    boolean mPaused -> import
    androidx.transition.TransitionPropagation mPropagation -> static
    androidx.transition.TransitionSet mParent -> final
    int[] DEFAULT_MATCH_ORDER -> default
    java.util.ArrayList mTargetNameExcludes -> this
    boolean mEnded -> native
    java.util.ArrayList mCurrentAnimators -> while
    java.lang.String mName -> if
    java.util.ArrayList mStartValuesList -> short
    int[] mMatchOrder -> float
    java.util.ArrayList mTargetNames -> case
    java.util.ArrayList mListeners -> public
    java.util.ArrayList mTargetExcludes -> goto
    androidx.transition.PathMotion STRAIGHT_PATH_MOTION -> extends
    java.util.ArrayList mTargetIdExcludes -> else
    java.util.ArrayList mTargetTypeExcludes -> long
    java.util.ArrayList mTargetTypeChildExcludes -> catch
    androidx.transition.TransitionValuesMaps mEndValues -> const
    androidx.transition.PathMotion mPathMotion -> boolean
    androidx.transition.Transition$EpicenterCallback mEpicenterCallback -> switch
    android.animation.TimeInterpolator mInterpolator -> new
    androidx.transition.TransitionValuesMaps mStartValues -> class
    java.util.ArrayList mTargetChildExcludes -> break
    long mStartDelay -> for
    java.util.ArrayList mTargetIds -> try
    java.util.ArrayList mAnimators -> return
    androidx.collection.ArrayMap mNameOverrides -> throws
    java.lang.ThreadLocal sRunningAnimators -> finally
    java.util.ArrayList mTargets -> byte
    java.util.ArrayList mTargetTypes -> char
    boolean mCanRemoveViews -> throw
    void runAnimators() -> break
    androidx.transition.PathMotion getPathMotion() -> byte
    androidx.transition.TransitionPropagation getPropagation() -> case
    void start() -> catch
    long getStartDelay() -> char
    androidx.collection.ArrayMap getRunningAnimators() -> class
    androidx.transition.Transition addListener(androidx.transition.Transition$TransitionListener) -> do
    androidx.transition.Transition addTarget(android.view.View) -> do
    void addUnmatched(androidx.collection.ArrayMap,androidx.collection.ArrayMap) -> do
    void addViewValues(androidx.transition.TransitionValuesMaps,android.view.View,androidx.transition.TransitionValues) -> do
    void animate(android.animation.Animator) -> do
    void cancel() -> do
    void captureEndValues(androidx.transition.TransitionValues) -> do
    void captureValues(android.view.ViewGroup,boolean) -> do
    void clearValues(boolean) -> do
    android.animation.Animator createAnimator(android.view.ViewGroup,androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> do
    void createAnimators(android.view.ViewGroup,androidx.transition.TransitionValuesMaps,androidx.transition.TransitionValuesMaps,java.util.ArrayList,java.util.ArrayList) -> do
    androidx.transition.TransitionValues getMatchedTransitionValues(android.view.View,boolean) -> do
    boolean isTransitionRequired(androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> do
    boolean isValueChanged(androidx.transition.TransitionValues,androidx.transition.TransitionValues,java.lang.String) -> do
    void matchIds(androidx.collection.ArrayMap,androidx.collection.ArrayMap,android.util.SparseArray,android.util.SparseArray) -> do
    void matchItemIds(androidx.collection.ArrayMap,androidx.collection.ArrayMap,androidx.collection.LongSparseArray,androidx.collection.LongSparseArray) -> do
    void matchNames(androidx.collection.ArrayMap,androidx.collection.ArrayMap,androidx.collection.ArrayMap,androidx.collection.ArrayMap) -> do
    void matchStartAndEnd(androidx.transition.TransitionValuesMaps,androidx.transition.TransitionValuesMaps) -> do
    void playTransition(android.view.ViewGroup) -> do
    void runAnimator(android.animation.Animator,androidx.collection.ArrayMap) -> do
    androidx.transition.Transition setDuration(long) -> do
    void setEpicenterCallback(androidx.transition.Transition$EpicenterCallback) -> do
    androidx.transition.Transition setInterpolator(android.animation.TimeInterpolator) -> do
    void setPathMotion(androidx.transition.PathMotion) -> do
    void setPropagation(androidx.transition.TransitionPropagation) -> do
    java.lang.String toString(java.lang.String) -> do
    java.util.List getTargetIds() -> else
    void captureHierarchy(android.view.View,boolean) -> for
    void captureStartValues(androidx.transition.TransitionValues) -> for
    long getDuration() -> for
    void pause(android.view.View) -> for
    java.util.List getTargetNames() -> goto
    void capturePropagationValues(androidx.transition.TransitionValues) -> if
    void end() -> if
    androidx.transition.TransitionValues getTransitionValues(android.view.View,boolean) -> if
    boolean isValidTarget(android.view.View) -> if
    void matchInstances(androidx.collection.ArrayMap,androidx.collection.ArrayMap) -> if
    androidx.transition.Transition removeListener(androidx.transition.Transition$TransitionListener) -> if
    androidx.transition.Transition setStartDelay(long) -> if
    androidx.transition.Transition$EpicenterCallback getEpicenterCallback() -> int
    androidx.transition.Transition removeTarget(android.view.View) -> int
    java.util.List getTargetTypes() -> long
    android.animation.TimeInterpolator getInterpolator() -> new
    void resume(android.view.View) -> new
    java.util.List getTargets() -> this
    java.lang.String getName() -> try
    java.lang.String[] getTransitionProperties() -> void
androidx.transition.Transition$1 -> if.long.this$do:
    android.graphics.Path getPath(float,float,float,float) -> do
androidx.transition.Transition$2 -> if.long.this$if:
    androidx.collection.ArrayMap val$runningAnimators -> do
    androidx.transition.Transition this$0 -> if
androidx.transition.Transition$3 -> if.long.this$for:
    androidx.transition.Transition this$0 -> do
androidx.transition.Transition$AnimationInfo -> if.long.this$int:
    android.view.View mView -> do
    androidx.transition.TransitionValues mValues -> for
    java.lang.String mName -> if
    androidx.transition.WindowIdImpl mWindowId -> int
    androidx.transition.Transition mTransition -> new
androidx.transition.Transition$EpicenterCallback -> if.long.this$new:
androidx.transition.Transition$TransitionListener -> if.long.this$try:
    void onTransitionStart(androidx.transition.Transition) -> do
    void onTransitionEnd(androidx.transition.Transition) -> for
    void onTransitionCancel(androidx.transition.Transition) -> if
    void onTransitionPause(androidx.transition.Transition) -> int
    void onTransitionResume(androidx.transition.Transition) -> new
androidx.transition.TransitionListenerAdapter -> if.long.void:
    void onTransitionStart(androidx.transition.Transition) -> do
    void onTransitionCancel(androidx.transition.Transition) -> if
    void onTransitionPause(androidx.transition.Transition) -> int
    void onTransitionResume(androidx.transition.Transition) -> new
androidx.transition.TransitionManager -> if.long.break:
    java.lang.ThreadLocal sRunningTransitions -> if
    java.util.ArrayList sPendingTransitions -> for
    androidx.transition.Transition sDefaultTransition -> do
    void beginDelayedTransition(android.view.ViewGroup,androidx.transition.Transition) -> do
    androidx.collection.ArrayMap getRunningTransitions() -> do
    void sceneChangeSetup(android.view.ViewGroup,androidx.transition.Transition) -> for
    void sceneChangeRunTransition(android.view.ViewGroup,androidx.transition.Transition) -> if
androidx.transition.TransitionManager$MultiListener -> if.long.break$do:
    android.view.ViewGroup mSceneRoot -> for
    androidx.transition.Transition mTransition -> if
    void removeListeners() -> do
androidx.transition.TransitionManager$MultiListener$1 -> if.long.break$do$do:
    androidx.collection.ArrayMap val$runningTransitions -> do
    androidx.transition.TransitionManager$MultiListener this$0 -> if
    void onTransitionEnd(androidx.transition.Transition) -> for
androidx.transition.TransitionPropagation -> if.long.catch:
    void captureValues(androidx.transition.TransitionValues) -> do
    java.lang.String[] getPropagationProperties() -> do
    long getStartDelay(android.view.ViewGroup,androidx.transition.Transition,androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> do
androidx.transition.TransitionSet -> if.long.class:
    java.util.ArrayList mTransitions -> package
    int mCurrentListeners -> abstract
    int mChangeFlags -> strictfp
    boolean mPlayTogether -> private
    boolean mStarted -> continue
    void runAnimators() -> break
    int getTransitionCount() -> const
    androidx.transition.Transition addListener(androidx.transition.Transition$TransitionListener) -> do
    androidx.transition.TransitionSet addListener(androidx.transition.Transition$TransitionListener) -> do
    androidx.transition.Transition addTarget(android.view.View) -> do
    androidx.transition.TransitionSet addTarget(android.view.View) -> do
    androidx.transition.TransitionSet addTransition(androidx.transition.Transition) -> do
    void cancel() -> do
    void captureEndValues(androidx.transition.TransitionValues) -> do
    void createAnimators(android.view.ViewGroup,androidx.transition.TransitionValuesMaps,androidx.transition.TransitionValuesMaps,java.util.ArrayList,java.util.ArrayList) -> do
    androidx.transition.Transition getTransitionAt(int) -> do
    androidx.transition.Transition setDuration(long) -> do
    androidx.transition.TransitionSet setDuration(long) -> do
    void setEpicenterCallback(androidx.transition.Transition$EpicenterCallback) -> do
    androidx.transition.Transition setInterpolator(android.animation.TimeInterpolator) -> do
    androidx.transition.TransitionSet setInterpolator(android.animation.TimeInterpolator) -> do
    void setPathMotion(androidx.transition.PathMotion) -> do
    void setPropagation(androidx.transition.TransitionPropagation) -> do
    java.lang.String toString(java.lang.String) -> do
    void setupStartEndListeners() -> final
    void captureStartValues(androidx.transition.TransitionValues) -> for
    void pause(android.view.View) -> for
    void addTransitionInternal(androidx.transition.Transition) -> if
    void capturePropagationValues(androidx.transition.TransitionValues) -> if
    androidx.transition.Transition removeListener(androidx.transition.Transition$TransitionListener) -> if
    androidx.transition.TransitionSet removeListener(androidx.transition.Transition$TransitionListener) -> if
    androidx.transition.TransitionSet setOrdering(int) -> if
    androidx.transition.Transition setStartDelay(long) -> if
    androidx.transition.TransitionSet setStartDelay(long) -> if
    androidx.transition.Transition removeTarget(android.view.View) -> int
    androidx.transition.TransitionSet removeTarget(android.view.View) -> int
    void resume(android.view.View) -> new
androidx.transition.TransitionSet$1 -> if.long.class$do:
    androidx.transition.Transition val$nextTransition -> do
    void onTransitionEnd(androidx.transition.Transition) -> for
androidx.transition.TransitionSet$TransitionSetListener -> if.long.class$if:
    androidx.transition.TransitionSet mTransitionSet -> do
    void onTransitionStart(androidx.transition.Transition) -> do
    void onTransitionEnd(androidx.transition.Transition) -> for
androidx.transition.TransitionUtils -> if.long.const:
    boolean HAS_IS_ATTACHED_TO_WINDOW -> do
    boolean HAS_PICTURE_BITMAP -> for
    boolean HAS_OVERLAY -> if
    android.view.View copyViewImage(android.view.ViewGroup,android.view.View,android.view.View) -> do
    android.graphics.Bitmap createViewBitmap(android.view.View,android.graphics.Matrix,android.graphics.RectF,android.view.ViewGroup) -> do
    android.animation.Animator mergeAnimators(android.animation.Animator,android.animation.Animator) -> do
androidx.transition.TransitionValues -> if.long.final:
    android.view.View view -> if
    java.util.ArrayList mTargetedTransitions -> for
    java.util.Map values -> do
androidx.transition.TransitionValuesMaps -> if.long.float:
    androidx.collection.ArrayMap mViewValues -> do
    android.util.SparseArray mIdValues -> if
    androidx.collection.LongSparseArray mItemIdValues -> for
    androidx.collection.ArrayMap mNameValues -> int
androidx.transition.ViewGroupOverlayApi14 -> if.long.short:
    androidx.transition.ViewGroupOverlayApi14 createFrom(android.view.ViewGroup) -> do
    void remove(android.view.View) -> do
    void add(android.view.View) -> if
androidx.transition.ViewGroupOverlayApi18 -> if.long.super:
    android.view.ViewGroupOverlay mViewGroupOverlay -> do
    void remove(android.graphics.drawable.Drawable) -> do
    void remove(android.view.View) -> do
    void add(android.graphics.drawable.Drawable) -> if
    void add(android.view.View) -> if
androidx.transition.ViewGroupOverlayImpl -> if.long.throw:
    void remove(android.view.View) -> do
    void add(android.view.View) -> if
androidx.transition.ViewGroupUtils -> if.long.while:
    boolean sTryHiddenSuppressLayout -> do
    androidx.transition.ViewGroupOverlayImpl getOverlay(android.view.ViewGroup) -> do
    void hiddenSuppressLayout(android.view.ViewGroup,boolean) -> do
    void suppressLayout(android.view.ViewGroup,boolean) -> if
androidx.transition.ViewGroupUtilsApi14 -> if.long.double:
    java.lang.reflect.Field sLayoutSuppressedField -> if
    boolean sLayoutSuppressedFieldFetched -> for
    android.animation.LayoutTransition sEmptyLayoutTransition -> do
    boolean sCancelMethodFetched -> new
    java.lang.reflect.Method sCancelMethod -> int
    void cancelLayoutTransition(android.animation.LayoutTransition) -> do
    void suppressLayout(android.view.ViewGroup,boolean) -> do
androidx.transition.ViewGroupUtilsApi14$1 -> if.long.double$do:
androidx.transition.ViewOverlayApi14 -> if.long.import:
    androidx.transition.ViewOverlayApi14$OverlayViewGroup mOverlayViewGroup -> do
    void remove(android.graphics.drawable.Drawable) -> do
    androidx.transition.ViewOverlayApi14 createFrom(android.view.View) -> for
    void add(android.graphics.drawable.Drawable) -> if
    android.view.ViewGroup getContentView(android.view.View) -> int
androidx.transition.ViewOverlayApi14$OverlayViewGroup -> if.long.import$do:
    android.view.View mRequestingView -> for
    java.util.ArrayList mDrawables -> int
    androidx.transition.ViewOverlayApi14 mViewOverlay -> new
    android.view.ViewGroup mHostView -> if
    boolean mDisposed -> try
    void add(android.graphics.drawable.Drawable) -> do
    void add(android.view.View) -> do
    void assertNotDisposed() -> do
    void getOffset(int[]) -> do
    void disposeIfEmpty() -> if
    void remove(android.graphics.drawable.Drawable) -> if
    void remove(android.view.View) -> if
androidx.transition.ViewOverlayApi18 -> if.long.native:
    android.view.ViewOverlay mViewOverlay -> do
    void remove(android.graphics.drawable.Drawable) -> do
    void add(android.graphics.drawable.Drawable) -> if
androidx.transition.ViewOverlayImpl -> if.long.public:
    void remove(android.graphics.drawable.Drawable) -> do
    void add(android.graphics.drawable.Drawable) -> if
androidx.transition.ViewUtils -> if.long.return:
    android.util.Property TRANSITION_ALPHA -> if
    androidx.transition.ViewUtilsBase IMPL -> do
    void clearNonTransitionAlpha(android.view.View) -> do
    void setLeftTopRightBottom(android.view.View,int,int,int,int) -> do
    void setTransitionAlpha(android.view.View,float) -> do
    void setTransitionVisibility(android.view.View,int) -> do
    void transformMatrixToGlobal(android.view.View,android.graphics.Matrix) -> do
    float getTransitionAlpha(android.view.View) -> for
    androidx.transition.ViewOverlayImpl getOverlay(android.view.View) -> if
    void transformMatrixToLocal(android.view.View,android.graphics.Matrix) -> if
    androidx.transition.WindowIdImpl getWindowId(android.view.View) -> int
    void saveNonTransitionAlpha(android.view.View) -> new
androidx.transition.ViewUtils$1 -> if.long.return$do:
    java.lang.Float get(android.view.View) -> do
    void set(android.view.View,java.lang.Float) -> do
androidx.transition.ViewUtils$2 -> if.long.return$if:
    android.graphics.Rect get(android.view.View) -> do
    void set(android.view.View,android.graphics.Rect) -> do
androidx.transition.ViewUtilsApi19 -> if.long.static:
    boolean sTryHiddenTransitionAlpha -> new
    void clearNonTransitionAlpha(android.view.View) -> do
    void setTransitionAlpha(android.view.View,float) -> do
    void saveNonTransitionAlpha(android.view.View) -> for
    float getTransitionAlpha(android.view.View) -> if
androidx.transition.ViewUtilsApi21 -> if.long.switch:
    boolean sTryHiddenTransformMatrixToLocal -> byte
    boolean sTryHiddenTransformMatrixToGlobal -> try
    void transformMatrixToGlobal(android.view.View,android.graphics.Matrix) -> do
    void transformMatrixToLocal(android.view.View,android.graphics.Matrix) -> if
androidx.transition.ViewUtilsApi22 -> if.long.throws:
    boolean sTryHiddenSetLeftTopRightBottom -> case
    void setLeftTopRightBottom(android.view.View,int,int,int,int) -> do
androidx.transition.ViewUtilsApi23 -> if.long.boolean:
    boolean sTryHiddenSetTransitionVisibility -> char
    void setTransitionVisibility(android.view.View,int) -> do
androidx.transition.ViewUtilsApi29 -> if.long.default:
    void setLeftTopRightBottom(android.view.View,int,int,int,int) -> do
    void setTransitionAlpha(android.view.View,float) -> do
    void setTransitionVisibility(android.view.View,int) -> do
    void transformMatrixToGlobal(android.view.View,android.graphics.Matrix) -> do
    float getTransitionAlpha(android.view.View) -> if
    void transformMatrixToLocal(android.view.View,android.graphics.Matrix) -> if
androidx.transition.ViewUtilsBase -> if.long.extends:
    java.lang.reflect.Field sViewFlagsField -> for
    boolean sViewFlagsFieldFetched -> int
    boolean sSetFrameFetched -> if
    java.lang.reflect.Method sSetFrameMethod -> do
    void clearNonTransitionAlpha(android.view.View) -> do
    void fetchSetFrame() -> do
    void setLeftTopRightBottom(android.view.View,int,int,int,int) -> do
    void setTransitionAlpha(android.view.View,float) -> do
    void setTransitionVisibility(android.view.View,int) -> do
    void transformMatrixToGlobal(android.view.View,android.graphics.Matrix) -> do
    void saveNonTransitionAlpha(android.view.View) -> for
    float getTransitionAlpha(android.view.View) -> if
    void transformMatrixToLocal(android.view.View,android.graphics.Matrix) -> if
androidx.transition.Visibility -> if.long.finally:
    java.lang.String[] sTransitionProperties -> private
    int mMode -> package
    void captureEndValues(androidx.transition.TransitionValues) -> do
    android.animation.Animator createAnimator(android.view.ViewGroup,androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> do
    boolean isTransitionRequired(androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> do
    android.animation.Animator onAppear(android.view.ViewGroup,android.view.View,androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> do
    android.animation.Animator onAppear(android.view.ViewGroup,androidx.transition.TransitionValues,int,androidx.transition.TransitionValues,int) -> do
    void setMode(int) -> do
    void captureStartValues(androidx.transition.TransitionValues) -> for
    androidx.transition.Visibility$VisibilityInfo getVisibilityChangeInfo(androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> if
    android.animation.Animator onDisappear(android.view.ViewGroup,android.view.View,androidx.transition.TransitionValues,androidx.transition.TransitionValues) -> if
    android.animation.Animator onDisappear(android.view.ViewGroup,androidx.transition.TransitionValues,int,androidx.transition.TransitionValues,int) -> if
    void captureValues(androidx.transition.TransitionValues) -> int
    java.lang.String[] getTransitionProperties() -> void
androidx.transition.Visibility$1 -> if.long.finally$do:
    android.view.View val$startView -> for
    android.view.View val$finalOverlayView -> if
    android.view.ViewGroup val$overlayHost -> do
    androidx.transition.Visibility this$0 -> int
    void onTransitionEnd(androidx.transition.Transition) -> for
    void onTransitionPause(androidx.transition.Transition) -> int
    void onTransitionResume(androidx.transition.Transition) -> new
androidx.transition.Visibility$DisappearListener -> if.long.finally$if:
    int mFinalVisibility -> if
    android.view.View mView -> do
    boolean mSuppressLayout -> int
    boolean mLayoutSuppressed -> new
    android.view.ViewGroup mParent -> for
    boolean mCanceled -> try
    void hideViewWhenNotCanceled() -> do
    void onTransitionStart(androidx.transition.Transition) -> do
    void suppressLayout(boolean) -> do
    void onTransitionEnd(androidx.transition.Transition) -> for
    void onTransitionCancel(androidx.transition.Transition) -> if
    void onTransitionPause(androidx.transition.Transition) -> int
    void onTransitionResume(androidx.transition.Transition) -> new
androidx.transition.Visibility$VisibilityInfo -> if.long.finally$for:
    boolean mVisibilityChange -> do
    android.view.ViewGroup mStartParent -> new
    android.view.ViewGroup mEndParent -> try
    int mEndVisibility -> int
    boolean mFadeIn -> if
    int mStartVisibility -> for
androidx.transition.WindowIdApi14 -> if.long.package:
    android.os.IBinder mToken -> do
androidx.transition.WindowIdApi18 -> if.long.private:
    android.view.WindowId mWindowId -> do
androidx.transition.WindowIdImpl -> if.long.abstract:
androidx.vectordrawable.graphics.drawable.AndroidResources -> if.this.do.do.do:
    int[] STYLEABLE_ANIMATOR -> byte
    int[] STYLEABLE_VECTOR_DRAWABLE_PATH -> for
    int[] STYLEABLE_PROPERTY_VALUES_HOLDER -> char
    int[] STYLEABLE_PATH_INTERPOLATOR -> long
    int[] STYLEABLE_KEYFRAME -> else
    int[] STYLEABLE_PROPERTY_ANIMATOR -> goto
    int[] STYLEABLE_ANIMATED_VECTOR_DRAWABLE_TARGET -> try
    int[] STYLEABLE_VECTOR_DRAWABLE_GROUP -> if
    int[] STYLEABLE_VECTOR_DRAWABLE_TYPE_ARRAY -> do
    int[] STYLEABLE_ANIMATOR_SET -> case
    int[] STYLEABLE_VECTOR_DRAWABLE_CLIP_PATH -> int
    int[] STYLEABLE_ANIMATED_VECTOR_DRAWABLE -> new
androidx.vectordrawable.graphics.drawable.Animatable2Compat -> if.this.do.do.if:
androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat -> if.this.do.do.for:
    android.content.Context mContext -> int
    android.graphics.drawable.Drawable$Callback mCallback -> try
    androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat$AnimatedVectorDrawableCompatState mAnimatedVectorState -> for
    android.animation.ArgbEvaluator mArgbEvaluator -> new
    androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat createFromXmlInner(android.content.Context,android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
    void setupAnimatorsForTarget(java.lang.String,android.animation.Animator) -> do
    void setupColorAnimator(android.animation.Animator) -> do
androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat$1 -> if.this.do.do.for$do:
    androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat this$0 -> if
androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat$AnimatedVectorDrawableCompatState -> if.this.do.do.for$if:
    java.util.ArrayList mAnimators -> int
    android.animation.AnimatorSet mAnimatorSet -> for
    int mChangingConfigurations -> do
    androidx.collection.ArrayMap mTargetNameMap -> new
    androidx.vectordrawable.graphics.drawable.VectorDrawableCompat mVectorDrawable -> if
    void setupAnimatorSet() -> do
androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat$AnimatedVectorDrawableDelegateState -> if.this.do.do.for$for:
    android.graphics.drawable.Drawable$ConstantState mDelegateState -> do
androidx.vectordrawable.graphics.drawable.AnimationUtilsCompat -> if.this.do.do.int:
    android.view.animation.Interpolator createInterpolatorFromXml(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,org.xmlpull.v1.XmlPullParser) -> do
    android.view.animation.Interpolator loadInterpolator(android.content.Context,int) -> do
androidx.vectordrawable.graphics.drawable.AnimatorInflaterCompat -> if.this.do.do.new:
    android.animation.Animator createAnimatorFromXml(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,org.xmlpull.v1.XmlPullParser,float) -> do
    android.animation.Animator createAnimatorFromXml(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.animation.AnimatorSet,int,float) -> do
    android.animation.Keyframe createNewKeyframe(android.animation.Keyframe,float) -> do
    void distributeKeyframes(android.animation.Keyframe[],float,int,int) -> do
    android.animation.PropertyValuesHolder getPVH(android.content.res.TypedArray,int,int,int,java.lang.String) -> do
    int inferValueTypeFromValues(android.content.res.TypedArray,int,int) -> do
    int inferValueTypeOfKeyframe(android.content.res.Resources,android.content.res.Resources$Theme,android.util.AttributeSet,org.xmlpull.v1.XmlPullParser) -> do
    boolean isColorType(int) -> do
    android.animation.Animator loadAnimator(android.content.Context,int) -> do
    android.animation.Animator loadAnimator(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,int) -> do
    android.animation.Animator loadAnimator(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,int,float) -> do
    android.animation.ValueAnimator loadAnimator(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,android.util.AttributeSet,android.animation.ValueAnimator,float,org.xmlpull.v1.XmlPullParser) -> do
    android.animation.Keyframe loadKeyframe(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,android.util.AttributeSet,int,org.xmlpull.v1.XmlPullParser) -> do
    android.animation.ObjectAnimator loadObjectAnimator(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,android.util.AttributeSet,float,org.xmlpull.v1.XmlPullParser) -> do
    android.animation.PropertyValuesHolder loadPvh(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,org.xmlpull.v1.XmlPullParser,java.lang.String,int) -> do
    android.animation.PropertyValuesHolder[] loadValues(android.content.Context,android.content.res.Resources,android.content.res.Resources$Theme,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet) -> do
    void parseAnimatorFromTypeArray(android.animation.ValueAnimator,android.content.res.TypedArray,android.content.res.TypedArray,float,org.xmlpull.v1.XmlPullParser) -> do
    void setupObjectAnimator(android.animation.ValueAnimator,android.content.res.TypedArray,int,float,org.xmlpull.v1.XmlPullParser) -> do
    void setupPathMotion(android.graphics.Path,android.animation.ObjectAnimator,float,java.lang.String,java.lang.String) -> do
androidx.vectordrawable.graphics.drawable.AnimatorInflaterCompat$PathDataEvaluator -> if.this.do.do.new$do:
    androidx.core.graphics.PathParser$PathDataNode[] mNodeArray -> do
    androidx.core.graphics.PathParser$PathDataNode[] evaluate(float,androidx.core.graphics.PathParser$PathDataNode[],androidx.core.graphics.PathParser$PathDataNode[]) -> do
androidx.vectordrawable.graphics.drawable.ArgbEvaluator -> if.this.do.do.try:
    androidx.vectordrawable.graphics.drawable.ArgbEvaluator sInstance -> do
    androidx.vectordrawable.graphics.drawable.ArgbEvaluator getInstance() -> do
androidx.vectordrawable.graphics.drawable.PathInterpolatorCompat -> if.this.do.do.byte:
    float[] mX -> do
    float[] mY -> if
    void initCubic(float,float,float,float) -> do
    void initPath(android.graphics.Path) -> do
    void initQuad(float,float) -> do
    void parseInterpolatorFromTypeArray(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser) -> do
androidx.vectordrawable.graphics.drawable.VectorDrawableCommon -> if.this.do.do.case:
    android.graphics.drawable.Drawable mDelegateDrawable -> if
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat -> if.this.do.do.char:
    android.graphics.Matrix mTmpMatrix -> char
    android.graphics.Rect mTmpBounds -> else
    androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VectorDrawableCompatState mVectorState -> for
    boolean mAllowCaching -> byte
    android.graphics.PorterDuffColorFilter mTintFilter -> int
    android.graphics.PorterDuff$Mode DEFAULT_TINT_MODE -> goto
    android.graphics.ColorFilter mColorFilter -> new
    boolean mMutated -> try
    float[] mTmpFloats -> case
    int applyAlpha(int,float) -> do
    androidx.vectordrawable.graphics.drawable.VectorDrawableCompat create(android.content.res.Resources,int,android.content.res.Resources$Theme) -> do
    java.lang.Object getTargetByName(java.lang.String) -> do
    void inflateInternal(android.content.res.Resources,org.xmlpull.v1.XmlPullParser,android.util.AttributeSet,android.content.res.Resources$Theme) -> do
    boolean needMirroring() -> do
    android.graphics.PorterDuff$Mode parseTintModeCompat(int,android.graphics.PorterDuff$Mode) -> do
    void setAllowCaching(boolean) -> do
    void updateStateFromTypedArray(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,android.content.res.Resources$Theme) -> do
    android.graphics.PorterDuffColorFilter updateTintFilter(android.graphics.PorterDuffColorFilter,android.content.res.ColorStateList,android.graphics.PorterDuff$Mode) -> do
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$1 -> if.this.do.do.char$do:
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VClipPath -> if.this.do.do.char$if:
    void inflate(android.content.res.Resources,android.util.AttributeSet,android.content.res.Resources$Theme,org.xmlpull.v1.XmlPullParser) -> do
    void updateStateFromTypedArray(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser) -> do
    boolean isClipPath() -> if
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VFullPath -> if.this.do.do.char$for:
    float mFillAlpha -> else
    float mStrokeAlpha -> char
    androidx.core.content.res.ComplexColorCompat mFillColor -> case
    float mTrimPathStart -> goto
    float mTrimPathEnd -> long
    android.graphics.Paint$Join mStrokeLineJoin -> break
    android.graphics.Paint$Cap mStrokeLineCap -> void
    float mStrokeWidth -> byte
    float mStrokeMiterlimit -> catch
    float mTrimPathOffset -> this
    androidx.core.content.res.ComplexColorCompat mStrokeColor -> try
    int[] mThemeAttrs -> new
    android.graphics.Paint$Cap getStrokeLineCap(int,android.graphics.Paint$Cap) -> do
    android.graphics.Paint$Join getStrokeLineJoin(int,android.graphics.Paint$Join) -> do
    void inflate(android.content.res.Resources,android.util.AttributeSet,android.content.res.Resources$Theme,org.xmlpull.v1.XmlPullParser) -> do
    boolean isStateful() -> do
    boolean onStateChanged(int[]) -> do
    void updateStateFromTypedArray(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser,android.content.res.Resources$Theme) -> do
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VGroup -> if.this.do.do.char$int:
    android.graphics.Matrix mStackedMatrix -> do
    java.util.ArrayList mChildren -> if
    float mScaleX -> try
    float mPivotX -> int
    int mChangingConfigurations -> goto
    android.graphics.Matrix mLocalMatrix -> else
    float mRotate -> for
    int[] mThemeAttrs -> long
    float mTranslateY -> char
    java.lang.String mGroupName -> this
    float mScaleY -> byte
    float mTranslateX -> case
    float mPivotY -> new
    void inflate(android.content.res.Resources,android.util.AttributeSet,android.content.res.Resources$Theme,org.xmlpull.v1.XmlPullParser) -> do
    boolean isStateful() -> do
    boolean onStateChanged(int[]) -> do
    void updateStateFromTypedArray(android.content.res.TypedArray,org.xmlpull.v1.XmlPullParser) -> do
    void updateLocalMatrix() -> if
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VObject -> if.this.do.do.char$new:
    boolean isStateful() -> do
    boolean onStateChanged(int[]) -> do
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VPath -> if.this.do.do.char$try:
    int mChangingConfigurations -> int
    java.lang.String mPathName -> if
    int mFillRule -> for
    androidx.core.graphics.PathParser$PathDataNode[] mNodes -> do
    void toPath(android.graphics.Path) -> do
    boolean isClipPath() -> if
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VPathRenderer -> if.this.do.do.char$byte:
    java.lang.String mRootName -> void
    android.graphics.Matrix IDENTITY_MATRIX -> class
    int mRootAlpha -> this
    android.graphics.Path mRenderPath -> if
    androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VGroup mRootGroup -> case
    java.lang.Boolean mIsStateful -> break
    android.graphics.Paint mFillPaint -> new
    android.graphics.PathMeasure mPathMeasure -> try
    float mBaseHeight -> else
    android.graphics.Matrix mFinalPathMatrix -> for
    float mBaseWidth -> char
    float mViewportWidth -> goto
    float mViewportHeight -> long
    android.graphics.Path mPath -> do
    int mChangingConfigurations -> byte
    android.graphics.Paint mStrokePaint -> int
    androidx.collection.ArrayMap mVGTargetsMap -> catch
    float cross(float,float,float,float) -> do
    void draw(android.graphics.Canvas,int,int,android.graphics.ColorFilter) -> do
    void drawGroupTree(androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VGroup,android.graphics.Matrix,android.graphics.Canvas,int,int,android.graphics.ColorFilter) -> do
    void drawPath(androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VGroup,androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VPath,android.graphics.Canvas,int,int,android.graphics.ColorFilter) -> do
    float getMatrixScale(android.graphics.Matrix) -> do
    boolean isStateful() -> do
    boolean onStateChanged(int[]) -> do
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VectorDrawableCompatState -> if.this.do.do.char$case:
    boolean mCachedAutoMirrored -> else
    android.graphics.Bitmap mCachedBitmap -> try
    boolean mAutoMirrored -> new
    int mChangingConfigurations -> do
    android.graphics.Paint mTempPaint -> long
    android.graphics.PorterDuff$Mode mTintMode -> int
    android.content.res.ColorStateList mTint -> for
    androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VPathRenderer mVPathRenderer -> if
    int mCachedRootAlpha -> char
    android.content.res.ColorStateList mCachedTint -> byte
    boolean mCacheDirty -> goto
    android.graphics.PorterDuff$Mode mCachedTintMode -> case
    boolean canReuseBitmap(int,int) -> do
    boolean canReuseCache() -> do
    void drawCachedBitmapWithRootAlpha(android.graphics.Canvas,android.graphics.ColorFilter,android.graphics.Rect) -> do
    android.graphics.Paint getPaint(android.graphics.ColorFilter) -> do
    boolean onStateChanged(int[]) -> do
    boolean isStateful() -> for
    void updateCachedBitmap(int,int) -> for
    void createCachedBitmapIfNeeded(int,int) -> if
    boolean hasTranslucentRoot() -> if
    void updateCacheStates() -> int
androidx.vectordrawable.graphics.drawable.VectorDrawableCompat$VectorDrawableDelegateState -> if.this.do.do.char$char:
    android.graphics.drawable.Drawable$ConstantState mDelegateState -> do
androidx.versionedparcelable.ParcelImpl -> androidx.versionedparcelable.ParcelImpl:
    androidx.versionedparcelable.VersionedParcelable mParcel -> if
androidx.versionedparcelable.ParcelImpl$1 -> androidx.versionedparcelable.ParcelImpl$do:
androidx.versionedparcelable.VersionedParcel -> androidx.versionedparcelable.do:
    androidx.collection.ArrayMap mReadCache -> do
    androidx.collection.ArrayMap mWriteCache -> if
    androidx.collection.ArrayMap mParcelizerCache -> for
    int readInt() -> byte
    android.os.Parcelable readParcelable() -> case
    java.lang.String readString() -> char
    void closeField() -> do
    java.lang.Class findParcelClass(java.lang.Class) -> do
    boolean readBoolean(boolean,int) -> do
    byte[] readByteArray(byte[],int) -> do
    java.lang.CharSequence readCharSequence(java.lang.CharSequence,int) -> do
    boolean readField(int) -> do
    androidx.versionedparcelable.VersionedParcelable readFromParcel(java.lang.String,androidx.versionedparcelable.VersionedParcel) -> do
    int readInt(int,int) -> do
    android.os.Parcelable readParcelable(android.os.Parcelable,int) -> do
    java.lang.String readString(java.lang.String,int) -> do
    androidx.versionedparcelable.VersionedParcelable readVersionedParcelable(androidx.versionedparcelable.VersionedParcelable,int) -> do
    void setSerializationFlags(boolean,boolean) -> do
    void writeBoolean(boolean) -> do
    void writeByteArray(byte[]) -> do
    void writeCharSequence(java.lang.CharSequence) -> do
    void writeParcelable(android.os.Parcelable) -> do
    void writeString(java.lang.String) -> do
    void writeToParcel(androidx.versionedparcelable.VersionedParcelable,androidx.versionedparcelable.VersionedParcel) -> do
    void writeVersionedParcelable(androidx.versionedparcelable.VersionedParcelable) -> do
    androidx.versionedparcelable.VersionedParcelable readVersionedParcelable() -> else
    boolean isStream() -> for
    void writeInt(int) -> for
    androidx.versionedparcelable.VersionedParcel createSubParcel() -> if
    java.lang.reflect.Method getReadMethod(java.lang.String) -> if
    java.lang.reflect.Method getWriteMethod(java.lang.Class) -> if
    void setOutputField(int) -> if
    void writeBoolean(boolean,int) -> if
    void writeByteArray(byte[],int) -> if
    void writeCharSequence(java.lang.CharSequence,int) -> if
    void writeInt(int,int) -> if
    void writeParcelable(android.os.Parcelable,int) -> if
    void writeString(java.lang.String,int) -> if
    void writeVersionedParcelable(androidx.versionedparcelable.VersionedParcelable,int) -> if
    void writeVersionedParcelableCreator(androidx.versionedparcelable.VersionedParcelable) -> if
    boolean readBoolean() -> int
    byte[] readByteArray() -> new
    java.lang.CharSequence readCharSequence() -> try
androidx.versionedparcelable.VersionedParcelParcel -> androidx.versionedparcelable.if:
    int mNextRead -> else
    int mEnd -> byte
    android.os.Parcel mParcel -> new
    java.lang.String mPrefix -> case
    android.util.SparseIntArray mPositionLookup -> int
    int mOffset -> try
    int mCurrentField -> char
    int mFieldId -> goto
    int readInt() -> byte
    android.os.Parcelable readParcelable() -> case
    java.lang.String readString() -> char
    void closeField() -> do
    boolean readField(int) -> do
    void writeBoolean(boolean) -> do
    void writeByteArray(byte[]) -> do
    void writeCharSequence(java.lang.CharSequence) -> do
    void writeParcelable(android.os.Parcelable) -> do
    void writeString(java.lang.String) -> do
    void writeInt(int) -> for
    androidx.versionedparcelable.VersionedParcel createSubParcel() -> if
    void setOutputField(int) -> if
    boolean readBoolean() -> int
    byte[] readByteArray() -> new
    java.lang.CharSequence readCharSequence() -> try
androidx.versionedparcelable.VersionedParcelable -> androidx.versionedparcelable.for:
androidx.viewpager2.adapter.FragmentStateAdapter -> androidx.viewpager2.adapter.do:
    boolean shouldDelayFragmentTransactions() -> new
androidx.viewpager2.adapter.FragmentStateAdapter$2 -> androidx.viewpager2.adapter.FragmentStateAdapter$2:
    androidx.viewpager2.adapter.FragmentViewHolder val$holder -> do
    androidx.viewpager2.adapter.FragmentStateAdapter this$0 -> if
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.viewpager2.adapter.FragmentStateAdapter$5 -> androidx.viewpager2.adapter.FragmentStateAdapter$5:
    java.lang.Runnable val$runnable -> if
    android.os.Handler val$handler -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.viewpager2.adapter.FragmentStateAdapter$FragmentMaxLifecycleEnforcer -> androidx.viewpager2.adapter.do$do:
    void updateFragmentMaxLifecycle(boolean) -> do
androidx.viewpager2.adapter.FragmentStateAdapter$FragmentMaxLifecycleEnforcer$3 -> androidx.viewpager2.adapter.FragmentStateAdapter$FragmentMaxLifecycleEnforcer$3:
    androidx.viewpager2.adapter.FragmentStateAdapter$FragmentMaxLifecycleEnforcer this$1 -> do
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> do
androidx.viewpager2.adapter.FragmentViewHolder -> androidx.viewpager2.adapter.if:
    android.widget.FrameLayout getContainer() -> return
com.coderstory.flyme.R$styleable -> for.do.do.do:
com.coderstory.purify.activity.-$$Lambda$MainActivity$2dpfxHXcoNlEV2zWf5QH2x4Vv2g -> com.coderstory.purify.activity.do:
    com.coderstory.purify.activity.-$$Lambda$MainActivity$2dpfxHXcoNlEV2zWf5QH2x4Vv2g INSTANCE -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.activity.-$$Lambda$MainActivity$Alvhb0qhnEyBTNkcKDizXVj2B1o -> com.coderstory.purify.activity.if:
    com.coderstory.purify.activity.-$$Lambda$MainActivity$Alvhb0qhnEyBTNkcKDizXVj2B1o INSTANCE -> if
com.coderstory.purify.activity.-$$Lambda$MainActivity$suLVdv1ZpWgMSjqr-nfrLYaZWLI -> com.coderstory.purify.activity.for:
    com.coderstory.purify.activity.MainActivity f$0 -> do
    boolean onNavigationItemSelected(android.view.MenuItem) -> do
com.coderstory.purify.activity.-$$Lambda$ToolbarActivity$KtLGkIRmCm_wJN5CKMl_V1bquMY -> com.coderstory.purify.activity.int:
    com.coderstory.purify.activity.ToolbarActivity f$0 -> if
com.coderstory.purify.activity.AboutActivity -> com.coderstory.purify.activity.AboutActivity:
    java.lang.String getToolbarTitle() -> float
    androidx.fragment.app.Fragment setFragment() -> short
com.coderstory.purify.activity.MainActivity -> com.coderstory.purify.activity.MainActivity:
    long lastBackKeyDownTick -> double
    android.view.MenuItem mPreMenuItem -> while
    com.google.android.material.navigation.NavigationView mNavigationView -> short
    androidx.appcompat.widget.Toolbar mToolbar -> float
    androidx.fragment.app.FragmentManager mFragmentManager -> super
    com.coderstory.purify.utils.SharedHelper helper -> import
    androidx.drawerlayout.widget.DrawerLayout mDrawerLayout -> final
    androidx.fragment.app.Fragment mCurrentFragment -> throw
    void init() -> catch
    int setLayoutResourceID() -> class
    void lambda$checkEnable$2(per.goweii.anylayer.AnyLayer,android.view.View) -> do
    boolean lambda$setNavigationViewItemClickListener$3(android.view.MenuItem) -> do
    void lambda$setUpView$1(android.content.DialogInterface,int) -> do
    void setUpView() -> final
    void checkEnable() -> float
    void switchFragment(java.lang.Class) -> if
    void initDefaultFragment() -> short
    void requestCameraPermission() -> super
    void setNavigationViewItemClickListener() -> throw
com.coderstory.purify.activity.SplashActivity$1 -> com.coderstory.purify.activity.SplashActivity$do:
    com.coderstory.purify.activity.SplashActivity this$0 -> do
    java.lang.Integer doInBackground(java.lang.Void[]) -> do
    void onPostExecute(java.lang.Integer) -> do
com.coderstory.purify.activity.ToolbarActivity -> com.coderstory.purify.activity.new:
    androidx.fragment.app.FragmentManager mFragmentManager -> float
    androidx.appcompat.widget.Toolbar mToolbar -> final
    void init() -> catch
    int setLayoutResourceID() -> class
    void setUpData() -> const
    void lambda$setUpToolBar$0(android.view.View) -> do
    void setUpView() -> final
    java.lang.String getToolbarTitle() -> float
    androidx.fragment.app.Fragment setFragment() -> short
    void setUpToolBar() -> super
com.coderstory.purify.activity.base.BaseActivity -> com.coderstory.purify.activity.try.do:
    void init() -> catch
    int setLayoutResourceID() -> class
    void setUpData() -> const
    void startActivityWithoutExtras(java.lang.Class) -> do
    void setUpView() -> final
    android.view.View $(int) -> for
com.coderstory.purify.adapter.AppInfo -> com.coderstory.purify.do.do:
    boolean isDisable -> for
    java.lang.String Version -> new
    java.lang.String name -> do
    android.graphics.drawable.Drawable imageId -> if
    java.lang.String releaseDate -> byte
    java.lang.String packageName -> int
    java.lang.String fileSize -> try
    java.lang.String getVersion() -> byte
    boolean getDisable() -> do
    void setDisable(boolean) -> do
    android.graphics.drawable.Drawable getImageId() -> for
    java.lang.String getFileSize() -> if
    java.lang.String getName() -> int
    java.lang.String getPackageName() -> new
    java.lang.String getReleaseDate() -> try
com.coderstory.purify.adapter.AppInfoAdapter -> com.coderstory.purify.do.if:
    int resourceId -> if
com.coderstory.purify.adapter.AppInfoAdapter$1 -> com.coderstory.purify.do.if$do:
com.coderstory.purify.adapter.AppInfoAdapter$ViewHolder -> com.coderstory.purify.do.if$if:
    android.widget.ImageView myImage -> do
    android.widget.TextView myText -> if
com.coderstory.purify.config.Misc -> com.coderstory.purify.if.do:
    boolean isProcessing -> do
    boolean isEnable() -> do
com.coderstory.purify.fragment.-$$Lambda$AboutFragment$TYYr3RPqMheTDpOi2uCUFvxAKTo -> com.coderstory.purify.for.do:
    com.coderstory.purify.fragment.AboutFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$CleanFragment$7jHTuD3zzQhvSMH9P1rFcMfrfp0 -> com.coderstory.purify.for.if:
    com.coderstory.purify.fragment.CleanFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$CleanFragment$cSO5sHtFWVf-5ixr4FTa0W7Qtb0 -> com.coderstory.purify.for.for:
    com.coderstory.purify.fragment.CleanFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$3NBXltVkvM_vtakKOTAPj03-B_g -> com.coderstory.purify.for.int:
    com.coderstory.purify.fragment.DisbaleAppFragment f$0 -> do
    void onRefresh() -> do
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$F-JtIOJY0LOhpqVpMeKXhrgZvyg -> com.coderstory.purify.for.new:
    com.coderstory.purify.fragment.DisbaleAppFragment f$0 -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$Uq_36hl6cUT_mYfP-EytJVDNT_s -> com.coderstory.purify.for.try:
    com.coderstory.purify.fragment.DisbaleAppFragment f$0 -> if
    java.lang.String[] f$1 -> for
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$gMLBidhy09sDqsA0Av2R819FHng -> com.coderstory.purify.for.byte:
    com.coderstory.purify.fragment.DisbaleAppFragment f$0 -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$gZO-B7Lt6uHxGYTCmVoybee3Kvg -> com.coderstory.purify.for.case:
    com.coderstory.purify.fragment.DisbaleAppFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$k6Ua_-g1SrDRL5BdSbH9o8283DE -> com.coderstory.purify.for.char:
    com.coderstory.purify.fragment.DisbaleAppFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$ldSwhPtJ7CNCK0ZI4aEUIHnCf1w -> com.coderstory.purify.for.else:
    com.coderstory.purify.fragment.DisbaleAppFragment f$0 -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$rORTxGpdnI5XLEwHPLcY-ZCvBy8 -> com.coderstory.purify.for.goto:
    com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$rORTxGpdnI5XLEwHPLcY-ZCvBy8 INSTANCE -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$s5Kktp-vzDjrxZPoEdeUUZoK7Y0 -> com.coderstory.purify.for.long:
    com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$s5Kktp-vzDjrxZPoEdeUUZoK7Y0 INSTANCE -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$x_FVrtVQM0VDNETS5Nrj_r_golo -> com.coderstory.purify.for.this:
    com.coderstory.purify.fragment.-$$Lambda$DisbaleAppFragment$x_FVrtVQM0VDNETS5Nrj_r_golo INSTANCE -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$-5JOTE0MVtaq6l_LJCggOFvBGgQ -> com.coderstory.purify.for.void:
    com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$-5JOTE0MVtaq6l_LJCggOFvBGgQ INSTANCE -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$172Xg145yo-6RQmVLsTXAc5Lw-0 -> com.coderstory.purify.for.break:
    com.coderstory.purify.fragment.HideAppFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$2xOZxAE63OOy3g_HT_1fDCv5XLs -> com.coderstory.purify.for.catch:
    com.coderstory.purify.fragment.HideAppFragment f$0 -> do
    void onRefresh() -> do
com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$43KRuAW08DJbmKoPh-QhPD2fwh8 -> com.coderstory.purify.for.class:
    com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$43KRuAW08DJbmKoPh-QhPD2fwh8 INSTANCE -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$Sha1XZ1YwZU_wi6DWCBQfY8fKfY -> com.coderstory.purify.for.const:
    com.coderstory.purify.fragment.HideAppFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$jlJwkrN5OknIkLwpY7Iv5ldhk2g -> com.coderstory.purify.for.final:
    com.coderstory.purify.fragment.HideAppFragment f$0 -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$li6-fywhUjjgVgkFstlsrqpL6L0 -> com.coderstory.purify.for.float:
    com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$li6-fywhUjjgVgkFstlsrqpL6L0 INSTANCE -> if
com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$yvCShwu9hH8m0HkqyVGzerqxZAs -> com.coderstory.purify.for.short:
    com.coderstory.purify.fragment.-$$Lambda$HideAppFragment$yvCShwu9hH8m0HkqyVGzerqxZAs INSTANCE -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$22C0J0kvrTevjjSNFtLMYl9J-Us -> com.coderstory.purify.for.super:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$43yAPXBM202zslNy3mZyp281DvU -> com.coderstory.purify.for.throw:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$6QCO8seGbkab2Ol3RUN8IIjKMPk -> com.coderstory.purify.for.while:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$8aRDL-XTlP-AVlRkzpR70IC2q1s -> com.coderstory.purify.for.double:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$FKu6RIapZLqN8Rswk0X7tvvmf1I -> com.coderstory.purify.for.import:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$Iuj_pK3kvDWvnO9rXXkyUgjYh4I -> com.coderstory.purify.for.native:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$RyieJAKSJGQ1VI3ccn8RMBvPE3o -> com.coderstory.purify.for.public:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$TdPodNTMo7mRsWZklUcPrOLRmFA -> com.coderstory.purify.for.return:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$bRUdODa274L07ybKasl0flZedP8 -> com.coderstory.purify.for.static:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$cfaseFO23jcijDFX0xDI2lnlPrE -> com.coderstory.purify.for.switch:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$lP56__AEIpHZTrK2HsM4Orf5fV4 -> com.coderstory.purify.for.throws:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$oaPQR_8RyJgmxJq5d-hhwjf7PZ8 -> com.coderstory.purify.for.boolean:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$pD2rSJISokBk26cGbuJe0OK26M8 -> com.coderstory.purify.for.default:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$pKgWNvcqMX4EfftY1RDL2EEuT14 -> com.coderstory.purify.for.extends:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$uGz7xySIdBGmc1ejfVZX17c-wOU -> com.coderstory.purify.for.finally:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$vg3wekzBT9hNz7y_fpM2b4T69-M -> com.coderstory.purify.for.package:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$whioVEQR3l0OJLlAyp_ds-hWa1w -> com.coderstory.purify.for.private:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$yyrNQbuWZik2lmMoiWiLARx6tXc -> com.coderstory.purify.for.abstract:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$OthersFragment$ziT1qzi9z54eOj_imjV71C5lP5U -> com.coderstory.purify.for.continue:
    com.coderstory.purify.fragment.OthersFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$SettingsFragment$LlPDgKLrGKegW-Xxqrc1Hr6_uqo -> com.coderstory.purify.for.strictfp:
    com.coderstory.purify.fragment.SettingsFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$SettingsFragment$XNaaHcSWLAC-Mo6woWtPw9iiHZ4 -> com.coderstory.purify.for.volatile:
    com.coderstory.purify.fragment.SettingsFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$SettingsFragment$lYsKXw1pFPLogxLNL9XhowfUt0c -> com.coderstory.purify.for.interface:
    com.coderstory.purify.fragment.SettingsFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$UpdateListFragment$DAD4B1X2BfRAcU_Dh3KMFQZGU6s -> com.coderstory.purify.for.protected:
    com.coderstory.purify.fragment.UpdateListFragment f$0 -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$UpdateListFragment$H1sK94X4_ufPmWeuoxsttNX3cgA -> com.coderstory.purify.for.transient:
    com.coderstory.purify.fragment.UpdateListFragment f$0 -> do
    void onRefresh() -> do
com.coderstory.purify.fragment.-$$Lambda$UpdateListFragment$NPYOLdQeYMqWCcwc_UHMxKauupY -> com.coderstory.purify.for.implements:
    com.coderstory.purify.fragment.UpdateListFragment f$0 -> if
com.coderstory.purify.fragment.-$$Lambda$UpdateListFragment$fxyc0c8Y7JUwHpKGG62NEZu7E_Y -> com.coderstory.purify.for.instanceof:
    com.coderstory.purify.fragment.-$$Lambda$UpdateListFragment$fxyc0c8Y7JUwHpKGG62NEZu7E_Y INSTANCE -> do
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$UpdateListFragment$gHU0BmhAJ8hSp2tRNP-xpOMbn8w -> com.coderstory.purify.for.synchronized:
    com.coderstory.purify.fragment.UpdateListFragment f$0 -> do
    com.coderstory.purify.adapter.AppInfo f$1 -> if
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
com.coderstory.purify.fragment.-$$Lambda$UpdateListFragment$wLM4pDnINzC2Y1Yydvi_YzP62dM -> com.coderstory.purify.for.ʻ:
    com.coderstory.purify.fragment.UpdateListFragment f$0 -> if
com.coderstory.purify.fragment.AboutFragment -> com.coderstory.purify.for.ʼ:
    void lambda$setUpView$5(android.view.View) -> if
    int setLayoutResourceID() -> ﹶ
    void setUpView() -> ﾞﾞ
com.coderstory.purify.fragment.BlogFragment -> com.coderstory.purify.for.ʽ:
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> do
    void shareMsg(java.lang.String,java.lang.String,java.lang.String) -> do
    boolean onOptionsItemSelected(android.view.MenuItem) -> if
    java.lang.String getLoadUrl() -> ʽʽ
com.coderstory.purify.fragment.CleanFragment -> com.coderstory.purify.for.ʾ:
    android.widget.TextView tvClean -> ˉ
    java.lang.Thread th -> ˈ
    android.os.Handler hInfo -> ˊ
    android.os.Handler hComplete -> ˋ
    android.widget.TextView access$000(com.coderstory.purify.fragment.CleanFragment) -> do
    android.view.View access$100(com.coderstory.purify.fragment.CleanFragment,int) -> do
    android.view.View access$300(com.coderstory.purify.fragment.CleanFragment,int) -> for
    com.coderstory.purify.fragment.CleanFragment$CacheSize getSize(java.lang.String) -> for
    android.view.View access$200(com.coderstory.purify.fragment.CleanFragment,int) -> if
    void deleteCache(java.lang.String) -> if
    void lambda$setUpView$6(android.view.View) -> if
    void sendMessageStr(java.lang.String) -> int
    void lambda$threadClean$7() -> ʻʻ
    void deleteAnrLog() -> ʼʼ
    void threadClean() -> ʽʽ
    int setLayoutResourceID() -> ﹶ
    void setUpView() -> ﾞﾞ
com.coderstory.purify.fragment.CleanFragment$1 -> com.coderstory.purify.for.ʾ$do:
    com.coderstory.purify.fragment.CleanFragment this$0 -> do
com.coderstory.purify.fragment.CleanFragment$2 -> com.coderstory.purify.for.ʾ$if:
    com.coderstory.purify.fragment.CleanFragment this$0 -> do
com.coderstory.purify.fragment.CleanFragment$CacheSize -> com.coderstory.purify.for.ʾ$for:
    java.lang.String sizeReadable -> do
    long size -> if
com.coderstory.purify.fragment.DisbaleAppFragment -> com.coderstory.purify.for.ʿ:
    int mposition -> ˎ
    android.widget.ListView listView -> ˊ
    com.coderstory.purify.view.PullToRefreshView mPullToRefreshView -> ˑ
    java.util.List appInfoList2 -> ـ
    android.os.Handler myHandler -> ᐧ
    android.view.View mview -> ˏ
    java.util.List appInfoList -> י
    java.util.List packages -> ˈ
    com.coderstory.purify.adapter.AppInfo appInfo -> ˋ
    com.coderstory.purify.adapter.AppInfoAdapter adapter -> ˉ
    android.app.Dialog dialog -> ٴ
    android.app.Dialog access$000(com.coderstory.purify.fragment.DisbaleAppFragment) -> do
    android.app.Dialog access$002(com.coderstory.purify.fragment.DisbaleAppFragment,android.app.Dialog) -> do
    void lambda$null$9(per.goweii.anylayer.AnyLayer,android.view.View) -> do
    void lambda$restoreList$17(java.lang.String[]) -> do
    void lambda$showData$10(android.widget.AdapterView,android.view.View,int,long) -> do
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> do
    void access$200(com.coderstory.purify.fragment.DisbaleAppFragment) -> for
    void lambda$onOptionsItemSelected$16(per.goweii.anylayer.AnyLayer,android.view.View) -> for
    void access$100(com.coderstory.purify.fragment.DisbaleAppFragment) -> if
    void lambda$onOptionsItemSelected$14(per.goweii.anylayer.AnyLayer,android.view.View) -> if
    boolean onOptionsItemSelected(android.view.MenuItem) -> if
    void lambda$null$8(per.goweii.anylayer.AnyLayer,android.view.View) -> int
    void lambda$onOptionsItemSelected$13(per.goweii.anylayer.AnyLayer,android.view.View) -> new
    void onDestroyView() -> protected
    void lambda$onOptionsItemSelected$15(per.goweii.anylayer.AnyLayer,android.view.View) -> try
    void closeProgress() -> ʻʻ
    void lambda$null$11() -> ʼʼ
    void lambda$init$12() -> ʽʽ
    void initData() -> ʾʾ
    void showProgress() -> ʿʿ
    void restoreList() -> ˆˆ
    void showData() -> ˈˈ
    void satrtBackuop() -> ˉˉ
    void initFruit() -> ــ
    void init() -> ﹳ
    int setLayoutResourceID() -> ﹶ
com.coderstory.purify.fragment.DisbaleAppFragment$1 -> com.coderstory.purify.for.ʿ$do:
    com.coderstory.purify.fragment.DisbaleAppFragment this$0 -> do
com.coderstory.purify.fragment.DisbaleAppFragment$MyTask -> com.coderstory.purify.for.ʿ$if:
    com.coderstory.purify.fragment.DisbaleAppFragment this$0 -> do
    java.lang.String doInBackground(java.lang.String[]) -> do
    void onPostExecute(java.lang.String) -> do
    void onProgressUpdate(java.lang.Integer[]) -> do
com.coderstory.purify.fragment.HideAppFragment -> com.coderstory.purify.for.ˆ:
    com.coderstory.purify.view.PullToRefreshView mPullToRefreshView -> ˏ
    java.util.List hideAppList -> ˑ
    java.util.List appInfoList2 -> ـ
    com.coderstory.purify.adapter.AppInfo appInfo -> ˊ
    int mPosition -> ˋ
    android.view.View mView -> ˎ
    java.util.List appInfoList -> י
    java.util.List packages -> ˈ
    com.coderstory.purify.adapter.AppInfoAdapter adapter -> ˉ
    android.app.Dialog dialog -> ٴ
    void access$000(com.coderstory.purify.fragment.HideAppFragment) -> do
    void lambda$null$19(per.goweii.anylayer.AnyLayer,android.view.View) -> do
    void lambda$showData$20(android.widget.AdapterView,android.view.View,int,long) -> do
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> do
    void access$200(com.coderstory.purify.fragment.HideAppFragment) -> for
    void lambda$onOptionsItemSelected$23(per.goweii.anylayer.AnyLayer,android.view.View) -> for
    com.coderstory.purify.adapter.AppInfoAdapter access$100(com.coderstory.purify.fragment.HideAppFragment) -> if
    void lambda$null$18(per.goweii.anylayer.AnyLayer,android.view.View) -> if
    boolean onOptionsItemSelected(android.view.MenuItem) -> if
    void lambda$onOptionsItemSelected$25(per.goweii.anylayer.AnyLayer,android.view.View) -> int
    void closeProgress() -> ʻʻ
    void lambda$null$21() -> ʼʼ
    void lambda$init$22() -> ʽʽ
    void initData() -> ʾʾ
    void showProgress() -> ʿʿ
    void lambda$null$24() -> ˆˆ
    void showData() -> ˉˉ
    void initFruit() -> ــ
    void init() -> ﹳ
    int setLayoutResourceID() -> ﹶ
com.coderstory.purify.fragment.HideAppFragment$MyTask -> com.coderstory.purify.for.ˆ$do:
    com.coderstory.purify.fragment.HideAppFragment this$0 -> do
    java.lang.String doInBackground(java.lang.String[]) -> do
    void onPostExecute(java.lang.String) -> do
com.coderstory.purify.fragment.OthersFragment -> com.coderstory.purify.for.ˈ:
    void lambda$setUpView$39(android.view.View) -> break
    void lambda$setUpView$31(android.view.View) -> byte
    void lambda$setUpView$32(android.view.View) -> case
    void lambda$setUpView$40(android.view.View) -> catch
    void lambda$setUpView$33(android.view.View) -> char
    void lambda$setUpView$41(android.view.View) -> class
    void lambda$setUpView$42(android.view.View) -> const
    void lambda$setUpView$34(android.view.View) -> else
    void lambda$setUpView$43(android.view.View) -> final
    void lambda$setUpView$44(android.view.View) -> float
    void lambda$setUpView$27(android.view.View) -> for
    void lambda$setUpView$35(android.view.View) -> goto
    void lambda$setUpView$26(android.view.View) -> if
    void lambda$setUpView$28(android.view.View) -> int
    void lambda$setUpView$36(android.view.View) -> long
    void lambda$setUpView$29(android.view.View) -> new
    void lambda$setUpView$37(android.view.View) -> this
    void lambda$setUpView$30(android.view.View) -> try
    void lambda$setUpView$38(android.view.View) -> void
    int setLayoutResourceID() -> ﹶ
    void setUpData() -> ﾞ
    void setUpView() -> ﾞﾞ
com.coderstory.purify.fragment.SettingsFragment -> com.coderstory.purify.for.ˉ:
    void lambda$setUpView$46(android.view.View) -> for
    void lambda$setUpView$45(android.view.View) -> if
    void lambda$setUpView$47(android.view.View) -> int
    int setLayoutResourceID() -> ﹶ
    void setUpData() -> ﾞ
    void setUpView() -> ﾞﾞ
com.coderstory.purify.fragment.UpdateListFragment -> com.coderstory.purify.for.ˊ:
    android.app.Dialog dialog -> ˋ
    java.util.List appInfos -> ˊ
    com.coderstory.purify.view.PullToRefreshView mPullToRefreshView -> ˉ
    com.coderstory.purify.adapter.AppInfoAdapter adapter -> ˈ
    void access$000(com.coderstory.purify.fragment.UpdateListFragment) -> do
    void lambda$null$50(com.coderstory.purify.adapter.AppInfo,per.goweii.anylayer.AnyLayer,android.view.View) -> do
    void lambda$onOptionsItemSelected$49(per.goweii.anylayer.AnyLayer,android.view.View) -> do
    void lambda$showData$51(android.widget.AdapterView,android.view.View,int,long) -> do
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> do
    void access$200(com.coderstory.purify.fragment.UpdateListFragment) -> for
    com.coderstory.purify.adapter.AppInfoAdapter access$100(com.coderstory.purify.fragment.UpdateListFragment) -> if
    void lambda$onOptionsItemSelected$48(per.goweii.anylayer.AnyLayer,android.view.View) -> if
    boolean onOptionsItemSelected(android.view.MenuItem) -> if
    void onResume() -> instanceof
    void closeProgress() -> ʻʻ
    void lambda$null$52() -> ʼʼ
    void lambda$init$53() -> ʽʽ
    void initData() -> ʾʾ
    void showProgress() -> ʿʿ
    void showData() -> ˆˆ
    void initFruit() -> ــ
    void init() -> ﹳ
    int setLayoutResourceID() -> ﹶ
com.coderstory.purify.fragment.UpdateListFragment$MyTask -> com.coderstory.purify.for.ˊ$do:
    com.coderstory.purify.fragment.UpdateListFragment this$0 -> do
    java.lang.String doInBackground(java.lang.String[]) -> do
    void onPostExecute(java.lang.String) -> do
    void onProgressUpdate(java.lang.Integer[]) -> do
com.coderstory.purify.fragment.WebViewFragment -> com.coderstory.purify.for.ˋ:
    android.webkit.WebView mWebView -> ˈ
    android.widget.ProgressBar mProgressBar -> ˉ
    void onPause() -> implements
    void onResume() -> instanceof
    void onDestroy() -> volatile
    boolean canGoBack() -> ʻʻ
    void goBack() -> ʼʼ
    java.lang.String getLoadUrl() -> ʽʽ
    void initWebViewSettings() -> ʿʿ
    int setLayoutResourceID() -> ﹶ
    void setUpView() -> ﾞﾞ
com.coderstory.purify.fragment.WebViewFragment$MyWebChromeClient -> com.coderstory.purify.for.ˋ$do:
    com.coderstory.purify.fragment.WebViewFragment this$0 -> do
com.coderstory.purify.fragment.WebViewFragment$MyWebViewClient -> com.coderstory.purify.for.ˋ$if:
com.coderstory.purify.fragment.base.-$$Lambda$BaseFragment$K4s-WpxvM1WTuVuQols8TmDhCfk -> com.coderstory.purify.for.ˎ.do:
    com.coderstory.purify.fragment.base.-$$Lambda$BaseFragment$K4s-WpxvM1WTuVuQols8TmDhCfk INSTANCE -> if
com.coderstory.purify.fragment.base.BaseFragment -> com.coderstory.purify.for.ˎ.if:
    android.view.View mContentView -> ʽ
    android.content.Context mContext -> ʾ
    android.content.SharedPreferences prefs -> ʿ
    android.content.SharedPreferences$Editor editor -> ˆ
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> do
    android.view.View $(int) -> int
    void sudoFixPermissions() -> ᐧᐧ
    void fix() -> ᴵ
    void lambda$sudoFixPermissions$4() -> ᴵᴵ
    android.view.View getContentView() -> ᵎ
    android.content.SharedPreferences$Editor getEditor() -> ᵔ
    android.content.Context getMContext() -> ᵢ
    android.content.SharedPreferences getPrefs() -> ⁱ
    void init() -> ﹳ
    int setLayoutResourceID() -> ﹶ
    void setUpData() -> ﾞ
    void setUpView() -> ﾞﾞ
com.coderstory.purify.module.FlymeHome -> com.coderstory.purify.int.do:
    void handleInitPackageResources(de.robv.android.xposed.callbacks.XC_InitPackageResources$InitPackageResourcesParam) -> do
    void handleLoadPackage(de.robv.android.xposed.callbacks.XC_LoadPackage$LoadPackageParam) -> do
    void hook55(java.lang.Class) -> do
com.coderstory.purify.module.FlymeHome$1 -> com.coderstory.purify.int.do$do:
com.coderstory.purify.module.FlymeHome$2 -> com.coderstory.purify.int.do$if:
com.coderstory.purify.module.FlymeHome$3 -> com.coderstory.purify.int.do$for:
    java.lang.String val$finalType -> do
com.coderstory.purify.module.FlymeHome$4 -> com.coderstory.purify.int.do$int:
    java.lang.String val$finalType -> do
com.coderstory.purify.module.FlymeRoot -> com.coderstory.purify.int.if:
    void handleInitPackageResources(de.robv.android.xposed.callbacks.XC_InitPackageResources$InitPackageResourcesParam) -> do
    void handleLoadPackage(de.robv.android.xposed.callbacks.XC_LoadPackage$LoadPackageParam) -> do
com.coderstory.purify.module.HideApp -> com.coderstory.purify.int.for:
    void handleLoadPackage(de.robv.android.xposed.callbacks.XC_LoadPackage$LoadPackageParam) -> do
com.coderstory.purify.module.HideApp$1 -> com.coderstory.purify.int.for$do:
    java.util.List val$hideAppList -> do
com.coderstory.purify.module.HideApp$2 -> com.coderstory.purify.int.for$if:
    java.util.List val$hideAppList -> do
com.coderstory.purify.module.IsEnable -> com.coderstory.purify.int.int:
    void handleLoadPackage(de.robv.android.xposed.callbacks.XC_LoadPackage$LoadPackageParam) -> do
com.coderstory.purify.module.Others -> com.coderstory.purify.int.new:
    android.content.Context mContext -> if
    de.robv.android.xposed.XSharedPreferences access$000(com.coderstory.purify.module.Others) -> do
    android.content.Context access$402(android.content.Context) -> do
    boolean handleInfo(java.lang.Object) -> do
    void handleLoadPackage(de.robv.android.xposed.callbacks.XC_LoadPackage$LoadPackageParam) -> do
    de.robv.android.xposed.XSharedPreferences access$200(com.coderstory.purify.module.Others) -> for
    de.robv.android.xposed.XSharedPreferences access$100(com.coderstory.purify.module.Others) -> if
    de.robv.android.xposed.XSharedPreferences access$300(com.coderstory.purify.module.Others) -> int
com.coderstory.purify.module.Others$1 -> com.coderstory.purify.int.new$do:
    com.coderstory.purify.module.Others this$0 -> do
com.coderstory.purify.module.Others$2 -> com.coderstory.purify.int.new$if:
com.coderstory.purify.module.Others$3 -> com.coderstory.purify.int.new$for:
com.coderstory.purify.module.Others$4 -> com.coderstory.purify.int.new$int:
com.coderstory.purify.module.Others$5 -> com.coderstory.purify.int.new$new:
    com.coderstory.purify.module.Others this$0 -> do
com.coderstory.purify.module.RemoveAds -> com.coderstory.purify.int.try:
    void handleLoadPackage(de.robv.android.xposed.callbacks.XC_LoadPackage$LoadPackageParam) -> do
com.coderstory.purify.module.RemoveAds$1 -> com.coderstory.purify.int.try$do:
    java.lang.Class val$finalClazz -> do
com.coderstory.purify.module.RemoveAds$2 -> com.coderstory.purify.int.try$if:
com.coderstory.purify.module.ThemePatcher -> com.coderstory.purify.int.byte:
    void handleLoadPackage(de.robv.android.xposed.callbacks.XC_LoadPackage$LoadPackageParam) -> do
com.coderstory.purify.module.ThemePatcher$1 -> com.coderstory.purify.int.byte$do:
com.coderstory.purify.module.ThemePatcher$2 -> com.coderstory.purify.int.byte$if:
com.coderstory.purify.preferences.PreferencesProvider -> com.coderstory.purify.new.do:
    java.lang.String mStringPath -> for
    android.content.UriMatcher mUriMatcher -> if
    java.lang.String mLongPath -> new
    java.lang.String mBooleanPath -> byte
    java.lang.String mIntegerPath -> int
    java.lang.String mDeletePath -> case
    java.lang.String COLUMNNAME -> else
    java.lang.String AUTHORITIES_SPNAME -> long
    java.lang.String mPutsPath -> char
    java.lang.String mFloatPath -> try
    java.lang.String AUTHORITIES_KEY -> goto
    android.database.Cursor buildCursor(android.content.Context,com.coderstory.purify.preferences.PreferencesProvider$Model,int) -> do
    void delete(android.content.Context,com.coderstory.purify.preferences.PreferencesProvider$Model) -> do
    java.lang.String getAuthorities() -> do
    com.coderstory.purify.preferences.PreferencesProvider$Model getModel(android.net.Uri) -> do
    void insert(android.content.Context,android.content.ContentValues,com.coderstory.purify.preferences.PreferencesProvider$Model) -> do
com.coderstory.purify.preferences.PreferencesProvider$1 -> com.coderstory.purify.new.do$do:
com.coderstory.purify.preferences.PreferencesProvider$Model -> com.coderstory.purify.new.do$if:
    java.lang.Object defValue -> for
    java.lang.String spName -> do
    java.lang.String key -> if
    java.lang.Object getDefValue() -> do
    void setDefValue(java.lang.Object) -> do
    void setKey(java.lang.String) -> do
    java.lang.String getSpName() -> for
    java.lang.String getKey() -> if
    void setSpName(java.lang.String) -> if
com.coderstory.purify.preferences.PreferencesProviderUtils -> com.coderstory.purify.new.if:
    android.net.Uri buildUri(int,java.lang.String,java.lang.String,java.lang.Object) -> do
    boolean getBoolean(android.content.Context,java.lang.String,java.lang.String,boolean) -> do
    boolean putFloat(android.content.Context,java.lang.String,java.lang.String,float) -> do
    boolean putInt(android.content.Context,java.lang.String,java.lang.String,int) -> do
    boolean putLong(android.content.Context,java.lang.String,java.lang.String,long) -> do
    boolean putString(android.content.Context,java.lang.String,java.lang.String,java.lang.String) -> do
    boolean putBoolean(android.content.Context,java.lang.String,java.lang.String,boolean) -> if
com.coderstory.purify.preferences.PreferencesUtils -> com.coderstory.purify.new.for:
    boolean getBoolean(android.content.Context,java.lang.String,java.lang.String) -> do
    boolean getBoolean(android.content.Context,java.lang.String,java.lang.String,boolean) -> do
    android.content.SharedPreferences$Editor getEditor(android.content.Context,java.lang.String) -> do
    float getFloat(android.content.Context,java.lang.String,java.lang.String,float) -> do
    int getInt(android.content.Context,java.lang.String,java.lang.String,int) -> do
    long getLong(android.content.Context,java.lang.String,java.lang.String,long) -> do
    java.lang.String getString(android.content.Context,java.lang.String,java.lang.String,java.lang.String) -> do
    int getInt(android.content.Context,java.lang.String,java.lang.String) -> for
    float getFloat(android.content.Context,java.lang.String,java.lang.String) -> if
    boolean putString(android.content.Context,java.lang.String,java.lang.String,java.lang.String) -> if
    long getLong(android.content.Context,java.lang.String,java.lang.String) -> int
    java.lang.String getString(android.content.Context,java.lang.String,java.lang.String) -> new
com.coderstory.purify.preferencesProvider -> com.coderstory.purify.preferencesProvider:
    java.lang.String getAuthorities() -> do
com.coderstory.purify.refresh_view.-$$Lambda$SunRefreshView$InwPpdlRak20C4saJBDYeXKItzE -> com.coderstory.purify.try.do:
    com.coderstory.purify.refresh_view.SunRefreshView f$0 -> if
    com.coderstory.purify.view.PullToRefreshView f$1 -> for
com.coderstory.purify.refresh_view.BaseRefreshView -> com.coderstory.purify.try.if:
    com.coderstory.purify.view.PullToRefreshView mRefreshLayout -> if
    android.content.Context getContext() -> do
    void offsetTopAndBottom(int) -> do
    void setPercent(float,boolean) -> do
com.coderstory.purify.refresh_view.SunRefreshView -> com.coderstory.purify.try.for:
    int mSunSize -> break
    android.graphics.Bitmap mSun -> short
    com.coderstory.purify.view.PullToRefreshView mParent -> for
    float mTownMoveOffset -> void
    int mTop -> try
    float mSunLeftOffset -> catch
    int mTownHeight -> goto
    android.graphics.Bitmap mSky -> float
    android.view.animation.Animation mAnimation -> new
    float mSkyMoveOffset -> else
    android.view.animation.Interpolator LINEAR_INTERPOLATOR -> while
    float mSkyTopOffset -> char
    float mTownInitialTopOffset -> long
    float mPercent -> const
    int mScreenWidth -> byte
    float mSunTopOffset -> class
    android.graphics.Matrix mMatrix -> int
    int mSkyHeight -> case
    float mTownFinalTopOffset -> this
    boolean isRefreshing -> throw
    float mRotate -> final
    android.graphics.Bitmap mTown -> super
    void access$000(com.coderstory.purify.refresh_view.SunRefreshView,float) -> do
    void drawSky(android.graphics.Canvas) -> do
    void lambda$new$54(com.coderstory.purify.view.PullToRefreshView) -> do
    void offsetTopAndBottom(int) -> do
    void setPercent(float) -> do
    void setPercent(float,boolean) -> do
    void drawTown(android.graphics.Canvas) -> for
    void resetOriginals() -> for
    void createBitmaps() -> if
    void drawSun(android.graphics.Canvas) -> if
    void initiateDimens(int) -> if
    void setRotate(float) -> if
    void setupAnimations() -> int
com.coderstory.purify.refresh_view.SunRefreshView$1 -> com.coderstory.purify.try.for$do:
    com.coderstory.purify.refresh_view.SunRefreshView this$0 -> if
com.coderstory.purify.utils.FileUtils -> com.coderstory.purify.utils.do:
    java.lang.String readFile(java.lang.String,java.lang.String) -> do
    java.lang.String removeBomHeaderIfExists(java.lang.String) -> do
com.coderstory.purify.utils.SharedHelper -> com.coderstory.purify.utils.if:
    android.content.Context context -> if
    java.lang.String spName -> do
    boolean getBoolean(java.lang.String,boolean) -> do
    void put(java.lang.String,java.lang.Object) -> do
com.coderstory.purify.utils.SnackBarUtils -> com.coderstory.purify.utils.for:
    com.google.android.material.snackbar.Snackbar mSnackbar -> do
    void danger() -> do
    android.view.View getSnackBarLayout(com.google.android.material.snackbar.Snackbar) -> do
    com.coderstory.purify.utils.SnackBarUtils makeLong(android.view.View,java.lang.String) -> do
    com.google.android.material.snackbar.Snackbar setSnackBarBackColor(int) -> do
    void show() -> for
    void info() -> if
    com.coderstory.purify.utils.SnackBarUtils makeShort(android.view.View,java.lang.String) -> if
com.coderstory.purify.utils.SuHelper -> com.coderstory.purify.utils.int:
    java.util.List execute() -> do
    java.util.ArrayList getCommandsToExecute() -> if
com.coderstory.purify.utils.Utils -> com.coderstory.purify.utils.new:
    int convertDpToPixel(android.content.Context,int) -> do
com.coderstory.purify.utils.ViewUtils -> com.coderstory.purify.utils.try:
    java.util.Map fragmentList -> do
    com.coderstory.purify.fragment.base.BaseFragment createFragment(java.lang.Class) -> do
    com.coderstory.purify.fragment.base.BaseFragment createFragment(java.lang.Class,boolean) -> do
com.coderstory.purify.utils.XposedHelper -> com.coderstory.purify.utils.byte:
    de.robv.android.xposed.XSharedPreferences prefs -> do
    void findAndHookMethod(java.lang.Class,java.lang.String,java.lang.Object[]) -> do
    void findAndHookMethod(java.lang.String,java.lang.ClassLoader,java.lang.String,java.lang.Object[]) -> do
    java.lang.Class findClassWithoutLog(java.lang.String,java.lang.ClassLoader) -> do
    void hookAllConstructors(java.lang.Class,de.robv.android.xposed.XC_MethodHook) -> do
    int hookAllMethods(java.lang.String,java.lang.ClassLoader,java.lang.String,de.robv.android.xposed.XC_MethodHook) -> do
    java.util.Set hookAllMethods(java.lang.Class,java.lang.String,de.robv.android.xposed.XC_MethodHook) -> do
    void writeFile(java.io.File,java.io.File) -> do
    java.lang.Class findClass(java.lang.String,java.lang.ClassLoader) -> if
com.coderstory.purify.utils.hostshelper.FileHelper -> com.coderstory.purify.utils.case.do:
    java.lang.String getFromAssets(java.lang.String,android.content.Context) -> do
    java.lang.String getReadableFileSize(long) -> do
com.coderstory.purify.utils.hostshelper.HostsHelper -> com.coderstory.purify.utils.case.if:
    android.content.Context mcontext -> if
    java.lang.String mcontent -> do
    java.util.ArrayList getCommandsToExecute() -> if
com.coderstory.purify.utils.licensesdialog.LicenseResolver -> com.coderstory.purify.utils.char.do:
    java.util.Map sLicenses -> do
    com.coderstory.purify.utils.licensesdialog.licenses.License read(java.lang.String) -> do
    void registerDefaultLicenses() -> do
    void registerLicense(com.coderstory.purify.utils.licensesdialog.licenses.License) -> do
com.coderstory.purify.utils.licensesdialog.LicensesDialog -> com.coderstory.purify.utils.char.if:
    java.lang.String mLicensesText -> for
    android.content.DialogInterface$OnDismissListener mOnDismissListener -> byte
    java.lang.String mTitleText -> if
    com.coderstory.purify.utils.licensesdialog.model.Notice LICENSES_DIALOG_NOTICE -> case
    java.lang.String mCloseText -> int
    int mThemeResourceId -> new
    android.content.Context mContext -> do
    int mDividerColor -> try
    android.content.DialogInterface$OnDismissListener access$000(com.coderstory.purify.utils.licensesdialog.LicensesDialog) -> do
    java.lang.String access$400(android.content.Context,com.coderstory.purify.utils.licensesdialog.model.Notices,boolean,boolean,java.lang.String) -> do
    com.coderstory.purify.utils.licensesdialog.model.Notices access$500(android.content.Context,int) -> do
    android.app.Dialog create() -> do
    android.webkit.WebView createWebView(android.content.Context) -> do
    android.content.Context access$200(com.coderstory.purify.utils.licensesdialog.LicensesDialog) -> for
    int access$100(com.coderstory.purify.utils.licensesdialog.LicensesDialog) -> if
    java.lang.String getLicensesText(android.content.Context,com.coderstory.purify.utils.licensesdialog.model.Notices,boolean,boolean,java.lang.String) -> if
    com.coderstory.purify.utils.licensesdialog.model.Notices getNotices(android.content.Context,int) -> if
    android.app.Dialog show() -> if
com.coderstory.purify.utils.licensesdialog.LicensesDialog$1 -> com.coderstory.purify.utils.char.if$do:
    android.content.Context val$context -> do
com.coderstory.purify.utils.licensesdialog.LicensesDialog$2 -> com.coderstory.purify.utils.char.if$if:
com.coderstory.purify.utils.licensesdialog.LicensesDialog$3 -> com.coderstory.purify.utils.char.if$for:
    com.coderstory.purify.utils.licensesdialog.LicensesDialog this$0 -> if
com.coderstory.purify.utils.licensesdialog.LicensesDialog$4 -> com.coderstory.purify.utils.char.if$int:
    com.coderstory.purify.utils.licensesdialog.LicensesDialog this$0 -> if
    android.app.AlertDialog val$dialog -> do
com.coderstory.purify.utils.licensesdialog.LicensesDialog$Builder -> com.coderstory.purify.utils.char.if$new:
    java.lang.String mCloseText -> for
    java.lang.Integer mRawNoticesId -> int
    com.coderstory.purify.utils.licensesdialog.model.Notices mNotices -> new
    boolean mShowFullLicenseText -> case
    int mThemeResourceId -> else
    java.lang.String mNoticesStyle -> byte
    java.lang.String mTitleText -> if
    android.content.Context mContext -> do
    boolean mIncludeOwnLicense -> char
    int mDividerColor -> goto
    java.lang.String mNoticesText -> try
    com.coderstory.purify.utils.licensesdialog.LicensesDialog build() -> do
    com.coderstory.purify.utils.licensesdialog.LicensesDialog$Builder setNotices(com.coderstory.purify.utils.licensesdialog.model.Notices) -> do
com.coderstory.purify.utils.licensesdialog.NoticesHtmlBuilder -> com.coderstory.purify.utils.char.for:
    com.coderstory.purify.utils.licensesdialog.model.Notices mNotices -> for
    java.util.Map mLicenseTextCache -> if
    java.lang.String mStyle -> new
    com.coderstory.purify.utils.licensesdialog.model.Notice mNotice -> int
    android.content.Context mContext -> do
    boolean mShowFullLicenseText -> try
    void appendNoticeBlock(java.lang.StringBuilder,com.coderstory.purify.utils.licensesdialog.model.Notice) -> do
    void appendNoticesContainerEnd(java.lang.StringBuilder) -> do
    java.lang.String build() -> do
    com.coderstory.purify.utils.licensesdialog.NoticesHtmlBuilder create(android.content.Context) -> do
    java.lang.String getLicenseText(com.coderstory.purify.utils.licensesdialog.licenses.License) -> do
    com.coderstory.purify.utils.licensesdialog.NoticesHtmlBuilder setNotices(com.coderstory.purify.utils.licensesdialog.model.Notices) -> do
    com.coderstory.purify.utils.licensesdialog.NoticesHtmlBuilder setShowFullLicenseText(boolean) -> do
    com.coderstory.purify.utils.licensesdialog.NoticesHtmlBuilder setStyle(java.lang.String) -> do
    void appendNoticesContainerStart(java.lang.StringBuilder) -> if
com.coderstory.purify.utils.licensesdialog.NoticesXmlParser -> com.coderstory.purify.utils.char.int:
    java.lang.String readUrl(org.xmlpull.v1.XmlPullParser) -> byte
    void skip(org.xmlpull.v1.XmlPullParser) -> case
    com.coderstory.purify.utils.licensesdialog.model.Notices parse(java.io.InputStream) -> do
    com.coderstory.purify.utils.licensesdialog.model.Notices parse(org.xmlpull.v1.XmlPullParser) -> do
    java.lang.String readTag(org.xmlpull.v1.XmlPullParser,java.lang.String) -> do
    com.coderstory.purify.utils.licensesdialog.licenses.License readLicense(org.xmlpull.v1.XmlPullParser) -> for
    java.lang.String readCopyright(org.xmlpull.v1.XmlPullParser) -> if
    java.lang.String readName(org.xmlpull.v1.XmlPullParser) -> int
    com.coderstory.purify.utils.licensesdialog.model.Notice readNotice(org.xmlpull.v1.XmlPullParser) -> new
    java.lang.String readText(org.xmlpull.v1.XmlPullParser) -> try
com.coderstory.purify.utils.licensesdialog.licenses.ApacheSoftwareLicense20 -> com.coderstory.purify.utils.char.new.do:
    java.lang.String getName() -> do
    java.lang.String readFullTextFromResources(android.content.Context) -> for
    java.lang.String readSummaryTextFromResources(android.content.Context) -> int
com.coderstory.purify.utils.licensesdialog.licenses.GnuGeneralPublicLicense20 -> com.coderstory.purify.utils.char.new.if:
    java.lang.String getName() -> do
    java.lang.String readFullTextFromResources(android.content.Context) -> for
    java.lang.String readSummaryTextFromResources(android.content.Context) -> int
com.coderstory.purify.utils.licensesdialog.licenses.License -> com.coderstory.purify.utils.char.new.for:
    java.lang.String mCachedFullText -> for
    java.lang.String mCachedSummaryText -> if
    java.lang.String LINE_SEPARATOR -> int
    java.lang.String getContent(android.content.Context,int) -> do
    java.lang.String getFullText(android.content.Context) -> do
    java.lang.String getName() -> do
    java.lang.String toString(java.io.BufferedReader) -> do
    java.lang.String readFullTextFromResources(android.content.Context) -> for
    java.lang.String getSummaryText(android.content.Context) -> if
    java.lang.String readSummaryTextFromResources(android.content.Context) -> int
com.coderstory.purify.utils.licensesdialog.model.Notice -> com.coderstory.purify.utils.char.try.do:
    java.lang.String mUrl -> for
    com.coderstory.purify.utils.licensesdialog.licenses.License mLicense -> new
    java.lang.String mName -> if
    java.lang.String mCopyright -> int
    java.lang.String getUrl() -> byte
    java.lang.String getCopyright() -> int
    com.coderstory.purify.utils.licensesdialog.licenses.License getLicense() -> new
    java.lang.String getName() -> try
com.coderstory.purify.utils.licensesdialog.model.Notice$1 -> com.coderstory.purify.utils.char.try.do$do:
com.coderstory.purify.utils.licensesdialog.model.Notices -> com.coderstory.purify.utils.char.try.if:
    java.util.List mNotices -> if
    void addNotice(com.coderstory.purify.utils.licensesdialog.model.Notice) -> do
    java.util.List getNotices() -> int
com.coderstory.purify.utils.licensesdialog.model.Notices$1 -> com.coderstory.purify.utils.char.try.if$do:
com.coderstory.purify.view.PullToRefreshView -> com.coderstory.purify.view.PullToRefreshView:
    android.widget.ImageView mRefreshView -> for
    com.coderstory.purify.view.PullToRefreshView$OnRefreshListener mListener -> const
    android.view.animation.Interpolator mDecelerateInterpolator -> int
    android.view.View mTarget -> if
    int mTargetPaddingBottom -> float
    android.view.animation.Animation mAnimateToStartPosition -> throw
    int mTotalDragDistance -> try
    int mActivePointerId -> goto
    boolean mIsBeingDragged -> long
    com.coderstory.purify.refresh_view.BaseRefreshView mBaseRefreshView -> byte
    int mFrom -> void
    int mTargetPaddingLeft -> super
    boolean mRefreshing -> else
    int mTargetPaddingTop -> final
    android.view.animation.Animation$AnimationListener mToStartListener -> while
    int mTouchSlop -> new
    boolean mNotify -> class
    int mCurrentOffsetTop -> char
    float mCurrentDragPercent -> case
    float mInitialMotionY -> this
    float mFromDragPercent -> break
    android.view.animation.Animation mAnimateToCorrectPosition -> catch
    int mTargetPaddingRight -> short
    int access$000(com.coderstory.purify.view.PullToRefreshView) -> do
    float access$302(com.coderstory.purify.view.PullToRefreshView,float) -> do
    void access$600(com.coderstory.purify.view.PullToRefreshView,int,boolean) -> do
    int access$802(com.coderstory.purify.view.PullToRefreshView,int) -> do
    void animateOffsetToCorrectPosition() -> do
    float getMotionEventY(android.view.MotionEvent,int) -> do
    void moveToStart(float) -> do
    void onSecondaryPointerUp(android.view.MotionEvent) -> do
    void setRefreshing(boolean,boolean) -> do
    void setTargetOffsetTop(int,boolean) -> do
    android.view.View access$200(com.coderstory.purify.view.PullToRefreshView) -> for
    boolean canChildScrollUp() -> for
    int access$100(com.coderstory.purify.view.PullToRefreshView) -> if
    void access$700(com.coderstory.purify.view.PullToRefreshView,float) -> if
    void animateOffsetToStartPosition() -> if
    float access$300(com.coderstory.purify.view.PullToRefreshView) -> int
    void ensureTarget() -> int
    float access$400(com.coderstory.purify.view.PullToRefreshView) -> new
    com.coderstory.purify.refresh_view.BaseRefreshView access$500(com.coderstory.purify.view.PullToRefreshView) -> try
com.coderstory.purify.view.PullToRefreshView$1 -> com.coderstory.purify.view.PullToRefreshView$do:
    com.coderstory.purify.view.PullToRefreshView this$0 -> if
com.coderstory.purify.view.PullToRefreshView$2 -> com.coderstory.purify.view.PullToRefreshView$if:
    com.coderstory.purify.view.PullToRefreshView this$0 -> if
com.coderstory.purify.view.PullToRefreshView$3 -> com.coderstory.purify.view.PullToRefreshView$for:
    com.coderstory.purify.view.PullToRefreshView this$0 -> do
com.coderstory.purify.view.PullToRefreshView$OnRefreshListener -> com.coderstory.purify.view.PullToRefreshView$int:
    void onRefresh() -> do
com.google.android.material.R$animator -> for.if.do.do.do:
com.google.android.material.R$attr -> for.if.do.do.if:
com.google.android.material.R$color -> for.if.do.do.for:
com.google.android.material.R$dimen -> for.if.do.do.int:
com.google.android.material.R$drawable -> for.if.do.do.new:
com.google.android.material.R$id -> for.if.do.do.try:
com.google.android.material.R$integer -> for.if.do.do.byte:
com.google.android.material.R$layout -> for.if.do.do.case:
com.google.android.material.R$string -> for.if.do.do.char:
com.google.android.material.R$style -> for.if.do.do.else:
com.google.android.material.R$styleable -> for.if.do.do.goto:
com.google.android.material.animation.AnimationUtils -> for.if.do.do.long.do:
    android.animation.TimeInterpolator FAST_OUT_SLOW_IN_INTERPOLATOR -> if
    android.animation.TimeInterpolator LINEAR_INTERPOLATOR -> do
    android.animation.TimeInterpolator FAST_OUT_LINEAR_IN_INTERPOLATOR -> for
    android.animation.TimeInterpolator LINEAR_OUT_SLOW_IN_INTERPOLATOR -> int
    android.animation.TimeInterpolator DECELERATE_INTERPOLATOR -> new
    float lerp(float,float,float) -> do
com.google.android.material.animation.AnimatorSetCompat -> for.if.do.do.long.if:
    void playTogether(android.animation.AnimatorSet,java.util.List) -> do
com.google.android.material.animation.ArgbEvaluatorCompat -> for.if.do.do.long.for:
    com.google.android.material.animation.ArgbEvaluatorCompat instance -> do
    java.lang.Integer evaluate(float,java.lang.Integer,java.lang.Integer) -> do
    com.google.android.material.animation.ArgbEvaluatorCompat getInstance() -> do
com.google.android.material.animation.ChildrenAlphaProperty -> for.if.do.do.long.int:
    android.util.Property CHILDREN_ALPHA -> do
    java.lang.Float get(android.view.ViewGroup) -> do
    void set(android.view.ViewGroup,java.lang.Float) -> do
com.google.android.material.animation.DrawableAlphaProperty -> for.if.do.do.long.new:
    java.util.WeakHashMap alphaCache -> do
    android.util.Property DRAWABLE_ALPHA_COMPAT -> if
    java.lang.Integer get(android.graphics.drawable.Drawable) -> do
    void set(android.graphics.drawable.Drawable,java.lang.Integer) -> do
com.google.android.material.animation.ImageMatrixProperty -> for.if.do.do.long.try:
    android.graphics.Matrix matrix -> do
    android.graphics.Matrix get(android.widget.ImageView) -> do
    void set(android.widget.ImageView,android.graphics.Matrix) -> do
com.google.android.material.animation.MatrixEvaluator -> for.if.do.do.long.byte:
    float[] tempStartValues -> do
    float[] tempEndValues -> if
    android.graphics.Matrix tempMatrix -> for
    android.graphics.Matrix evaluate(float,android.graphics.Matrix,android.graphics.Matrix) -> do
com.google.android.material.animation.MotionSpec -> for.if.do.do.long.case:
    androidx.collection.SimpleArrayMap propertyValues -> if
    androidx.collection.SimpleArrayMap timings -> do
    void addInfoFromAnimator(com.google.android.material.animation.MotionSpec,android.animation.Animator) -> do
    com.google.android.material.animation.MotionSpec createFromAttribute(android.content.Context,android.content.res.TypedArray,int) -> do
    com.google.android.material.animation.MotionSpec createFromResource(android.content.Context,int) -> do
    com.google.android.material.animation.MotionSpec createSpecFromAnimators(java.util.List) -> do
    com.google.android.material.animation.MotionTiming getTiming(java.lang.String) -> do
    long getTotalDuration() -> do
    void setPropertyValues(java.lang.String,android.animation.PropertyValuesHolder[]) -> do
    void setTiming(java.lang.String,com.google.android.material.animation.MotionTiming) -> do
    boolean hasTiming(java.lang.String) -> if
com.google.android.material.animation.MotionTiming -> for.if.do.do.long.char:
    int repeatCount -> int
    long delay -> do
    int repeatMode -> new
    long duration -> if
    android.animation.TimeInterpolator interpolator -> for
    void apply(android.animation.Animator) -> do
    com.google.android.material.animation.MotionTiming createFromAnimator(android.animation.ValueAnimator) -> do
    long getDelay() -> do
    android.animation.TimeInterpolator getInterpolator() -> for
    long getDuration() -> if
    android.animation.TimeInterpolator getInterpolatorCompat(android.animation.ValueAnimator) -> if
    int getRepeatCount() -> int
    int getRepeatMode() -> new
com.google.android.material.animation.Positioning -> for.if.do.do.long.else:
    float yAdjustment -> for
    int gravity -> do
    float xAdjustment -> if
com.google.android.material.animation.TransformationCallback -> for.if.do.do.long.goto:
    void onScaleChanged(android.view.View) -> do
    void onTranslationChanged(android.view.View) -> if
com.google.android.material.appbar.AppBarLayout -> com.google.android.material.appbar.AppBarLayout:
    android.graphics.drawable.Drawable statusBarForeground -> const
    boolean liftOnScroll -> this
    java.lang.ref.WeakReference liftOnScrollTargetView -> break
    androidx.core.view.WindowInsetsCompat lastInsets -> case
    boolean lifted -> long
    int liftOnScrollTargetViewId -> void
    int currentOffset -> if
    int downPreScrollRange -> int
    boolean liftableOverride -> else
    int[] tmpStatesArray -> class
    int totalScrollRange -> for
    int pendingAction -> byte
    java.util.List listeners -> char
    android.animation.ValueAnimator elevationOverlayAnimator -> catch
    int downScrollRange -> new
    boolean haveChildWithInterpolator -> try
    boolean liftable -> goto
    void invalidateScrollRanges() -> byte
    boolean shouldDrawStatusBarForeground() -> case
    boolean shouldOffsetFirstChild() -> char
    boolean hasChildWithInterpolator() -> do
    void onOffsetChanged(int) -> do
    androidx.core.view.WindowInsetsCompat onWindowInsetChanged(androidx.core.view.WindowInsetsCompat) -> do
    void setExpanded(boolean,boolean) -> do
    void setExpanded(boolean,boolean,boolean) -> do
    boolean setLiftedState(boolean) -> do
    boolean shouldLift(android.view.View) -> do
    void startLiftOnScrollElevationOverlayAnimation(com.google.android.material.shape.MaterialShapeDrawable,boolean) -> do
    void updateWillNotDraw() -> else
    boolean isLiftOnScroll() -> for
    android.view.View findLiftOnScrollTargetView(android.view.View) -> if
    boolean hasScrollableChildren() -> if
    boolean setLiftableState(boolean) -> if
    void resetPendingAction() -> int
    void clearLiftOnScrollTargetView() -> new
    boolean hasCollapsibleChild() -> try
com.google.android.material.appbar.AppBarLayout$1 -> com.google.android.material.appbar.AppBarLayout$do:
    com.google.android.material.appbar.AppBarLayout this$0 -> do
    androidx.core.view.WindowInsetsCompat onApplyWindowInsets(android.view.View,androidx.core.view.WindowInsetsCompat) -> do
com.google.android.material.appbar.AppBarLayout$2 -> com.google.android.material.appbar.AppBarLayout$if:
    com.google.android.material.shape.MaterialShapeDrawable val$background -> do
com.google.android.material.appbar.AppBarLayout$BaseBehavior -> com.google.android.material.appbar.AppBarLayout$BaseBehavior:
    android.animation.ValueAnimator offsetAnimator -> this
    com.google.android.material.appbar.AppBarLayout$BaseBehavior$BaseDragCallback onDragCallback -> const
    int lastStartedType -> long
    boolean offsetToChildIndexOnLayoutIsMinHeight -> break
    java.lang.ref.WeakReference lastNestedScrollingChildRef -> class
    float offsetToChildIndexOnLayoutPerc -> catch
    int offsetDelta -> goto
    int offsetToChildIndexOnLayout -> void
    int access$000(com.google.android.material.appbar.AppBarLayout$BaseBehavior) -> do
    void animateOffsetTo(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,int,float) -> do
    void animateOffsetWithDuration(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,int,int) -> do
    boolean canDragView(android.view.View) -> do
    boolean canDragView(com.google.android.material.appbar.AppBarLayout) -> do
    boolean canScrollChildren(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View) -> do
    boolean checkFlag(int,int) -> do
    android.view.View findFirstScrollingChild(androidx.coordinatorlayout.widget.CoordinatorLayout) -> do
    android.view.View getAppBarChildOnOffset(com.google.android.material.appbar.AppBarLayout,int) -> do
    void onFlingFinished(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,int) -> do
    boolean onMeasureChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int,int,int,int) -> do
    boolean onMeasureChild(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,int,int,int,int) -> do
    void onNestedPreScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int[],int) -> do
    void onNestedPreScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View,int,int,int[],int) -> do
    void onNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int,int,int,int[]) -> do
    void onNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View,int,int,int,int,int,int[]) -> do
    void onRestoreInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.os.Parcelable) -> do
    void onRestoreInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.os.Parcelable) -> do
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View,android.view.View,int,int) -> do
    void onStopNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int) -> do
    void onStopNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View,int) -> do
    int setHeaderTopBottomOffset(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,int,int,int) -> do
    void updateAppBarLayoutDrawableState(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,int,int,boolean) -> do
    int getScrollRangeForDragFling(android.view.View) -> for
    int getScrollRangeForDragFling(com.google.android.material.appbar.AppBarLayout) -> for
    int getTopBottomOffsetForScrollingSibling() -> for
    int interpolateOffset(com.google.android.material.appbar.AppBarLayout,int) -> for
    boolean shouldJumpElevationState(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout) -> for
    int getChildIndexOnOffset(com.google.android.material.appbar.AppBarLayout,int) -> if
    int getMaxDragOffset(android.view.View) -> if
    int getMaxDragOffset(com.google.android.material.appbar.AppBarLayout) -> if
    android.os.Parcelable onSaveInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout) -> if
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,android.view.View,int,int) -> if
    int setHeaderTopBottomOffset(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int,int,int) -> if
    android.os.Parcelable onSaveInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> int
    void snapToChildIfNeeded(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout) -> int
    void onFlingFinished(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> new
com.google.android.material.appbar.AppBarLayout$BaseBehavior$1 -> com.google.android.material.appbar.AppBarLayout$BaseBehavior$do:
    androidx.coordinatorlayout.widget.CoordinatorLayout val$coordinatorLayout -> do
    com.google.android.material.appbar.AppBarLayout val$child -> if
    com.google.android.material.appbar.AppBarLayout$BaseBehavior this$0 -> for
com.google.android.material.appbar.AppBarLayout$BaseBehavior$BaseDragCallback -> com.google.android.material.appbar.AppBarLayout$BaseBehavior$if:
    boolean canDrag(com.google.android.material.appbar.AppBarLayout) -> do
com.google.android.material.appbar.AppBarLayout$BaseBehavior$SavedState -> com.google.android.material.appbar.AppBarLayout$BaseBehavior$for:
    int firstVisibleChildIndex -> int
    boolean firstVisibleChildAtMinimumHeight -> try
    float firstVisibleChildPercentageShown -> new
com.google.android.material.appbar.AppBarLayout$BaseBehavior$SavedState$1 -> com.google.android.material.appbar.AppBarLayout$BaseBehavior$for$do:
com.google.android.material.appbar.AppBarLayout$BaseOnOffsetChangedListener -> com.google.android.material.appbar.AppBarLayout$for:
    void onOffsetChanged(com.google.android.material.appbar.AppBarLayout,int) -> do
com.google.android.material.appbar.AppBarLayout$Behavior -> com.google.android.material.appbar.AppBarLayout$Behavior:
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,int) -> do
    boolean onMeasureChild(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,int,int,int,int) -> do
    void onNestedPreScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View,int,int,int[],int) -> do
    void onNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View,int,int,int,int,int,int[]) -> do
    void onRestoreInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.os.Parcelable) -> do
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View,android.view.View,int,int) -> do
    void onStopNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,android.view.View,int) -> do
    boolean setTopAndBottomOffset(int) -> do
    int getTopAndBottomOffset() -> if
    android.os.Parcelable onSaveInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout) -> if
com.google.android.material.appbar.AppBarLayout$LayoutParams -> com.google.android.material.appbar.AppBarLayout$int:
    android.view.animation.Interpolator scrollInterpolator -> if
    int scrollFlags -> do
    int getScrollFlags() -> do
    boolean isCollapsible() -> for
    android.view.animation.Interpolator getScrollInterpolator() -> if
com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior -> com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior:
    android.view.View findFirstDependency(java.util.List) -> do
    com.google.android.material.appbar.AppBarLayout findFirstDependency(java.util.List) -> do
    int getAppBarLayoutOffset(com.google.android.material.appbar.AppBarLayout) -> do
    boolean layoutDependsOn(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> do
    void offsetChildAsNeeded(android.view.View,android.view.View) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean onMeasureChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int,int,int,int) -> do
    boolean onRequestChildRectangleOnScreen(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.graphics.Rect,boolean) -> do
    boolean setTopAndBottomOffset(int) -> do
    int getScrollRange(android.view.View) -> for
    float getOverlapRatioForOffset(android.view.View) -> if
    int getTopAndBottomOffset() -> if
    boolean onDependentViewChanged(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> if
    void updateLiftedStateIfNeeded(android.view.View,android.view.View) -> if
com.google.android.material.appbar.HeaderBehavior -> com.google.android.material.appbar.do:
    android.widget.OverScroller scroller -> new
    int activePointerId -> byte
    android.view.VelocityTracker velocityTracker -> else
    boolean isBeingDragged -> try
    int touchSlop -> char
    int lastMotionY -> case
    java.lang.Runnable flingRunnable -> int
    boolean canDragView(android.view.View) -> do
    boolean fling(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int,int,float) -> do
    boolean onInterceptTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> do
    int scroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int,int,int) -> do
    int getScrollRangeForDragFling(android.view.View) -> for
    int getTopBottomOffsetForScrollingSibling() -> for
    int setHeaderTopBottomOffset(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> for
    int getMaxDragOffset(android.view.View) -> if
    boolean onTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> if
    int setHeaderTopBottomOffset(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int,int,int) -> if
    void ensureVelocityTracker() -> int
    void onFlingFinished(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> new
com.google.android.material.appbar.HeaderBehavior$FlingRunnable -> com.google.android.material.appbar.do$do:
    androidx.coordinatorlayout.widget.CoordinatorLayout parent -> if
    android.view.View layout -> for
    com.google.android.material.appbar.HeaderBehavior this$0 -> int
com.google.android.material.appbar.HeaderScrollingViewBehavior -> com.google.android.material.appbar.if:
    android.graphics.Rect tempRect1 -> int
    android.graphics.Rect tempRect2 -> new
    int overlayTop -> byte
    int verticalLayoutGap -> try
    android.view.View findFirstDependency(java.util.List) -> do
    int getOverlapPixelsForOffset(android.view.View) -> do
    boolean onMeasureChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int,int,int,int) -> do
    int getOverlayTop() -> for
    int getScrollRange(android.view.View) -> for
    int resolveGravity(int) -> for
    float getOverlapRatioForOffset(android.view.View) -> if
    void layoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> if
    void setOverlayTop(int) -> if
    int getVerticalLayoutGap() -> int
    boolean shouldHeaderOverlapScrollingChild() -> new
com.google.android.material.appbar.MaterialToolbar -> com.google.android.material.appbar.MaterialToolbar:
    int DEF_STYLE_RES -> interface
    void initBackground(android.content.Context) -> do
com.google.android.material.appbar.ViewOffsetBehavior -> com.google.android.material.appbar.for:
    int tempTopBottomOffset -> if
    int tempLeftRightOffset -> for
    com.google.android.material.appbar.ViewOffsetHelper viewOffsetHelper -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean setTopAndBottomOffset(int) -> do
    int getTopAndBottomOffset() -> if
    void layoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> if
com.google.android.material.appbar.ViewOffsetHelper -> com.google.android.material.appbar.int:
    int layoutTop -> if
    int offsetTop -> int
    android.view.View view -> do
    int layoutLeft -> for
    boolean horizontalOffsetEnabled -> byte
    int offsetLeft -> new
    boolean verticalOffsetEnabled -> try
    void applyOffsets() -> do
    boolean setLeftAndRightOffset(int) -> do
    void onViewLayout() -> for
    int getTopAndBottomOffset() -> if
    boolean setTopAndBottomOffset(int) -> if
com.google.android.material.appbar.ViewUtilsLollipop -> com.google.android.material.appbar.new:
    int[] STATE_LIST_ANIM_ATTRS -> do
    void setBoundsViewOutlineProvider(android.view.View) -> do
    void setDefaultAppBarLayoutStateListAnimator(android.view.View,float) -> do
    void setStateListAnimatorFromAttrs(android.view.View,android.util.AttributeSet,int,int) -> do
com.google.android.material.behavior.HideBottomViewOnScrollBehavior -> com.google.android.material.behavior.HideBottomViewOnScrollBehavior:
    int currentState -> if
    int height -> do
    int additionalHiddenOffsetY -> for
    android.view.ViewPropertyAnimator currentAnimator -> int
    android.view.ViewPropertyAnimator access$002(com.google.android.material.behavior.HideBottomViewOnScrollBehavior,android.view.ViewPropertyAnimator) -> do
    void animateChildTo(android.view.View,int,long,android.animation.TimeInterpolator) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    void onNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int,int) -> do
    void setAdditionalHiddenOffsetY(android.view.View,int) -> do
    void slideDown(android.view.View) -> do
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,android.view.View,int) -> if
    void slideUp(android.view.View) -> if
com.google.android.material.behavior.HideBottomViewOnScrollBehavior$1 -> com.google.android.material.behavior.HideBottomViewOnScrollBehavior$do:
    com.google.android.material.behavior.HideBottomViewOnScrollBehavior this$0 -> do
com.google.android.material.behavior.SwipeDismissBehavior -> com.google.android.material.behavior.SwipeDismissBehavior:
    boolean interceptingEvents -> for
    float alphaEndSwipeDistance -> char
    boolean sensitivitySet -> new
    androidx.customview.widget.ViewDragHelper$Callback dragCallback -> else
    float dragDismissThreshold -> byte
    com.google.android.material.behavior.SwipeDismissBehavior$OnDismissListener listener -> if
    float sensitivity -> int
    int swipeDirection -> try
    float alphaStartSwipeDistance -> case
    androidx.customview.widget.ViewDragHelper viewDragHelper -> do
    boolean canSwipeDismissView(android.view.View) -> do
    float clamp(float,float,float) -> do
    int clamp(int,int,int) -> do
    void ensureViewDragHelper(android.view.ViewGroup) -> do
    boolean onInterceptTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> do
    void setEndAlphaSwipeDistance(float) -> do
    void setListener(com.google.android.material.behavior.SwipeDismissBehavior$OnDismissListener) -> do
    void setSwipeDirection(int) -> do
    float fraction(float,float,float) -> if
    boolean onTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> if
    void setStartAlphaSwipeDistance(float) -> if
com.google.android.material.behavior.SwipeDismissBehavior$1 -> com.google.android.material.behavior.SwipeDismissBehavior$do:
    int activePointerId -> if
    int originalCapturedViewLeft -> do
    com.google.android.material.behavior.SwipeDismissBehavior this$0 -> for
    int clampViewPositionHorizontal(android.view.View,int,int) -> do
    int getViewHorizontalDragRange(android.view.View) -> do
    void onViewCaptured(android.view.View,int) -> do
    void onViewPositionChanged(android.view.View,int,int,int,int) -> do
    void onViewReleased(android.view.View,float,float) -> do
    boolean shouldDismiss(android.view.View,float) -> do
    void onViewDragStateChanged(int) -> for
    int clampViewPositionVertical(android.view.View,int,int) -> if
    boolean tryCaptureView(android.view.View,int) -> if
com.google.android.material.behavior.SwipeDismissBehavior$OnDismissListener -> com.google.android.material.behavior.SwipeDismissBehavior$if:
    void onDismiss(android.view.View) -> do
    void onDragStateChanged(int) -> do
com.google.android.material.behavior.SwipeDismissBehavior$SettleRunnable -> com.google.android.material.behavior.SwipeDismissBehavior$for:
    com.google.android.material.behavior.SwipeDismissBehavior this$0 -> int
    boolean dismiss -> for
    android.view.View view -> if
com.google.android.material.bottomappbar.BottomAppBar -> com.google.android.material.bottomappbar.BottomAppBar:
    com.google.android.material.animation.TransformationCallback fabTransformationCallback -> ˉ
    java.util.ArrayList animationListeners -> ʽ
    android.animation.AnimatorListenerAdapter fabAnimationListener -> ˈ
    int fabAnimationMode -> synchronized
    int bottomInset -> ˆ
    com.google.android.material.shape.MaterialShapeDrawable materialShapeDrawable -> protected
    int fabOffsetEndMode -> interface
    boolean fabAttached -> ʾ
    com.google.android.material.bottomappbar.BottomAppBar$Behavior behavior -> ʿ
    int animatingModeChangeCounter -> ʼ
    int fabAlignmentMode -> instanceof
    android.animation.Animator modeAnimator -> transient
    android.animation.Animator menuAnimator -> implements
    boolean hideOnScroll -> ʻ
    void access$700(com.google.android.material.bottomappbar.BottomAppBar) -> byte
    void access$1000(com.google.android.material.bottomappbar.BottomAppBar,androidx.appcompat.widget.ActionMenuView,int,boolean) -> do
    com.google.android.material.floatingactionbutton.FloatingActionButton access$1100(com.google.android.material.bottomappbar.BottomAppBar) -> do
    void access$1800(com.google.android.material.bottomappbar.BottomAppBar,com.google.android.material.floatingactionbutton.FloatingActionButton) -> do
    float access$800(com.google.android.material.bottomappbar.BottomAppBar,int) -> do
    android.animation.Animator access$902(com.google.android.material.bottomappbar.BottomAppBar,android.animation.Animator) -> do
    void addFabAnimationListeners(com.google.android.material.floatingactionbutton.FloatingActionButton) -> do
    void createFabDefaultXAnimation(int,java.util.List) -> do
    void createMenuViewTranslationAnimation(int,boolean,java.util.List) -> do
    int getActionMenuViewTranslationX(androidx.appcompat.widget.ActionMenuView,int,boolean) -> do
    void maybeAnimateMenuView(int,boolean) -> do
    void setActionMenuViewPosition() -> double
    void cancelAnimations() -> final
    void dispatchAnimationEnd() -> float
    int access$1600(com.google.android.material.bottomappbar.BottomAppBar) -> for
    float access$1200(com.google.android.material.bottomappbar.BottomAppBar) -> if
    void createFabTranslationXAnimation(int,java.util.List) -> if
    void translateActionMenuView(androidx.appcompat.widget.ActionMenuView,int,boolean) -> if
    void setCutoutState() -> import
    android.view.View access$1700(com.google.android.material.bottomappbar.BottomAppBar) -> int
    boolean setFabDiameter(int) -> int
    void access$1900(com.google.android.material.bottomappbar.BottomAppBar) -> new
    float getFabTranslationX(int) -> new
    void dispatchAnimationStart() -> short
    com.google.android.material.floatingactionbutton.FloatingActionButton findDependentFab() -> super
    android.view.View findDependentView() -> throw
    void access$600(com.google.android.material.bottomappbar.BottomAppBar) -> try
    void maybeAnimateModeChange(int) -> try
    boolean isFabVisibleOrWillBeShown() -> while
com.google.android.material.bottomappbar.BottomAppBar$4 -> com.google.android.material.bottomappbar.BottomAppBar$do:
    com.google.android.material.bottomappbar.BottomAppBar this$0 -> do
com.google.android.material.bottomappbar.BottomAppBar$5 -> com.google.android.material.bottomappbar.BottomAppBar$if:
    int val$targetMode -> do
    com.google.android.material.bottomappbar.BottomAppBar this$0 -> if
    void onHidden(com.google.android.material.floatingactionbutton.FloatingActionButton) -> do
com.google.android.material.bottomappbar.BottomAppBar$5$1 -> com.google.android.material.bottomappbar.BottomAppBar$if$do:
    com.google.android.material.bottomappbar.BottomAppBar$5 this$1 -> do
    void onShown(com.google.android.material.floatingactionbutton.FloatingActionButton) -> if
com.google.android.material.bottomappbar.BottomAppBar$6 -> com.google.android.material.bottomappbar.BottomAppBar$for:
    com.google.android.material.bottomappbar.BottomAppBar this$0 -> do
com.google.android.material.bottomappbar.BottomAppBar$7 -> com.google.android.material.bottomappbar.BottomAppBar$int:
    boolean cancelled -> do
    androidx.appcompat.widget.ActionMenuView val$actionMenuView -> if
    com.google.android.material.bottomappbar.BottomAppBar this$0 -> new
    boolean val$targetAttached -> int
    int val$targetMode -> for
com.google.android.material.bottomappbar.BottomAppBar$8 -> com.google.android.material.bottomappbar.BottomAppBar$new:
    com.google.android.material.bottomappbar.BottomAppBar this$0 -> do
com.google.android.material.bottomappbar.BottomAppBar$AnimationListener -> com.google.android.material.bottomappbar.BottomAppBar$try:
    void onAnimationStart(com.google.android.material.bottomappbar.BottomAppBar) -> do
    void onAnimationEnd(com.google.android.material.bottomappbar.BottomAppBar) -> if
com.google.android.material.bottomappbar.BottomAppBar$Behavior -> com.google.android.material.bottomappbar.BottomAppBar$Behavior:
    android.view.View$OnLayoutChangeListener fabLayoutListener -> case
    android.graphics.Rect fabContentRect -> new
    java.lang.ref.WeakReference viewRef -> try
    int originalBottomMargin -> byte
    java.lang.ref.WeakReference access$1300(com.google.android.material.bottomappbar.BottomAppBar$Behavior) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.bottomappbar.BottomAppBar,int) -> do
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.bottomappbar.BottomAppBar,android.view.View,android.view.View,int,int) -> do
    int access$1500(com.google.android.material.bottomappbar.BottomAppBar$Behavior) -> for
    android.graphics.Rect access$1400(com.google.android.material.bottomappbar.BottomAppBar$Behavior) -> if
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,android.view.View,int,int) -> if
com.google.android.material.bottomappbar.BottomAppBar$Behavior$1 -> com.google.android.material.bottomappbar.BottomAppBar$Behavior$do:
    com.google.android.material.bottomappbar.BottomAppBar$Behavior this$0 -> do
com.google.android.material.bottomappbar.BottomAppBar$SavedState -> com.google.android.material.bottomappbar.BottomAppBar$byte:
    int fabAlignmentMode -> int
    boolean fabAttached -> new
com.google.android.material.bottomappbar.BottomAppBar$SavedState$1 -> com.google.android.material.bottomappbar.BottomAppBar$byte$do:
com.google.android.material.bottomappbar.BottomAppBarTopEdgeTreatment -> com.google.android.material.bottomappbar.do:
    float fabMargin -> for
    float horizontalOffset -> try
    float fabDiameter -> int
    float roundedCornerRadius -> if
    float cradleVerticalOffset -> new
    float getCradleVerticalOffset() -> do
    void getEdgePath(float,float,float,com.google.android.material.shape.ShapePath) -> do
    void setCradleVerticalOffset(float) -> do
    float getFabCradleRoundedCornerRadius() -> for
    void setFabCradleRoundedCornerRadius(float) -> for
    float getFabCradleMargin() -> if
    void setFabCradleMargin(float) -> if
    float getFabDiameter() -> int
    void setFabDiameter(float) -> int
    void setHorizontalOffset(float) -> new
com.google.android.material.bottomsheet.BottomSheetBehavior -> com.google.android.material.bottomsheet.BottomSheetBehavior:
    boolean skipCollapsed -> float
    int expandedOffset -> this
    android.animation.ValueAnimator interpolatorAnimator -> long
    java.lang.ref.WeakReference nestedScrollingChildRef -> return
    int activePointerId -> throws
    boolean touchingScrollingChild -> default
    boolean peekHeightAuto -> new
    int saveFlags -> do
    float halfExpandedRatio -> catch
    int peekHeight -> int
    boolean isShapeExpanded -> else
    int initialY -> boolean
    float elevation -> const
    boolean hideable -> final
    boolean shapeThemingEnabled -> byte
    com.google.android.material.shape.MaterialShapeDrawable materialShapeDrawable -> case
    int state -> short
    java.util.Map importantForAccessibilityMap -> extends
    android.view.VelocityTracker velocityTracker -> switch
    int halfExpandedOffset -> break
    int lastNestedScrollDy -> while
    boolean nestedScrolled -> double
    int parentWidth -> import
    com.google.android.material.shape.ShapeAppearanceModel shapeAppearanceModelDefault -> char
    int collapsedOffset -> class
    int DEF_STYLE_RES -> package
    java.lang.ref.WeakReference viewRef -> public
    int peekHeightMin -> try
    java.util.ArrayList callbacks -> static
    int fitToContentsOffset -> void
    int parentHeight -> native
    float maximumVelocity -> for
    androidx.customview.widget.ViewDragHelper$Callback dragCallback -> finally
    boolean fitToContents -> if
    com.google.android.material.bottomsheet.BottomSheetBehavior$SettleRunnable settleRunnable -> goto
    androidx.customview.widget.ViewDragHelper viewDragHelper -> super
    boolean ignoreEvents -> throw
    void reset() -> byte
    void settleToStatePendingLayout(int) -> byte
    void updateAccessibilityActions() -> case
    void updateDrawableForTargetState(int) -> case
    com.google.android.material.shape.MaterialShapeDrawable access$000(com.google.android.material.bottomsheet.BottomSheetBehavior) -> do
    void addAccessibilityActionForState(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityActionCompat,int) -> do
    void createMaterialShapeDrawable(android.content.Context,android.util.AttributeSet,boolean) -> do
    void createMaterialShapeDrawable(android.content.Context,android.util.AttributeSet,boolean,android.content.res.ColorStateList) -> do
    void dispatchOnSlide(int) -> do
    android.view.View findScrollingChild(android.view.View) -> do
    void onAttachedToLayoutParams(androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams) -> do
    void onDetachedFromLayoutParams() -> do
    boolean onInterceptTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean onNestedPreFling(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,float,float) -> do
    void onNestedPreScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int[],int) -> do
    void onNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int,int,int,int,int,int[]) -> do
    void onRestoreInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.os.Parcelable) -> do
    void onStopNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,int) -> do
    void restoreOptionalState(com.google.android.material.bottomsheet.BottomSheetBehavior$SavedState) -> do
    void setFitToContents(boolean) -> do
    void setHalfExpandedRatio(float) -> do
    void setPeekHeight(int,boolean) -> do
    void settleToState(android.view.View,int) -> do
    boolean shouldHide(android.view.View,float) -> do
    void startSettlingAnimation(android.view.View,int,int,boolean) -> do
    int access$300(com.google.android.material.bottomsheet.BottomSheetBehavior) -> for
    void calculateHalfExpandedOffset() -> for
    void setPeekHeight(int) -> for
    void setSkipCollapsed(boolean) -> for
    boolean access$200(com.google.android.material.bottomsheet.BottomSheetBehavior) -> if
    void calculateCollapsedOffset() -> if
    boolean onStartNestedScroll(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View,android.view.View,int,int) -> if
    boolean onTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> if
    void setExpandedOffset(int) -> if
    void setHideable(boolean) -> if
    int access$400(com.google.android.material.bottomsheet.BottomSheetBehavior) -> int
    void createShapeValueAnimator() -> int
    android.os.Parcelable onSaveInstanceState(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> int
    void setSaveFlags(int) -> int
    void updateImportantForAccessibility(boolean) -> int
    boolean access$500(com.google.android.material.bottomsheet.BottomSheetBehavior) -> new
    int getExpandedOffset() -> new
    void setState(int) -> new
    float getYVelocity() -> try
    void setStateInternal(int) -> try
com.google.android.material.bottomsheet.BottomSheetBehavior$1 -> com.google.android.material.bottomsheet.BottomSheetBehavior$do:
    android.view.View val$child -> if
    int val$finalState -> for
    com.google.android.material.bottomsheet.BottomSheetBehavior this$0 -> int
com.google.android.material.bottomsheet.BottomSheetBehavior$2 -> com.google.android.material.bottomsheet.BottomSheetBehavior$if:
    com.google.android.material.bottomsheet.BottomSheetBehavior this$0 -> do
com.google.android.material.bottomsheet.BottomSheetBehavior$3 -> com.google.android.material.bottomsheet.BottomSheetBehavior$for:
    com.google.android.material.bottomsheet.BottomSheetBehavior this$0 -> do
    int clampViewPositionHorizontal(android.view.View,int,int) -> do
    void onViewPositionChanged(android.view.View,int,int,int,int) -> do
    void onViewReleased(android.view.View,float,float) -> do
    void onViewDragStateChanged(int) -> for
    int clampViewPositionVertical(android.view.View,int,int) -> if
    int getViewVerticalDragRange(android.view.View) -> if
    boolean tryCaptureView(android.view.View,int) -> if
com.google.android.material.bottomsheet.BottomSheetBehavior$4 -> com.google.android.material.bottomsheet.BottomSheetBehavior$int:
    com.google.android.material.bottomsheet.BottomSheetBehavior this$0 -> if
    int val$state -> do
    boolean perform(android.view.View,androidx.core.view.accessibility.AccessibilityViewCommand$CommandArguments) -> do
com.google.android.material.bottomsheet.BottomSheetBehavior$BottomSheetCallback -> com.google.android.material.bottomsheet.BottomSheetBehavior$new:
    void onSlide(android.view.View,float) -> do
    void onStateChanged(android.view.View,int) -> do
com.google.android.material.bottomsheet.BottomSheetBehavior$SavedState -> com.google.android.material.bottomsheet.BottomSheetBehavior$try:
    int state -> int
    boolean skipCollapsed -> case
    boolean hideable -> byte
    int peekHeight -> new
    boolean fitToContents -> try
com.google.android.material.bottomsheet.BottomSheetBehavior$SavedState$1 -> com.google.android.material.bottomsheet.BottomSheetBehavior$try$do:
com.google.android.material.bottomsheet.BottomSheetBehavior$SettleRunnable -> com.google.android.material.bottomsheet.BottomSheetBehavior$byte:
    com.google.android.material.bottomsheet.BottomSheetBehavior this$0 -> new
    int targetState -> int
    boolean isPosted -> for
    android.view.View view -> if
    boolean access$100(com.google.android.material.bottomsheet.BottomSheetBehavior$SettleRunnable) -> do
    boolean access$102(com.google.android.material.bottomsheet.BottomSheetBehavior$SettleRunnable,boolean) -> do
com.google.android.material.button.MaterialButton -> com.google.android.material.button.MaterialButton:
    android.content.res.ColorStateList iconTint -> case
    int iconGravity -> break
    java.util.LinkedHashSet onCheckedChangeListeners -> new
    boolean checked -> this
    com.google.android.material.button.MaterialButtonHelper materialButtonHelper -> int
    com.google.android.material.button.MaterialButton$OnPressedChangeListener onPressedChangeListenerInternal -> try
    int DEF_STYLE_RES -> const
    int iconLeft -> goto
    int[] CHECKABLE_STATE_SET -> catch
    int[] CHECKED_STATE_SET -> class
    android.graphics.PorterDuff$Mode iconTintMode -> byte
    int iconPadding -> long
    int iconSize -> else
    boolean broadcasting -> void
    android.graphics.drawable.Drawable icon -> char
    boolean isCheckable() -> do
    void resetIconDrawable(boolean) -> do
    boolean isUsingOriginalBackground() -> for
    boolean isLayoutRTL() -> if
    void updateIcon(boolean) -> if
    void updateIconPosition() -> int
com.google.android.material.button.MaterialButton$OnCheckedChangeListener -> com.google.android.material.button.MaterialButton$do:
    void onCheckedChanged(com.google.android.material.button.MaterialButton,boolean) -> do
com.google.android.material.button.MaterialButton$OnPressedChangeListener -> com.google.android.material.button.MaterialButton$if:
    void onPressedChanged(com.google.android.material.button.MaterialButton,boolean) -> do
com.google.android.material.button.MaterialButtonHelper -> com.google.android.material.button.do:
    android.graphics.PorterDuff$Mode backgroundTintMode -> char
    android.graphics.drawable.LayerDrawable rippleDrawable -> const
    boolean backgroundOverwritten -> break
    com.google.android.material.button.MaterialButton materialButton -> do
    com.google.android.material.shape.ShapeAppearanceModel shapeAppearanceModel -> if
    int insetBottom -> try
    int insetRight -> int
    android.content.res.ColorStateList backgroundTint -> else
    boolean cornerRadiusSet -> catch
    boolean IS_LOLLIPOP -> final
    android.content.res.ColorStateList strokeColor -> goto
    android.content.res.ColorStateList rippleColor -> long
    android.graphics.drawable.Drawable maskDrawable -> this
    int insetLeft -> for
    int cornerRadius -> byte
    int insetTop -> new
    boolean shouldDrawSurfaceColorStroke -> void
    boolean checkable -> class
    int strokeWidth -> case
    void updateStroke() -> break
    int getStrokeWidth() -> byte
    android.content.res.ColorStateList getSupportBackgroundTintList() -> case
    android.graphics.PorterDuff$Mode getSupportBackgroundTintMode() -> char
    int getCornerRadius() -> do
    void loadFromAttributes(android.content.res.TypedArray) -> do
    void setBackgroundColor(int) -> do
    void setCheckable(boolean) -> do
    void setRippleColor(android.content.res.ColorStateList) -> do
    void setShapeAppearanceModel(com.google.android.material.shape.ShapeAppearanceModel) -> do
    void setSupportBackgroundTintMode(android.graphics.PorterDuff$Mode) -> do
    void updateMaskBounds(int,int) -> do
    android.graphics.drawable.InsetDrawable wrapDrawableWithInset(android.graphics.drawable.Drawable) -> do
    boolean isBackgroundOverwritten() -> else
    com.google.android.material.shape.MaterialShapeDrawable getMaterialShapeDrawable() -> for
    com.google.android.material.shape.MaterialShapeDrawable getMaterialShapeDrawable(boolean) -> for
    void setStrokeWidth(int) -> for
    void setSupportBackgroundTintList(android.content.res.ColorStateList) -> for
    boolean isCheckable() -> goto
    com.google.android.material.shape.Shapeable getMaskDrawable() -> if
    void setCornerRadius(int) -> if
    void setShouldDrawSurfaceColorStroke(boolean) -> if
    void setStrokeColor(android.content.res.ColorStateList) -> if
    void updateButtonShape(com.google.android.material.shape.ShapeAppearanceModel) -> if
    android.content.res.ColorStateList getRippleColor() -> int
    void setBackgroundOverwritten() -> long
    com.google.android.material.shape.ShapeAppearanceModel getShapeAppearanceModel() -> new
    android.graphics.drawable.Drawable createBackground() -> this
    android.content.res.ColorStateList getStrokeColor() -> try
    com.google.android.material.shape.MaterialShapeDrawable getSurfaceColorStrokeDrawable() -> void
com.google.android.material.canvas.CanvasCompat -> for.if.do.do.this.do:
    int saveLayerAlpha(android.graphics.Canvas,float,float,float,float,int) -> do
com.google.android.material.card.MaterialCardView -> for.if.do.do.void.do:
    int[] CHECKED_STATE_SET -> class
    boolean checked -> this
    int[] DRAGGED_STATE_SET -> const
    com.google.android.material.card.MaterialCardView$OnCheckedChangeListener onCheckedChangeListener -> break
    boolean dragged -> void
    boolean isParentCardViewDoneInitializing -> long
    int[] CHECKABLE_STATE_SET -> catch
    com.google.android.material.card.MaterialCardViewHelper cardViewHelper -> goto
    float access$001(com.google.android.material.card.MaterialCardView) -> do
    boolean isCheckable() -> for
    boolean isDragged() -> int
    void forceRippleRedrawIfNeeded() -> new
com.google.android.material.card.MaterialCardView$OnCheckedChangeListener -> for.if.do.do.void.do$do:
    void onCheckedChanged(com.google.android.material.card.MaterialCardView,boolean) -> do
com.google.android.material.card.MaterialCardViewHelper -> for.if.do.do.void.if:
    boolean isCheckable() -> break
    float getProgress() -> byte
    android.content.res.ColorStateList getRippleColor() -> case
    void updateClickable() -> catch
    com.google.android.material.shape.ShapeAppearanceModel getShapeAppearanceModel() -> char
    void updateElevation() -> class
    void updateInsets() -> const
    void forceRippleRedraw() -> do
    void onMeasure(int,int) -> do
    void setCardBackgroundColor(android.content.res.ColorStateList) -> do
    void setCheckable(boolean) -> do
    void setCheckedIcon(android.graphics.drawable.Drawable) -> do
    void setCornerRadius(float) -> do
    void setShapeAppearanceModel(com.google.android.material.shape.ShapeAppearanceModel) -> do
    void setStrokeWidth(int) -> do
    int getStrokeColor() -> else
    android.content.res.ColorStateList getCardBackgroundColor() -> for
    void setRippleColor(android.content.res.ColorStateList) -> for
    android.content.res.ColorStateList getStrokeColorStateList() -> goto
    com.google.android.material.shape.MaterialShapeDrawable getBackground() -> if
    void setCheckedIconTint(android.content.res.ColorStateList) -> if
    void setProgress(float) -> if
    android.graphics.drawable.Drawable getCheckedIcon() -> int
    void setStrokeColor(android.content.res.ColorStateList) -> int
    int getStrokeWidth() -> long
    android.content.res.ColorStateList getCheckedIconTint() -> new
    android.graphics.Rect getUserContentPadding() -> this
    float getCornerRadius() -> try
    boolean isBackgroundOverwritten() -> void
com.google.android.material.checkbox.MaterialCheckBox -> for.if.do.do.break.do:
    int[][] ENABLED_CHECKED_STATES -> case
    int DEF_STYLE_RES -> byte
    boolean useMaterialThemeColors -> try
    android.content.res.ColorStateList materialThemeColorsTintList -> new
com.google.android.material.chip.Chip -> com.google.android.material.chip.Chip:
    com.google.android.material.chip.ChipDrawable chipDrawable -> new
    int lastLayoutDirection -> break
    boolean closeIconFocused -> this
    int minTouchTargetSize -> catch
    com.google.android.material.chip.Chip$ChipTouchHelper touchHelper -> class
    int[] SELECTED_STATE -> super
    boolean closeIconHovered -> long
    android.graphics.Rect rect -> const
    android.graphics.RectF rectF -> final
    boolean deferredCheckedValue -> else
    android.graphics.drawable.InsetDrawable insetBackgroundDrawable -> try
    com.google.android.material.resources.TextAppearanceFontCallback fontCallback -> float
    int[] CHECKABLE_STATE_SET -> throw
    android.view.View$OnClickListener onCloseIconClickListener -> case
    android.graphics.Rect EMPTY_BOUNDS -> short
    android.graphics.drawable.RippleDrawable ripple -> byte
    android.widget.CompoundButton$OnCheckedChangeListener onCheckedChangeListenerInternal -> char
    boolean ensureMinTouchTargetSize -> void
    boolean closeIconPressed -> goto
    void updatePaddingInternal() -> break
    int[] createCloseIconDrawableState() -> byte
    void ensureChipDrawableHasCallback() -> case
    void updateTextPaintDrawState() -> catch
    boolean hasCloseIcon() -> char
    com.google.android.material.chip.ChipDrawable access$000(com.google.android.material.chip.Chip) -> do
    boolean access$302(com.google.android.material.chip.Chip,boolean) -> do
    void applyChipDrawable(com.google.android.material.chip.ChipDrawable) -> do
    boolean ensureAccessibleTouchTarget(int) -> do
    boolean handleAccessibilityExit(android.view.MotionEvent) -> do
    void initMinTouchTarget(android.content.Context,android.util.AttributeSet,int) -> do
    void insetChipBackgroundDrawable(int,int,int,int) -> do
    void onChipDrawableSizeChange() -> do
    void validateAttributes(android.util.AttributeSet) -> do
    void initOutlineProvider() -> else
    android.graphics.RectF access$200(com.google.android.material.chip.Chip) -> for
    boolean isCloseIconVisible() -> for
    void removeBackgroundInset() -> goto
    boolean access$100(com.google.android.material.chip.Chip) -> if
    boolean isCheckable() -> if
    void unapplyChipDrawable(com.google.android.material.chip.ChipDrawable) -> if
    android.graphics.Rect access$400(com.google.android.material.chip.Chip) -> int
    boolean performCloseIconClick() -> int
    void updateAccessibilityDelegate() -> long
    boolean shouldEnsureMinTouchTargetSize() -> new
    void updateBackgroundDrawable() -> this
    android.graphics.Rect access$500() -> try
    void updateFrameworkRippleBackground() -> void
com.google.android.material.chip.Chip$1 -> com.google.android.material.chip.Chip$do:
    com.google.android.material.chip.Chip this$0 -> do
    void onFontRetrievalFailed(int) -> do
    void onFontRetrieved(android.graphics.Typeface,boolean) -> do
com.google.android.material.chip.Chip$2 -> com.google.android.material.chip.Chip$if:
    com.google.android.material.chip.Chip this$0 -> do
com.google.android.material.chip.Chip$ChipTouchHelper -> com.google.android.material.chip.Chip$for:
    com.google.android.material.chip.Chip this$0 -> class
    int getVirtualViewAt(float,float) -> do
    void getVisibleVirtualViews(java.util.List) -> do
    boolean onPerformActionForVirtualView(int,int,android.os.Bundle) -> do
    void onPopulateNodeForHost(androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onPopulateNodeForVirtualView(int,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onVirtualViewKeyboardFocusChanged(int,boolean) -> do
com.google.android.material.chip.ChipDrawable -> com.google.android.material.chip.do:
    float closeIconEndPadding -> ˆ
    android.graphics.drawable.ShapeDrawable closeIconRippleMask -> ˋˋ
    boolean currentChecked -> ⁱ
    android.graphics.drawable.Drawable closeIcon -> private
    float textEndPadding -> ʾ
    com.google.android.material.animation.MotionSpec showMotionSpec -> implements
    int[] DEFAULT_STATE -> ˈˈ
    android.graphics.Path shapePath -> י
    android.graphics.PorterDuffColorFilter tintFilter -> ﾞﾞ
    int alpha -> ﹶ
    float closeIconSize -> strictfp
    boolean checkable -> interface
    int currentCompatRippleColor -> ᵔ
    float chipStartPadding -> synchronized
    android.graphics.Paint$FontMetrics fontMetrics -> ˎ
    int maxWidth -> ˆˆ
    float chipIconSize -> extends
    android.content.res.ColorStateList compatRippleColor -> ʼʼ
    android.content.Context context -> ˉ
    int currentChipBackgroundColor -> ᐧ
    float closeIconStartPadding -> ʿ
    android.graphics.ColorFilter colorFilter -> ﾞ
    android.graphics.Paint chipPaint -> ˊ
    int[] closeIconStateSet -> ʻʻ
    boolean closeIconVisible -> package
    android.graphics.PorterDuff$Mode tintMode -> ᴵᴵ
    android.content.res.ColorStateList tint -> ᐧᐧ
    float chipEndPadding -> ˈ
    boolean hasChipIconTint -> finally
    java.lang.ref.WeakReference delegate -> ʿʿ
    int currentTextColor -> ᵢ
    com.google.android.material.internal.TextDrawableHelper textDrawableHelper -> ـ
    float chipMinHeight -> import
    android.content.res.ColorStateList chipBackgroundColor -> double
    android.graphics.Paint debugPaint -> ˋ
    float iconStartPadding -> ʻ
    android.graphics.RectF rectF -> ˏ
    android.content.res.ColorStateList chipStrokeColor -> public
    android.graphics.drawable.Drawable closeIconRipple -> abstract
    boolean checkedIconVisible -> protected
    android.content.res.ColorStateList closeIconTint -> continue
    boolean chipIconVisible -> throws
    boolean shouldDrawText -> ــ
    android.text.TextUtils$TruncateAt truncateAt -> ʾʾ
    int currentCompositeSurfaceBackgroundColor -> ᴵ
    android.content.res.ColorStateList chipSurfaceColor -> while
    int currentChipStrokeColor -> ᵎ
    float chipStrokeWidth -> return
    android.content.res.ColorStateList chipIconTint -> default
    android.content.res.ColorStateList rippleColor -> static
    boolean useCompatRipple -> ʽʽ
    boolean isShapeThemingEnabled -> ˉˉ
    float textStartPadding -> ʽ
    float iconEndPadding -> ʼ
    android.graphics.PointF pointF -> ˑ
    float chipCornerRadius -> native
    java.lang.CharSequence closeIconContentDescription -> volatile
    int currentChipSurfaceColor -> ٴ
    com.google.android.material.animation.MotionSpec hideMotionSpec -> instanceof
    android.graphics.drawable.Drawable chipIcon -> boolean
    android.graphics.drawable.Drawable checkedIcon -> transient
    int currentTint -> ﹳ
    java.lang.CharSequence text -> switch
    float getChipStartPadding() -> abstract
    float getChipCornerRadius() -> boolean
    void setChipStrokeColorResource(int) -> break
    void setIconStartPadding(float) -> break
    void drawCompatRipple(android.graphics.Canvas,android.graphics.Rect) -> byte
    void setChipCornerRadiusResource(int) -> byte
    void setChipIconSize(float) -> byte
    void setRippleColor(android.content.res.ColorStateList) -> byte
    void drawDebug(android.graphics.Canvas,android.graphics.Rect) -> case
    boolean isStateful(android.content.res.ColorStateList) -> case
    void setChipEndPaddingResource(int) -> case
    void setChipMinHeight(float) -> case
    void setChipStrokeWidthResource(int) -> catch
    void setTextEndPadding(float) -> catch
    void drawText(android.graphics.Canvas,android.graphics.Rect) -> char
    void setChipIconResource(int) -> char
    void setChipStartPadding(float) -> char
    void setChipSurfaceColor(android.content.res.ColorStateList) -> char
    void setCloseIconEndPaddingResource(int) -> class
    void setTextStartPadding(float) -> class
    void setCloseIconResource(int) -> const
    android.content.res.ColorStateList getChipStrokeColor() -> continue
    float getChipEndPadding() -> default
    void calculateChipIconBounds(android.graphics.Rect,android.graphics.RectF) -> do
    android.graphics.Paint$Align calculateTextOriginAndAlignment(android.graphics.Rect,android.graphics.PointF) -> do
    com.google.android.material.chip.ChipDrawable createFromAttributes(android.content.Context,android.util.AttributeSet,int,int) -> do
    void drawCheckedIcon(android.graphics.Canvas,android.graphics.Rect) -> do
    void getCloseIconTouchBounds(android.graphics.RectF) -> do
    boolean hasState(int[],int) -> do
    void loadFromAttributes(android.util.AttributeSet,int,int) -> do
    boolean onStateChange(int[],int[]) -> do
    void onTextSizeChange() -> do
    void setCheckable(boolean) -> do
    void setCheckedIcon(android.graphics.drawable.Drawable) -> do
    void setCloseIconContentDescription(java.lang.CharSequence) -> do
    void setDelegate(com.google.android.material.chip.ChipDrawable$Delegate) -> do
    void setEllipsize(android.text.TextUtils$TruncateAt) -> do
    void setHideMotionSpec(com.google.android.material.animation.MotionSpec) -> do
    void setTextAppearance(com.google.android.material.resources.TextAppearance) -> do
    void setMaxWidth(int) -> double
    void setChipIconSizeResource(int) -> else
    void setChipStrokeWidth(float) -> else
    android.graphics.drawable.Drawable getChipIcon() -> extends
    void setCloseIconSizeResource(int) -> final
    float getChipIconSize() -> finally
    void setCloseIconStartPaddingResource(int) -> float
    void calculateCloseIconBounds(android.graphics.Rect,android.graphics.RectF) -> for
    void drawChipIcon(android.graphics.Canvas,android.graphics.Rect) -> for
    void setCheckableResource(int) -> for
    void setChipBackgroundColor(android.content.res.ColorStateList) -> for
    void setChipIconVisible(boolean) -> for
    void setCloseIcon(android.graphics.drawable.Drawable) -> for
    void setChipIconTintResource(int) -> goto
    void setCloseIconEndPadding(float) -> goto
    void calculateChipTouchBounds(android.graphics.Rect,android.graphics.RectF) -> if
    void drawChipBackground(android.graphics.Canvas,android.graphics.Rect) -> if
    boolean isStateful(com.google.android.material.resources.TextAppearance) -> if
    void setCheckedIconVisible(boolean) -> if
    void setChipIcon(android.graphics.drawable.Drawable) -> if
    boolean setCloseIconState(int[]) -> if
    void setShowMotionSpec(com.google.android.material.animation.MotionSpec) -> if
    void setText(java.lang.CharSequence) -> if
    float getCloseIconStartPadding() -> implements
    void setRippleColorResource(int) -> import
    int[] getCloseIconState() -> instanceof
    void applyChildDrawable(android.graphics.drawable.Drawable) -> int
    void calculateCloseIconTouchBounds(android.graphics.Rect,android.graphics.RectF) -> int
    void drawChipStroke(android.graphics.Canvas,android.graphics.Rect) -> int
    void setCheckedIconResource(int) -> int
    void setChipIconTint(android.content.res.ColorStateList) -> int
    void setCloseIconVisible(boolean) -> int
    java.lang.CharSequence getCloseIconContentDescription() -> interface
    void setChipIconVisible(int) -> long
    void setCloseIconSize(float) -> long
    void setShowMotionSpecResource(int) -> native
    void calculateTextBounds(android.graphics.Rect,android.graphics.RectF) -> new
    void drawChipSurface(android.graphics.Canvas,android.graphics.Rect) -> new
    boolean isStateful(android.graphics.drawable.Drawable) -> new
    void setCheckedIconVisible(int) -> new
    void setChipCornerRadius(float) -> new
    void setChipStrokeColor(android.content.res.ColorStateList) -> new
    void setShouldDrawText(boolean) -> new
    android.content.res.ColorStateList getChipIconTint() -> package
    float getChipMinHeight() -> private
    float getCloseIconEndPadding() -> protected
    void setTextAppearanceResource(int) -> public
    float calculateChipIconWidth() -> return
    void setTextEndPaddingResource(int) -> return
    void setCloseIconTintResource(int) -> short
    float calculateCloseIconWidth() -> static
    void setTextStartPaddingResource(int) -> static
    float getChipStrokeWidth() -> strictfp
    void setHideMotionSpecResource(int) -> super
    android.graphics.drawable.Drawable getCheckedIcon() -> switch
    android.content.res.ColorStateList getCloseIconTint() -> synchronized
    void setChipMinHeightResource(int) -> this
    void setCloseIconStartPadding(float) -> this
    void setIconEndPaddingResource(int) -> throw
    android.content.res.ColorStateList getChipBackgroundColor() -> throws
    float getCloseIconSize() -> transient
    void drawCloseIcon(android.graphics.Canvas,android.graphics.Rect) -> try
    void setChipBackgroundColorResource(int) -> try
    void setChipEndPadding(float) -> try
    void setCloseIconTint(android.content.res.ColorStateList) -> try
    void setUseCompatRipple(boolean) -> try
    void unapplyChildDrawable(android.graphics.drawable.Drawable) -> try
    void setChipStartPaddingResource(int) -> void
    void setIconEndPadding(float) -> void
    android.graphics.drawable.Drawable getCloseIcon() -> volatile
    void setIconStartPaddingResource(int) -> while
    android.text.TextUtils$TruncateAt getEllipsize() -> ʻ
    com.google.android.material.animation.MotionSpec getHideMotionSpec() -> ʼ
    float getIconEndPadding() -> ʽ
    float getIconStartPadding() -> ʾ
    android.content.res.ColorStateList getRippleColor() -> ʿ
    com.google.android.material.animation.MotionSpec getShowMotionSpec() -> ˆ
    java.lang.CharSequence getText() -> ˈ
    com.google.android.material.resources.TextAppearance getTextAppearance() -> ˉ
    float getTextEndPadding() -> ˊ
    float getTextStartPadding() -> ˋ
    boolean getUseCompatRipple() -> ˎ
    boolean isCheckable() -> ˏ
    boolean isCloseIconStateful() -> ˑ
    boolean isCloseIconVisible() -> י
    void onSizeChange() -> ـ
    boolean shouldDrawText() -> ٴ
    float calculateTextCenterFromBaseline() -> ᐧ
    boolean canShowCheckedIcon() -> ᴵ
    android.graphics.ColorFilter getTintColorFilter() -> ᵎ
    boolean showsCheckedIcon() -> ᵔ
    boolean showsChipIcon() -> ᵢ
    boolean showsCloseIcon() -> ⁱ
    void updateCompatRippleColor() -> ﹳ
    void updateFrameworkCloseIconRipple() -> ﹶ
com.google.android.material.chip.ChipDrawable$Delegate -> com.google.android.material.chip.do$do:
    void onChipDrawableSizeChange() -> do
com.google.android.material.chip.ChipGroup -> com.google.android.material.chip.ChipGroup:
    com.google.android.material.chip.ChipGroup$PassThroughHierarchyChangeListener passThroughListener -> else
    com.google.android.material.chip.ChipGroup$OnCheckedChangeListener onCheckedChangeListener -> case
    boolean singleSelection -> byte
    com.google.android.material.chip.ChipGroup$CheckedStateTracker checkedStateTracker -> char
    int chipSpacingHorizontal -> new
    int chipSpacingVertical -> try
    int checkedId -> goto
    boolean protectFromCheckedChange -> long
    boolean access$300(com.google.android.material.chip.ChipGroup) -> do
    void access$600(com.google.android.material.chip.ChipGroup,int,boolean) -> do
    void access$700(com.google.android.material.chip.ChipGroup,int) -> do
    boolean isSingleLine() -> do
    void setCheckedStateForView(int,boolean) -> do
    boolean access$500(com.google.android.material.chip.ChipGroup) -> for
    int access$400(com.google.android.material.chip.ChipGroup) -> if
    void clearCheck() -> if
    com.google.android.material.chip.ChipGroup$CheckedStateTracker access$800(com.google.android.material.chip.ChipGroup) -> int
com.google.android.material.chip.ChipGroup$1 -> com.google.android.material.chip.ChipGroup$do:
com.google.android.material.chip.ChipGroup$CheckedStateTracker -> com.google.android.material.chip.ChipGroup$if:
    com.google.android.material.chip.ChipGroup this$0 -> do
com.google.android.material.chip.ChipGroup$LayoutParams -> com.google.android.material.chip.ChipGroup$for:
com.google.android.material.chip.ChipGroup$OnCheckedChangeListener -> com.google.android.material.chip.ChipGroup$int:
    void onCheckedChanged(com.google.android.material.chip.ChipGroup,int) -> do
com.google.android.material.chip.ChipGroup$PassThroughHierarchyChangeListener -> com.google.android.material.chip.ChipGroup$new:
    com.google.android.material.chip.ChipGroup this$0 -> for
    android.view.ViewGroup$OnHierarchyChangeListener onHierarchyChangeListener -> if
    android.view.ViewGroup$OnHierarchyChangeListener access$202(com.google.android.material.chip.ChipGroup$PassThroughHierarchyChangeListener,android.view.ViewGroup$OnHierarchyChangeListener) -> do
com.google.android.material.circularreveal.CircularRevealCompat -> for.if.do.do.catch.do:
    android.animation.Animator createCircularReveal(com.google.android.material.circularreveal.CircularRevealWidget,float,float,float) -> do
    android.animation.Animator$AnimatorListener createCircularRevealListener(com.google.android.material.circularreveal.CircularRevealWidget) -> do
com.google.android.material.circularreveal.CircularRevealCompat$1 -> for.if.do.do.catch.do$do:
    com.google.android.material.circularreveal.CircularRevealWidget val$view -> do
com.google.android.material.circularreveal.CircularRevealFrameLayout -> for.if.do.do.catch.if:
    com.google.android.material.circularreveal.CircularRevealHelper helper -> if
    void destroyCircularRevealCache() -> do
    void buildCircularRevealCache() -> if
com.google.android.material.circularreveal.CircularRevealHelper -> for.if.do.do.catch.for:
    int STRATEGY -> do
    void buildCircularRevealCache() -> do
    void draw(android.graphics.Canvas) -> do
    void setCircularRevealOverlayDrawable(android.graphics.drawable.Drawable) -> do
    void setCircularRevealScrimColor(int) -> do
    void setRevealInfo(com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo) -> do
    android.graphics.drawable.Drawable getCircularRevealOverlayDrawable() -> for
    void destroyCircularRevealCache() -> if
    int getCircularRevealScrimColor() -> int
    com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo getRevealInfo() -> new
    boolean isOpaque() -> try
com.google.android.material.circularreveal.CircularRevealWidget -> for.if.do.do.catch.int:
    void destroyCircularRevealCache() -> do
    void buildCircularRevealCache() -> if
com.google.android.material.circularreveal.CircularRevealWidget$1 -> for.if.do.do.catch.int$do:
com.google.android.material.circularreveal.CircularRevealWidget$CircularRevealEvaluator -> for.if.do.do.catch.int$if:
    android.animation.TypeEvaluator CIRCULAR_REVEAL -> if
    com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo revealInfo -> do
    com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo evaluate(float,com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo,com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo) -> do
com.google.android.material.circularreveal.CircularRevealWidget$CircularRevealProperty -> for.if.do.do.catch.int$for:
    android.util.Property CIRCULAR_REVEAL -> do
    com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo get(com.google.android.material.circularreveal.CircularRevealWidget) -> do
    void set(com.google.android.material.circularreveal.CircularRevealWidget,com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo) -> do
com.google.android.material.circularreveal.CircularRevealWidget$CircularRevealScrimColorProperty -> for.if.do.do.catch.int$int:
    android.util.Property CIRCULAR_REVEAL_SCRIM_COLOR -> do
    java.lang.Integer get(com.google.android.material.circularreveal.CircularRevealWidget) -> do
    void set(com.google.android.material.circularreveal.CircularRevealWidget,java.lang.Integer) -> do
com.google.android.material.circularreveal.CircularRevealWidget$RevealInfo -> for.if.do.do.catch.int$new:
    float centerX -> do
    float radius -> for
    float centerY -> if
    void set(float,float,float) -> do
com.google.android.material.circularreveal.cardview.CircularRevealCardView -> for.if.do.do.catch.new.do:
    com.google.android.material.circularreveal.CircularRevealHelper helper -> final
    void destroyCircularRevealCache() -> do
    void buildCircularRevealCache() -> if
com.google.android.material.color.MaterialColors -> for.if.do.do.class.do:
    int getColor(android.content.Context,int,int) -> do
    int getColor(android.content.Context,int,java.lang.String) -> do
    int getColor(android.view.View,int) -> do
    int getColor(android.view.View,int,int) -> do
    int layer(int,int) -> do
    int layer(int,int,float) -> do
    int layer(android.view.View,int,int,float) -> do
com.google.android.material.datepicker.CalendarConstraints -> com.google.android.material.datepicker.do:
    com.google.android.material.datepicker.Month openAt -> int
    com.google.android.material.datepicker.Month start -> if
    int monthSpan -> byte
    com.google.android.material.datepicker.CalendarConstraints$DateValidator validator -> new
    int yearSpan -> try
    com.google.android.material.datepicker.Month end -> for
    com.google.android.material.datepicker.Month getOpenAt() -> byte
    com.google.android.material.datepicker.Month getStart() -> case
    int getYearSpan() -> char
    com.google.android.material.datepicker.CalendarConstraints$DateValidator getDateValidator() -> int
    com.google.android.material.datepicker.Month getEnd() -> new
    int getMonthSpan() -> try
com.google.android.material.datepicker.CalendarConstraints$1 -> com.google.android.material.datepicker.do$do:
com.google.android.material.datepicker.CalendarConstraints$DateValidator -> com.google.android.material.datepicker.do$if:
    boolean isValid(long) -> if
com.google.android.material.datepicker.CalendarItemStyle -> com.google.android.material.datepicker.if:
    android.content.res.ColorStateList strokeColor -> int
    com.google.android.material.shape.ShapeAppearanceModel itemShape -> try
    android.graphics.Rect insets -> do
    int strokeWidth -> new
    android.content.res.ColorStateList backgroundColor -> for
    android.content.res.ColorStateList textColor -> if
    com.google.android.material.datepicker.CalendarItemStyle create(android.content.Context,int) -> do
    int getBottomInset() -> do
    void styleItem(android.widget.TextView) -> do
    int getTopInset() -> if
com.google.android.material.datepicker.CalendarStyle -> com.google.android.material.datepicker.for:
    com.google.android.material.datepicker.CalendarItemStyle todayDay -> for
    com.google.android.material.datepicker.CalendarItemStyle invalidDay -> byte
    com.google.android.material.datepicker.CalendarItemStyle day -> do
    com.google.android.material.datepicker.CalendarItemStyle selectedYear -> new
    com.google.android.material.datepicker.CalendarItemStyle selectedDay -> if
    com.google.android.material.datepicker.CalendarItemStyle todayYear -> try
    com.google.android.material.datepicker.CalendarItemStyle year -> int
    android.graphics.Paint rangeFill -> case
com.google.android.material.datepicker.DateSelector -> com.google.android.material.datepicker.int:
    java.lang.Object getSelection() -> do
    void select(long) -> do
    java.util.Collection getSelectedDays() -> for
    java.util.Collection getSelectedRanges() -> if
com.google.android.material.datepicker.DateStrings -> com.google.android.material.datepicker.new:
    java.lang.String getMonthDayOfWeekDay(long) -> do
    java.lang.String getMonthDayOfWeekDay(long,java.util.Locale) -> do
    java.lang.String getYearMonthDayOfWeekDay(long) -> if
    java.lang.String getYearMonthDayOfWeekDay(long,java.util.Locale) -> if
com.google.android.material.datepicker.DaysOfWeekAdapter -> com.google.android.material.datepicker.try:
    int firstDayOfWeek -> int
    int daysInWeek -> for
    int CALENDAR_DAY_STYLE -> new
    java.util.Calendar calendar -> if
    int positionToDayOfWeek(int) -> do
com.google.android.material.datepicker.MaterialCalendar -> com.google.android.material.datepicker.byte:
    com.google.android.material.datepicker.MaterialCalendar$CalendarSelector calendarSelector -> ˉ
    java.lang.Object SELECTOR_TOGGLE_TAG -> ᐧ
    com.google.android.material.datepicker.CalendarStyle calendarStyle -> ˊ
    androidx.recyclerview.widget.RecyclerView recyclerView -> ˎ
    android.view.View dayFrame -> ˑ
    androidx.recyclerview.widget.RecyclerView yearSelector -> ˋ
    com.google.android.material.datepicker.CalendarConstraints calendarConstraints -> ˆ
    com.google.android.material.datepicker.Month current -> ˈ
    com.google.android.material.datepicker.DateSelector dateSelector -> ʿ
    java.lang.Object MONTHS_VIEW_GROUP_TAG -> י
    int themeResId -> ʾ
    java.lang.Object NAVIGATION_NEXT_TAG -> ٴ
    android.view.View yearFrame -> ˏ
    java.lang.Object NAVIGATION_PREV_TAG -> ـ
    androidx.recyclerview.widget.RecyclerView access$000(com.google.android.material.datepicker.MaterialCalendar) -> do
    com.google.android.material.datepicker.Month access$602(com.google.android.material.datepicker.MaterialCalendar,com.google.android.material.datepicker.Month) -> do
    void addActionsToMonthNavigation(android.view.View,com.google.android.material.datepicker.MonthsPagerAdapter) -> do
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> do
    void setCurrentMonth(com.google.android.material.datepicker.Month) -> do
    void setSelector(com.google.android.material.datepicker.MaterialCalendar$CalendarSelector) -> do
    com.google.android.material.datepicker.DateSelector access$200(com.google.android.material.datepicker.MaterialCalendar) -> for
    void onCreate(android.os.Bundle) -> for
    com.google.android.material.datepicker.CalendarConstraints access$100(com.google.android.material.datepicker.MaterialCalendar) -> if
    int getDayHeight(android.content.Context) -> if
    androidx.recyclerview.widget.RecyclerView access$300(com.google.android.material.datepicker.MaterialCalendar) -> int
    void postSmoothRecyclerViewScroll(int) -> int
    com.google.android.material.datepicker.CalendarStyle access$400(com.google.android.material.datepicker.MaterialCalendar) -> new
    void onSaveInstanceState(android.os.Bundle) -> new
    android.view.View access$500(com.google.android.material.datepicker.MaterialCalendar) -> try
    com.google.android.material.datepicker.CalendarConstraints getCalendarConstraints() -> ᴵ
    com.google.android.material.datepicker.CalendarStyle getCalendarStyle() -> ᵎ
    com.google.android.material.datepicker.Month getCurrentMonth() -> ᵔ
    com.google.android.material.datepicker.DateSelector getDateSelector() -> ᵢ
    androidx.recyclerview.widget.LinearLayoutManager getLayoutManager() -> ⁱ
    void toggleVisibleSelector() -> ﹳ
    androidx.recyclerview.widget.RecyclerView$ItemDecoration createItemDecoration() -> ﹶ
com.google.android.material.datepicker.MaterialCalendar$1 -> com.google.android.material.datepicker.byte$if:
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
com.google.android.material.datepicker.MaterialCalendar$10 -> com.google.android.material.datepicker.byte$do:
    int val$position -> if
    com.google.android.material.datepicker.MaterialCalendar this$0 -> for
com.google.android.material.datepicker.MaterialCalendar$2 -> com.google.android.material.datepicker.byte$for:
    com.google.android.material.datepicker.MaterialCalendar this$0 -> finally
    int val$orientation -> extends
    void calculateExtraLayoutSpace(androidx.recyclerview.widget.RecyclerView$State,int[]) -> do
com.google.android.material.datepicker.MaterialCalendar$3 -> com.google.android.material.datepicker.byte$int:
    com.google.android.material.datepicker.MaterialCalendar this$0 -> do
    void onDayClick(long) -> do
com.google.android.material.datepicker.MaterialCalendar$4 -> com.google.android.material.datepicker.byte$new:
    com.google.android.material.datepicker.MaterialCalendar this$0 -> for
    java.util.Calendar startItem -> do
    java.util.Calendar endItem -> if
    void onDraw(android.graphics.Canvas,androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State) -> do
com.google.android.material.datepicker.MaterialCalendar$5 -> com.google.android.material.datepicker.byte$try:
    com.google.android.material.datepicker.MaterialCalendar this$0 -> int
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
com.google.android.material.datepicker.MaterialCalendar$6 -> com.google.android.material.datepicker.byte$byte:
    com.google.android.material.datepicker.MonthsPagerAdapter val$monthsPagerAdapter -> do
    com.google.android.material.datepicker.MaterialCalendar this$0 -> for
    com.google.android.material.button.MaterialButton val$monthDropSelect -> if
    void onScrollStateChanged(androidx.recyclerview.widget.RecyclerView,int) -> do
    void onScrolled(androidx.recyclerview.widget.RecyclerView,int,int) -> do
com.google.android.material.datepicker.MaterialCalendar$7 -> com.google.android.material.datepicker.byte$case:
    com.google.android.material.datepicker.MaterialCalendar this$0 -> if
com.google.android.material.datepicker.MaterialCalendar$8 -> com.google.android.material.datepicker.byte$char:
    com.google.android.material.datepicker.MonthsPagerAdapter val$monthsPagerAdapter -> if
    com.google.android.material.datepicker.MaterialCalendar this$0 -> for
com.google.android.material.datepicker.MaterialCalendar$9 -> com.google.android.material.datepicker.byte$else:
    com.google.android.material.datepicker.MonthsPagerAdapter val$monthsPagerAdapter -> if
    com.google.android.material.datepicker.MaterialCalendar this$0 -> for
com.google.android.material.datepicker.MaterialCalendar$CalendarSelector -> com.google.android.material.datepicker.byte$goto:
    com.google.android.material.datepicker.MaterialCalendar$CalendarSelector YEAR -> for
    com.google.android.material.datepicker.MaterialCalendar$CalendarSelector[] $VALUES -> int
    com.google.android.material.datepicker.MaterialCalendar$CalendarSelector DAY -> if
com.google.android.material.datepicker.MaterialCalendar$OnDayClickListener -> com.google.android.material.datepicker.byte$long:
    void onDayClick(long) -> do
com.google.android.material.datepicker.MaterialCalendarGridView -> com.google.android.material.datepicker.MaterialCalendarGridView:
    java.util.Calendar dayCompute -> if
    void gainFocus(int,android.graphics.Rect) -> do
    int horizontalMidPoint(android.view.View) -> do
    boolean skipMonth(java.lang.Long,java.lang.Long,java.lang.Long,java.lang.Long) -> do
com.google.android.material.datepicker.MaterialCalendarGridView$1 -> com.google.android.material.datepicker.MaterialCalendarGridView$do:
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
com.google.android.material.datepicker.MaterialDatePicker -> com.google.android.material.datepicker.case:
    boolean isFullscreen(android.content.Context) -> if
com.google.android.material.datepicker.Month -> com.google.android.material.datepicker.char:
    java.lang.String longName -> for
    int month -> int
    int daysInMonth -> byte
    int year -> new
    int daysInWeek -> try
    java.util.Calendar firstOfMonth -> if
    com.google.android.material.datepicker.Month today() -> byte
    int compareTo(com.google.android.material.datepicker.Month) -> do
    com.google.android.material.datepicker.Month create(int,int) -> do
    long getDay(int) -> do
    com.google.android.material.datepicker.Month monthsLater(int) -> if
    int monthsUntil(com.google.android.material.datepicker.Month) -> if
    int daysFromStartOfWeekToFirstOfMonth() -> int
    java.lang.String getLongName() -> new
    long getStableId() -> try
com.google.android.material.datepicker.Month$1 -> com.google.android.material.datepicker.char$do:
com.google.android.material.datepicker.MonthAdapter -> com.google.android.material.datepicker.else:
    com.google.android.material.datepicker.CalendarStyle calendarStyle -> int
    com.google.android.material.datepicker.CalendarConstraints calendarConstraints -> new
    com.google.android.material.datepicker.Month month -> if
    com.google.android.material.datepicker.DateSelector dateSelector -> for
    int MAXIMUM_WEEKS -> try
    int dayToPosition(int) -> do
    int firstPositionInMonth() -> do
    void initializeStyles(android.content.Context) -> do
    boolean isLastInRow(int) -> for
    boolean isFirstInRow(int) -> if
    int lastPositionInMonth() -> if
    int positionToDay(int) -> int
    boolean withinMonth(int) -> new
com.google.android.material.datepicker.MonthsPagerAdapter -> com.google.android.material.datepicker.goto:
    com.google.android.material.datepicker.DateSelector dateSelector -> int
    com.google.android.material.datepicker.CalendarConstraints calendarConstraints -> for
    com.google.android.material.datepicker.MaterialCalendar$OnDayClickListener onDayClickListener -> new
    int itemHeight -> try
    com.google.android.material.datepicker.MaterialCalendar$OnDayClickListener access$000(com.google.android.material.datepicker.MonthsPagerAdapter) -> do
    int getItemCount() -> do
    long getItemId(int) -> do
    int getPosition(com.google.android.material.datepicker.Month) -> do
    void onBindViewHolder(com.google.android.material.datepicker.MonthsPagerAdapter$ViewHolder,int) -> do
    com.google.android.material.datepicker.Month getPageMonth(int) -> for
    void onBindViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder,int) -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder onCreateViewHolder(android.view.ViewGroup,int) -> if
    com.google.android.material.datepicker.MonthsPagerAdapter$ViewHolder onCreateViewHolder(android.view.ViewGroup,int) -> if
    java.lang.CharSequence getPageTitle(int) -> int
com.google.android.material.datepicker.MonthsPagerAdapter$1 -> com.google.android.material.datepicker.goto$do:
    com.google.android.material.datepicker.MaterialCalendarGridView val$monthGrid -> if
    com.google.android.material.datepicker.MonthsPagerAdapter this$0 -> for
com.google.android.material.datepicker.MonthsPagerAdapter$ViewHolder -> com.google.android.material.datepicker.goto$if:
    android.widget.TextView monthTitle -> float
    com.google.android.material.datepicker.MaterialCalendarGridView monthGrid -> short
com.google.android.material.datepicker.OnSelectionChangedListener -> com.google.android.material.datepicker.long:
    void onSelectionChanged(java.lang.Object) -> do
com.google.android.material.datepicker.PickerFragment -> com.google.android.material.datepicker.this:
    java.util.LinkedHashSet onSelectionChangedListeners -> ʽ
com.google.android.material.datepicker.SmoothCalendarLayoutManager -> com.google.android.material.datepicker.void:
    void smoothScrollToPosition(androidx.recyclerview.widget.RecyclerView,androidx.recyclerview.widget.RecyclerView$State,int) -> do
com.google.android.material.datepicker.SmoothCalendarLayoutManager$1 -> com.google.android.material.datepicker.void$do:
    float calculateSpeedPerPixel(android.util.DisplayMetrics) -> do
com.google.android.material.datepicker.UtcDates -> com.google.android.material.datepicker.break:
    long canonicalYearMonthDay(long) -> do
    android.icu.text.DateFormat getAbbrMonthWeekdayDayFormat(java.util.Locale) -> do
    android.icu.text.DateFormat getAndroidFormat(java.lang.String,java.util.Locale) -> do
    java.util.Calendar getDayCopy(java.util.Calendar) -> do
    java.text.DateFormat getFormat(int,java.util.Locale) -> do
    java.util.TimeZone getTimeZone() -> do
    android.icu.util.TimeZone getUtcAndroidTimeZone() -> for
    android.icu.text.DateFormat getYearAbbrMonthWeekdayDayFormat(java.util.Locale) -> for
    java.text.DateFormat getFullFormat(java.util.Locale) -> if
    java.text.SimpleDateFormat getSimpleFormat(java.lang.String,java.util.Locale) -> if
    java.util.Calendar getTodayCalendar() -> if
    java.util.Calendar getUtcCalendarOf(java.util.Calendar) -> if
    java.util.Calendar getUtcCalendar() -> int
    java.text.SimpleDateFormat getYearMonthFormat(java.util.Locale) -> int
    java.text.SimpleDateFormat getYearMonthFormat() -> new
com.google.android.material.datepicker.YearGridAdapter -> com.google.android.material.datepicker.catch:
    com.google.android.material.datepicker.MaterialCalendar materialCalendar -> for
    com.google.android.material.datepicker.MaterialCalendar access$000(com.google.android.material.datepicker.YearGridAdapter) -> do
    int getItemCount() -> do
    void onBindViewHolder(com.google.android.material.datepicker.YearGridAdapter$ViewHolder,int) -> do
    int getPositionForYear(int) -> for
    void onBindViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder,int) -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder onCreateViewHolder(android.view.ViewGroup,int) -> if
    com.google.android.material.datepicker.YearGridAdapter$ViewHolder onCreateViewHolder(android.view.ViewGroup,int) -> if
    int getYearForPosition(int) -> int
    android.view.View$OnClickListener createYearClickListener(int) -> new
com.google.android.material.datepicker.YearGridAdapter$1 -> com.google.android.material.datepicker.catch$do:
    int val$year -> if
    com.google.android.material.datepicker.YearGridAdapter this$0 -> for
com.google.android.material.datepicker.YearGridAdapter$ViewHolder -> com.google.android.material.datepicker.catch$if:
    android.widget.TextView textView -> float
com.google.android.material.drawable.DrawableUtils -> for.if.do.do.const.do:
    android.graphics.PorterDuffColorFilter updateTintFilter(android.graphics.drawable.Drawable,android.content.res.ColorStateList,android.graphics.PorterDuff$Mode) -> do
com.google.android.material.elevation.ElevationOverlayProvider -> for.if.do.do.final.do:
    boolean elevationOverlayEnabled -> do
    int elevationOverlayColor -> if
    int colorSurface -> for
    float displayDensity -> int
    float calculateOverlayAlphaFraction(float) -> do
    int compositeOverlay(int,float) -> do
    boolean isThemeElevationOverlayEnabled() -> do
    boolean isThemeSurfaceColor(int) -> do
    int compositeOverlayIfNeeded(int,float) -> if
com.google.android.material.expandable.ExpandableTransformationWidget -> for.if.do.do.float.do:
com.google.android.material.expandable.ExpandableWidget -> for.if.do.do.float.if:
    boolean isExpanded() -> do
com.google.android.material.expandable.ExpandableWidgetHelper -> for.if.do.do.float.for:
    int getExpandedComponentIdHint() -> do
    void onRestoreInstanceState(android.os.Bundle) -> do
    void setExpandedComponentIdHint(int) -> do
    android.os.Bundle onSaveInstanceState() -> for
    boolean isExpanded() -> if
com.google.android.material.floatingactionbutton.BorderDrawable -> com.google.android.material.floatingactionbutton.do:
    void setBorderTint(android.content.res.ColorStateList) -> do
    void setShapeAppearanceModel(com.google.android.material.shape.ShapeAppearanceModel) -> do
com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton -> com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton:
    android.graphics.Rect shadowPadding -> final
    com.google.android.material.floatingactionbutton.MotionStrategy extendStrategy -> short
    com.google.android.material.floatingactionbutton.MotionStrategy hideStrategy -> throw
    boolean isExtended -> double
    androidx.coordinatorlayout.widget.CoordinatorLayout$Behavior behavior -> while
    com.google.android.material.floatingactionbutton.MotionStrategy shrinkStrategy -> float
    com.google.android.material.floatingactionbutton.MotionStrategy showStrategy -> super
    com.google.android.material.floatingactionbutton.MotionStrategy access$000(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> do
    void access$200(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton,com.google.android.material.floatingactionbutton.MotionStrategy,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$OnChangedCallback) -> do
    void performMotion(com.google.android.material.floatingactionbutton.MotionStrategy,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$OnChangedCallback) -> do
    com.google.android.material.floatingactionbutton.MotionStrategy access$300(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> for
    com.google.android.material.floatingactionbutton.MotionStrategy access$100(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> if
    com.google.android.material.floatingactionbutton.MotionStrategy access$400(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> int
    android.graphics.Rect access$500(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> new
    boolean shouldAnimateVisibilityChange() -> new
com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$3 -> com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$do:
    boolean cancelled -> do
    com.google.android.material.floatingactionbutton.MotionStrategy val$strategy -> if
    com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$OnChangedCallback val$callback -> for
com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$4 -> com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$if:
    java.lang.Float get(android.view.View) -> do
    void set(android.view.View,java.lang.Float) -> do
com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$5 -> com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$for:
    java.lang.Float get(android.view.View) -> do
    void set(android.view.View,java.lang.Float) -> do
com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$ExtendedFloatingActionButtonBehavior -> com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$ExtendedFloatingActionButtonBehavior:
    boolean autoHideEnabled -> int
    boolean autoShrinkEnabled -> new
    android.graphics.Rect tmpRect -> do
    com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$OnChangedCallback internalAutoHideCallback -> if
    com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$OnChangedCallback internalAutoShrinkCallback -> for
    void extendOrShow(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> do
    boolean getInsetDodgeRect(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.graphics.Rect) -> do
    boolean getInsetDodgeRect(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton,android.graphics.Rect) -> do
    boolean isBottomSheet(android.view.View) -> do
    void offsetIfNeeded(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> do
    void onAttachedToLayoutParams(androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams) -> do
    boolean onDependentViewChanged(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton,android.view.View) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton,int) -> do
    boolean shouldUpdateVisibility(android.view.View,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> do
    boolean updateFabVisibilityForAppBarLayout(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> do
    boolean onDependentViewChanged(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> if
    void shrinkOrHide(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> if
    boolean updateFabVisibilityForBottomSheet(android.view.View,com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton) -> if
com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$OnChangedCallback -> com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$int:
com.google.android.material.floatingactionbutton.FloatingActionButton -> com.google.android.material.floatingactionbutton.FloatingActionButton:
    com.google.android.material.expandable.ExpandableWidgetHelper expandableWidgetHelper -> catch
    android.graphics.PorterDuff$Mode imageMode -> try
    android.graphics.Rect touchArea -> void
    androidx.appcompat.widget.AppCompatImageHelper imageHelper -> break
    android.graphics.PorterDuff$Mode backgroundTintMode -> int
    android.content.res.ColorStateList backgroundTint -> for
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl impl -> class
    int maxImageSize -> goto
    boolean compatPadding -> long
    int imagePadding -> else
    android.graphics.Rect shadowPadding -> this
    int customSize -> char
    android.content.res.ColorStateList rippleColor -> byte
    int size -> case
    android.content.res.ColorStateList imageTint -> new
    int access$000(com.google.android.material.floatingactionbutton.FloatingActionButton) -> do
    void access$101(com.google.android.material.floatingactionbutton.FloatingActionButton,android.graphics.drawable.Drawable) -> do
    void addOnHideAnimationListener(android.animation.Animator$AnimatorListener) -> do
    void addTransformationCallback(com.google.android.material.animation.TransformationCallback) -> do
    boolean getContentRect(android.graphics.Rect) -> do
    int getSizeDimension(int) -> do
    void hide(com.google.android.material.floatingactionbutton.FloatingActionButton$OnVisibilityChangedListener) -> do
    void hide(com.google.android.material.floatingactionbutton.FloatingActionButton$OnVisibilityChangedListener,boolean) -> do
    boolean isExpanded() -> do
    int resolveAdjustedSize(int,int) -> do
    boolean isOrWillBeShown() -> for
    void offsetRectWithShadow(android.graphics.Rect) -> for
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$InternalVisibilityChangedListener wrapOnVisibilityChangedListener(com.google.android.material.floatingactionbutton.FloatingActionButton$OnVisibilityChangedListener) -> for
    void addOnShowAnimationListener(android.animation.Animator$AnimatorListener) -> if
    void getMeasuredContentRect(android.graphics.Rect) -> if
    boolean isOrWillBeHidden() -> if
    void show(com.google.android.material.floatingactionbutton.FloatingActionButton$OnVisibilityChangedListener) -> if
    void show(com.google.android.material.floatingactionbutton.FloatingActionButton$OnVisibilityChangedListener,boolean) -> if
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl createImpl() -> int
    void onApplySupportImageTint() -> new
com.google.android.material.floatingactionbutton.FloatingActionButton$1 -> com.google.android.material.floatingactionbutton.FloatingActionButton$do:
    com.google.android.material.floatingactionbutton.FloatingActionButton this$0 -> if
    com.google.android.material.floatingactionbutton.FloatingActionButton$OnVisibilityChangedListener val$listener -> do
    void onShown() -> do
    void onHidden() -> if
com.google.android.material.floatingactionbutton.FloatingActionButton$BaseBehavior -> com.google.android.material.floatingactionbutton.FloatingActionButton$BaseBehavior:
    boolean autoHideEnabled -> for
    android.graphics.Rect tmpRect -> do
    com.google.android.material.floatingactionbutton.FloatingActionButton$OnVisibilityChangedListener internalAutoHideListener -> if
    boolean getInsetDodgeRect(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.graphics.Rect) -> do
    boolean getInsetDodgeRect(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.FloatingActionButton,android.graphics.Rect) -> do
    boolean isBottomSheet(android.view.View) -> do
    void offsetIfNeeded(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.FloatingActionButton) -> do
    void onAttachedToLayoutParams(androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams) -> do
    boolean onDependentViewChanged(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.FloatingActionButton,android.view.View) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.FloatingActionButton,int) -> do
    boolean shouldUpdateVisibility(android.view.View,com.google.android.material.floatingactionbutton.FloatingActionButton) -> do
    boolean updateFabVisibilityForAppBarLayout(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.appbar.AppBarLayout,com.google.android.material.floatingactionbutton.FloatingActionButton) -> do
    boolean onDependentViewChanged(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> if
    boolean updateFabVisibilityForBottomSheet(android.view.View,com.google.android.material.floatingactionbutton.FloatingActionButton) -> if
com.google.android.material.floatingactionbutton.FloatingActionButton$Behavior -> com.google.android.material.floatingactionbutton.FloatingActionButton$Behavior:
    boolean getInsetDodgeRect(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.FloatingActionButton,android.graphics.Rect) -> do
    void onAttachedToLayoutParams(androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams) -> do
    boolean onDependentViewChanged(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.FloatingActionButton,android.view.View) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,com.google.android.material.floatingactionbutton.FloatingActionButton,int) -> do
com.google.android.material.floatingactionbutton.FloatingActionButton$OnVisibilityChangedListener -> com.google.android.material.floatingactionbutton.FloatingActionButton$if:
    void onHidden(com.google.android.material.floatingactionbutton.FloatingActionButton) -> do
    void onShown(com.google.android.material.floatingactionbutton.FloatingActionButton) -> if
com.google.android.material.floatingactionbutton.FloatingActionButton$ShadowDelegateImpl -> com.google.android.material.floatingactionbutton.FloatingActionButton$for:
    com.google.android.material.floatingactionbutton.FloatingActionButton this$0 -> do
    boolean isCompatPaddingEnabled() -> do
    void setBackgroundDrawable(android.graphics.drawable.Drawable) -> do
    void setShadowPadding(int,int,int,int) -> do
com.google.android.material.floatingactionbutton.FloatingActionButton$TransformationCallbackWrapper -> com.google.android.material.floatingactionbutton.FloatingActionButton$int:
    com.google.android.material.floatingactionbutton.FloatingActionButton this$0 -> if
    com.google.android.material.animation.TransformationCallback listener -> do
    void onScaleChanged() -> do
    void onTranslationChanged() -> if
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl -> com.google.android.material.floatingactionbutton.if:
    android.graphics.Rect tmpRect -> native
    java.util.ArrayList showListeners -> super
    java.util.ArrayList hideListeners -> throw
    com.google.android.material.floatingactionbutton.FloatingActionButton view -> double
    int minTouchTargetSize -> goto
    com.google.android.material.animation.MotionSpec hideMotionSpec -> class
    int[] HOVERED_ENABLED_STATE_SET -> finally
    com.google.android.material.animation.MotionSpec defaultShowMotionSpec -> this
    android.graphics.drawable.Drawable contentBackground -> new
    float pressedTranslationZ -> else
    int[] HOVERED_FOCUSED_ENABLED_STATE_SET -> default
    android.graphics.Matrix tmpMatrix -> static
    android.animation.TimeInterpolator ELEVATION_ANIM_INTERPOLATOR -> throws
    java.util.ArrayList transformationCallbacks -> while
    android.graphics.drawable.Drawable rippleDrawable -> for
    com.google.android.material.animation.MotionSpec defaultHideMotionSpec -> void
    float rotation -> const
    boolean shadowPaddingEnabled -> byte
    android.graphics.RectF tmpRectF2 -> return
    android.view.ViewTreeObserver$OnPreDrawListener preDrawListener -> switch
    com.google.android.material.shape.ShapeAppearanceModel shapeAppearance -> do
    com.google.android.material.animation.MotionSpec showMotionSpec -> catch
    boolean ensureMinTouchTargetSize -> try
    float elevation -> case
    com.google.android.material.internal.StateListAnimator stateListAnimator -> long
    int animState -> short
    android.graphics.RectF tmpRectF1 -> public
    int[] PRESSED_ENABLED_STATE_SET -> boolean
    int maxImageSize -> float
    com.google.android.material.shape.MaterialShapeDrawable shapeDrawable -> if
    int[] FOCUSED_ENABLED_STATE_SET -> extends
    int[] EMPTY_STATE_SET -> private
    float hoveredFocusedTranslationZ -> char
    int[] ENABLED_STATE_SET -> package
    com.google.android.material.shadow.ShadowViewDelegate shadowViewDelegate -> import
    com.google.android.material.floatingactionbutton.BorderDrawable borderDrawable -> int
    android.animation.Animator currentAnimator -> break
    float imageMatrixScale -> final
    void onPreDraw() -> break
    com.google.android.material.shape.ShapeAppearanceModel getShapeAppearance() -> byte
    com.google.android.material.animation.MotionSpec getShowMotionSpec() -> case
    void onScaleChanged() -> catch
    boolean isOrWillBeHidden() -> char
    void onTranslationChanged() -> class
    boolean requirePreDrawListener() -> const
    int access$002(com.google.android.material.floatingactionbutton.FloatingActionButtonImpl,int) -> do
    android.animation.Animator access$102(com.google.android.material.floatingactionbutton.FloatingActionButtonImpl,android.animation.Animator) -> do
    float access$202(com.google.android.material.floatingactionbutton.FloatingActionButtonImpl,float) -> do
    void addOnHideAnimationListener(android.animation.Animator$AnimatorListener) -> do
    void addTransformationCallback(com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$InternalTransformationCallback) -> do
    void calculateImageMatrixFromScale(float,android.graphics.Matrix) -> do
    android.animation.AnimatorSet createAnimator(com.google.android.material.animation.MotionSpec,float,float,float) -> do
    android.animation.ValueAnimator createElevationAnimator(com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$ShadowAnimatorImpl) -> do
    android.graphics.drawable.Drawable getContentBackground() -> do
    void getPadding(android.graphics.Rect) -> do
    void hide(com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$InternalVisibilityChangedListener,boolean) -> do
    void onDrawableStateChanged(int[]) -> do
    void onElevationsChanged(float,float,float) -> do
    void setBackgroundTintList(android.content.res.ColorStateList) -> do
    void setBackgroundTintMode(android.graphics.PorterDuff$Mode) -> do
    void setElevation(float) -> do
    void setEnsureMinTouchTargetSize(boolean) -> do
    void setHideMotionSpec(com.google.android.material.animation.MotionSpec) -> do
    void setShapeAppearance(com.google.android.material.shape.ShapeAppearanceModel) -> do
    void workAroundOreoBug(android.animation.ObjectAnimator) -> do
    com.google.android.material.animation.MotionSpec getDefaultShowMotionSpec() -> double
    boolean isOrWillBeShown() -> else
    boolean shouldAddPadding() -> final
    boolean shouldExpandBoundsForA11y() -> float
    boolean getEnsureMinTouchTargetSize() -> for
    void setImageMatrixScale(float) -> for
    void jumpDrawableToCurrentState() -> goto
    void addOnShowAnimationListener(android.animation.Animator$AnimatorListener) -> if
    float getElevation() -> if
    void onPaddingUpdated(android.graphics.Rect) -> if
    void setHoveredFocusedTranslationZ(float) -> if
    void setRippleColor(android.content.res.ColorStateList) -> if
    void setShadowPaddingEnabled(boolean) -> if
    void setShowMotionSpec(com.google.android.material.animation.MotionSpec) -> if
    void show(com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$InternalVisibilityChangedListener,boolean) -> if
    android.view.ViewTreeObserver$OnPreDrawListener getOrCreatePreDrawListener() -> import
    com.google.android.material.animation.MotionSpec getHideMotionSpec() -> int
    void setPressedTranslationZ(float) -> int
    void onAttachedToWindow() -> long
    boolean shouldAnimateVisibilityChange() -> native
    float getHoveredFocusedTranslationZ() -> new
    void updateShapeElevation(float) -> new
    void updateFromViewRotation() -> short
    void updateImageMatrixScale() -> super
    void onCompatShadowChanged() -> this
    void updatePadding() -> throw
    float getPressedTranslationZ() -> try
    void onDetachedFromWindow() -> void
    com.google.android.material.animation.MotionSpec getDefaultHideMotionSpec() -> while
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$1 -> com.google.android.material.floatingactionbutton.if$do:
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl this$0 -> int
    boolean cancelled -> do
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$InternalVisibilityChangedListener val$listener -> for
    boolean val$fromUser -> if
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$2 -> com.google.android.material.floatingactionbutton.if$if:
    boolean val$fromUser -> do
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$InternalVisibilityChangedListener val$listener -> if
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl this$0 -> for
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$3 -> com.google.android.material.floatingactionbutton.if$for:
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl this$0 -> int
    android.graphics.Matrix evaluate(float,android.graphics.Matrix,android.graphics.Matrix) -> do
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$4 -> com.google.android.material.floatingactionbutton.if$int:
    android.animation.FloatEvaluator floatEvaluator -> do
    java.lang.Float evaluate(float,java.lang.Float,java.lang.Float) -> do
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$5 -> com.google.android.material.floatingactionbutton.if$new:
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl this$0 -> if
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$DisabledElevationAnimation -> com.google.android.material.floatingactionbutton.if$try:
    float getTargetShadowSize() -> do
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$ElevateToHoveredFocusedTranslationZAnimation -> com.google.android.material.floatingactionbutton.if$byte:
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl this$0 -> new
    float getTargetShadowSize() -> do
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$ElevateToPressedTranslationZAnimation -> com.google.android.material.floatingactionbutton.if$case:
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl this$0 -> new
    float getTargetShadowSize() -> do
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$InternalTransformationCallback -> com.google.android.material.floatingactionbutton.if$char:
    void onScaleChanged() -> do
    void onTranslationChanged() -> if
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$InternalVisibilityChangedListener -> com.google.android.material.floatingactionbutton.if$else:
    void onShown() -> do
    void onHidden() -> if
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$ResetElevationAnimation -> com.google.android.material.floatingactionbutton.if$goto:
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl this$0 -> new
    float getTargetShadowSize() -> do
com.google.android.material.floatingactionbutton.FloatingActionButtonImpl$ShadowAnimatorImpl -> com.google.android.material.floatingactionbutton.if$long:
    com.google.android.material.floatingactionbutton.FloatingActionButtonImpl this$0 -> int
    boolean validValues -> do
    float shadowSizeEnd -> for
    float shadowSizeStart -> if
    float getTargetShadowSize() -> do
com.google.android.material.floatingactionbutton.FloatingActionButtonImplLollipop -> com.google.android.material.floatingactionbutton.for:
    boolean requirePreDrawListener() -> const
    android.animation.Animator createElevationAnimator(float,float) -> do
    void getPadding(android.graphics.Rect) -> do
    void onDrawableStateChanged(int[]) -> do
    void onElevationsChanged(float,float,float) -> do
    boolean shouldAddPadding() -> final
    void jumpDrawableToCurrentState() -> goto
    float getElevation() -> if
    void setRippleColor(android.content.res.ColorStateList) -> if
    void updateFromViewRotation() -> short
    void onCompatShadowChanged() -> this
com.google.android.material.floatingactionbutton.MotionStrategy -> com.google.android.material.floatingactionbutton.int:
    void performNow() -> byte
    com.google.android.material.animation.MotionSpec getMotionSpec() -> do
    void onChange(com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton$OnChangedCallback) -> do
    void setMotionSpec(com.google.android.material.animation.MotionSpec) -> do
    boolean shouldCancel() -> for
    android.animation.AnimatorSet createAnimator() -> if
    void onAnimationEnd() -> int
    void onAnimationCancel() -> new
    java.util.List getListeners() -> try
com.google.android.material.internal.BaselineLayout -> com.google.android.material.internal.BaselineLayout:
    int baseline -> if
com.google.android.material.internal.CheckableImageButton -> com.google.android.material.internal.CheckableImageButton:
    int[] DRAWABLE_STATE_CHECKED -> byte
    boolean checked -> int
    boolean checkable -> new
    boolean pressable -> try
    boolean isCheckable() -> do
com.google.android.material.internal.CheckableImageButton$1 -> com.google.android.material.internal.CheckableImageButton$do:
    com.google.android.material.internal.CheckableImageButton this$0 -> int
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> if
com.google.android.material.internal.CheckableImageButton$SavedState -> com.google.android.material.internal.CheckableImageButton$if:
    boolean checked -> int
    void readFromParcel(android.os.Parcel) -> do
com.google.android.material.internal.CheckableImageButton$SavedState$1 -> com.google.android.material.internal.CheckableImageButton$if$do:
com.google.android.material.internal.CollapsingTextHelper -> com.google.android.material.internal.do:
    android.graphics.Typeface collapsedTypeface -> final
    boolean isRtl -> import
    float expandedShadowRadius -> protected
    boolean useTexture -> native
    float textureAscent -> static
    int[] state -> default
    float expandedShadowDx -> transient
    android.graphics.Bitmap expandedTitleTexture -> public
    android.graphics.Typeface currentTypeface -> short
    float collapsedShadowDx -> strictfp
    int collapsedTextGravity -> case
    float expandedDrawY -> this
    android.content.res.ColorStateList collapsedShadowColor -> interface
    android.view.View view -> do
    float expandedFraction -> for
    float expandedTextSize -> char
    android.graphics.RectF currentBounds -> try
    android.content.res.ColorStateList expandedShadowColor -> instanceof
    android.animation.TimeInterpolator positionInterpolator -> private
    float scale -> throws
    float currentDrawX -> class
    float expandedDrawX -> break
    android.graphics.Rect expandedBounds -> int
    float expandedShadowDy -> implements
    float collapsedDrawY -> void
    float collapsedDrawX -> catch
    float collapsedTextSize -> else
    java.lang.CharSequence text -> while
    float collapsedShadowRadius -> continue
    android.graphics.Rect collapsedBounds -> new
    android.content.res.ColorStateList collapsedTextColor -> long
    float currentDrawY -> const
    float currentTextSize -> boolean
    android.graphics.Paint DEBUG_DRAW_PAINT -> ʻ
    boolean USE_SCALING_TEXTURE -> synchronized
    float textureDescent -> switch
    com.google.android.material.resources.CancelableFontCallback collapsedFontCallback -> throw
    com.google.android.material.resources.CancelableFontCallback expandedFontCallback -> super
    android.animation.TimeInterpolator textSizeInterpolator -> abstract
    android.graphics.Typeface expandedTypeface -> float
    android.graphics.Paint texturePaint -> return
    android.text.TextPaint textPaint -> finally
    android.text.TextPaint tmpPaint -> package
    boolean drawTitle -> if
    android.content.res.ColorStateList expandedTextColor -> goto
    int expandedTextGravity -> byte
    float collapsedShadowDy -> volatile
    java.lang.CharSequence textToDraw -> double
    boolean boundsChanged -> extends
    boolean isStateful() -> byte
    void onBoundsChanged() -> case
    void recalculate() -> char
    int blendColors(int,int,float) -> do
    float calculateCollapsedTextWidth() -> do
    void draw(android.graphics.Canvas) -> do
    void getCollapsedTextActualBounds(android.graphics.RectF) -> do
    void getTextPaintCollapsed(android.text.TextPaint) -> do
    boolean isClose(float,float) -> do
    float lerp(float,float,float,android.animation.TimeInterpolator) -> do
    boolean rectEquals(android.graphics.Rect,int,int,int,int) -> do
    void setCollapsedBounds(int,int,int,int) -> do
    void setCollapsedBounds(android.graphics.Rect) -> do
    void setCollapsedTextAppearance(int) -> do
    void setCollapsedTextColor(android.content.res.ColorStateList) -> do
    void setCollapsedTypeface(android.graphics.Typeface) -> do
    void setExpandedTextSize(float) -> do
    void setPositionInterpolator(android.animation.TimeInterpolator) -> do
    boolean setState(int[]) -> do
    void setText(java.lang.CharSequence) -> do
    void calculateBaseOffsets() -> else
    void calculateOffsets(float) -> for
    float getCollapsedTextHeight() -> for
    int getCurrentColor(android.content.res.ColorStateList) -> for
    boolean setCollapsedTypefaceInternal(android.graphics.Typeface) -> for
    void setExpandedTextGravity(int) -> for
    void calculateCurrentOffsets() -> goto
    boolean calculateIsRtl(java.lang.CharSequence) -> if
    android.content.res.ColorStateList getCollapsedTextColor() -> if
    void getTextPaintExpanded(android.text.TextPaint) -> if
    void setCollapsedTextGravity(int) -> if
    void setExpandedBounds(int,int,int,int) -> if
    void setExpandedBounds(android.graphics.Rect) -> if
    void setExpandedTextColor(android.content.res.ColorStateList) -> if
    void setExpansionFraction(float) -> if
    void setTextSizeInterpolator(android.animation.TimeInterpolator) -> if
    void setTypefaces(android.graphics.Typeface) -> if
    void calculateUsingTextSize(float) -> int
    int getCurrentCollapsedTextColor() -> int
    boolean setExpandedTypefaceInternal(android.graphics.Typeface) -> int
    void clearTexture() -> long
    float getExpandedTextHeight() -> new
    void interpolateBounds(float) -> new
    void ensureExpandedTexture() -> this
    float getExpansionFraction() -> try
    void setInterpolatedTextSize(float) -> try
    int getCurrentExpandedTextColor() -> void
com.google.android.material.internal.CollapsingTextHelper$1 -> com.google.android.material.internal.do$do:
    com.google.android.material.internal.CollapsingTextHelper this$0 -> do
    void apply(android.graphics.Typeface) -> do
com.google.android.material.internal.DescendantOffsetUtils -> com.google.android.material.internal.if:
    java.lang.ThreadLocal rectF -> if
    java.lang.ThreadLocal matrix -> do
    void getDescendantRect(android.view.ViewGroup,android.view.View,android.graphics.Rect) -> do
    void offsetDescendantMatrix(android.view.ViewParent,android.view.View,android.graphics.Matrix) -> do
    void offsetDescendantRect(android.view.ViewGroup,android.view.View,android.graphics.Rect) -> if
com.google.android.material.internal.FlowLayout -> com.google.android.material.internal.for:
    int lineSpacing -> if
    boolean singleLine -> int
    int itemSpacing -> for
    int getMeasuredDimension(int,int,int) -> do
    boolean isSingleLine() -> do
    void loadFromAttributes(android.content.Context,android.util.AttributeSet) -> do
com.google.android.material.internal.ForegroundLinearLayout -> com.google.android.material.internal.int:
    android.graphics.Rect overlayBounds -> final
    boolean foregroundBoundsChanged -> super
    android.graphics.drawable.Drawable foreground -> class
    int foregroundGravity -> float
    boolean mForegroundInPadding -> short
    android.graphics.Rect selfBounds -> const
com.google.android.material.internal.NavigationMenu -> com.google.android.material.internal.new:
com.google.android.material.internal.NavigationMenuItemView -> com.google.android.material.internal.NavigationMenuItemView:
    boolean needsEmptyIcon -> while
    int[] CHECKED_STATE_SET -> boolean
    boolean checkable -> double
    android.graphics.drawable.Drawable emptyDrawable -> switch
    androidx.core.view.AccessibilityDelegateCompat accessibilityDelegate -> throws
    android.content.res.ColorStateList iconTintList -> return
    int iconSize -> throw
    androidx.appcompat.view.menu.MenuItemImpl itemData -> public
    boolean hasIconTintList -> static
    android.widget.FrameLayout actionArea -> native
    android.widget.CheckedTextView textView -> import
    boolean shouldExpandActionArea() -> byte
    void initialize(androidx.appcompat.view.menu.MenuItemImpl,int) -> do
    boolean prefersCondensedTitle() -> for
    void recycle() -> int
    void adjustAppearance() -> new
    android.graphics.drawable.StateListDrawable createDefaultBackground() -> try
com.google.android.material.internal.NavigationMenuItemView$1 -> com.google.android.material.internal.NavigationMenuItemView$do:
    com.google.android.material.internal.NavigationMenuItemView this$0 -> int
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
com.google.android.material.internal.NavigationMenuPresenter -> com.google.android.material.internal.try:
    int itemIconPadding -> break
    int paddingTopDefault -> float
    com.google.android.material.internal.NavigationMenuPresenter$NavigationMenuAdapter adapter -> byte
    int itemIconSize -> catch
    int id -> try
    android.view.View$OnClickListener onClickListener -> throw
    int itemHorizontalPadding -> void
    androidx.appcompat.view.menu.MenuPresenter$Callback callback -> int
    int overScrollMode -> super
    boolean textAppearanceSet -> else
    int itemMaxLines -> final
    androidx.appcompat.view.menu.MenuBuilder menu -> new
    android.view.LayoutInflater layoutInflater -> case
    android.content.res.ColorStateList textColor -> goto
    android.content.res.ColorStateList iconTintList -> long
    android.graphics.drawable.Drawable itemBackground -> this
    android.widget.LinearLayout headerLayout -> for
    boolean hasCustomItemIconSize -> class
    int textAppearance -> char
    com.google.android.material.internal.NavigationMenuView menuView -> if
    boolean isBehindStatusBar -> const
    int paddingSeparator -> short
    int getItemHorizontalPadding() -> byte
    void setItemTextAppearance(int) -> byte
    int getItemIconPadding() -> case
    void setOverScrollMode(int) -> case
    int getItemMaxLines() -> char
    int access$000(com.google.android.material.internal.NavigationMenuPresenter) -> do
    void addHeaderView(android.view.View) -> do
    void dispatchApplyWindowInsets(androidx.core.view.WindowInsetsCompat) -> do
    boolean expandItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> do
    androidx.appcompat.view.menu.MenuItemImpl getCheckedItem() -> do
    androidx.appcompat.view.menu.MenuView getMenuView(android.view.ViewGroup) -> do
    android.view.View inflateHeaderView(int) -> do
    void initForMenu(android.content.Context,androidx.appcompat.view.menu.MenuBuilder) -> do
    void onCloseMenu(androidx.appcompat.view.menu.MenuBuilder,boolean) -> do
    void onRestoreInstanceState(android.os.Parcelable) -> do
    boolean onSubMenuSelected(androidx.appcompat.view.menu.SubMenuBuilder) -> do
    void setCallback(androidx.appcompat.view.menu.MenuPresenter$Callback) -> do
    void setCheckedItem(androidx.appcompat.view.menu.MenuItemImpl) -> do
    void setItemBackground(android.graphics.drawable.Drawable) -> do
    void setItemIconTintList(android.content.res.ColorStateList) -> do
    void updateMenuView(boolean) -> do
    android.content.res.ColorStateList getItemTextColor() -> else
    int getId() -> for
    void setItemHorizontalPadding(int) -> for
    void setUpdateSuspended(boolean) -> for
    android.content.res.ColorStateList getItemTintList() -> goto
    boolean collapseItemActionView(androidx.appcompat.view.menu.MenuBuilder,androidx.appcompat.view.menu.MenuItemImpl) -> if
    int getHeaderCount() -> if
    void setBehindStatusBar(boolean) -> if
    void setId(int) -> if
    void setItemTextColor(android.content.res.ColorStateList) -> if
    boolean flagActionItems() -> int
    void setItemIconPadding(int) -> int
    void updateTopPadding() -> long
    android.graphics.drawable.Drawable getItemBackground() -> new
    void setItemIconSize(int) -> new
    android.os.Parcelable onSaveInstanceState() -> try
    void setItemMaxLines(int) -> try
com.google.android.material.internal.NavigationMenuPresenter$1 -> com.google.android.material.internal.try$do:
    com.google.android.material.internal.NavigationMenuPresenter this$0 -> if
com.google.android.material.internal.NavigationMenuPresenter$HeaderViewHolder -> com.google.android.material.internal.try$if:
com.google.android.material.internal.NavigationMenuPresenter$NavigationMenuAdapter -> com.google.android.material.internal.try$for:
    com.google.android.material.internal.NavigationMenuPresenter this$0 -> try
    androidx.appcompat.view.menu.MenuItemImpl checkedItem -> int
    java.util.ArrayList items -> for
    boolean updateSuspended -> new
    int getRowCount() -> byte
    void update() -> case
    void prepareMenuItems() -> char
    void appendTransparentIconIfMissing(int,int) -> do
    int getItemCount() -> do
    long getItemId(int) -> do
    void onBindViewHolder(com.google.android.material.internal.NavigationMenuPresenter$ViewHolder,int) -> do
    void onViewRecycled(com.google.android.material.internal.NavigationMenuPresenter$ViewHolder) -> do
    void restoreInstanceState(android.os.Bundle) -> do
    void setCheckedItem(androidx.appcompat.view.menu.MenuItemImpl) -> do
    int getItemViewType(int) -> if
    void onBindViewHolder(androidx.recyclerview.widget.RecyclerView$ViewHolder,int) -> if
    androidx.recyclerview.widget.RecyclerView$ViewHolder onCreateViewHolder(android.view.ViewGroup,int) -> if
    com.google.android.material.internal.NavigationMenuPresenter$ViewHolder onCreateViewHolder(android.view.ViewGroup,int) -> if
    void setUpdateSuspended(boolean) -> if
    void onViewRecycled(androidx.recyclerview.widget.RecyclerView$ViewHolder) -> int
    android.os.Bundle createInstanceState() -> new
    androidx.appcompat.view.menu.MenuItemImpl getCheckedItem() -> try
com.google.android.material.internal.NavigationMenuPresenter$NavigationMenuHeaderItem -> com.google.android.material.internal.try$int:
com.google.android.material.internal.NavigationMenuPresenter$NavigationMenuItem -> com.google.android.material.internal.try$new:
com.google.android.material.internal.NavigationMenuPresenter$NavigationMenuSeparatorItem -> com.google.android.material.internal.try$try:
    int paddingBottom -> if
    int paddingTop -> do
    int getPaddingBottom() -> do
    int getPaddingTop() -> if
com.google.android.material.internal.NavigationMenuPresenter$NavigationMenuTextItem -> com.google.android.material.internal.try$byte:
    androidx.appcompat.view.menu.MenuItemImpl menuItem -> do
    boolean needsEmptyIcon -> if
    androidx.appcompat.view.menu.MenuItemImpl getMenuItem() -> do
com.google.android.material.internal.NavigationMenuPresenter$NavigationMenuViewAccessibilityDelegate -> com.google.android.material.internal.try$case:
    com.google.android.material.internal.NavigationMenuPresenter this$0 -> try
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
com.google.android.material.internal.NavigationMenuPresenter$NormalViewHolder -> com.google.android.material.internal.try$char:
com.google.android.material.internal.NavigationMenuPresenter$SeparatorViewHolder -> com.google.android.material.internal.try$else:
com.google.android.material.internal.NavigationMenuPresenter$SubheaderViewHolder -> com.google.android.material.internal.try$goto:
com.google.android.material.internal.NavigationMenuPresenter$ViewHolder -> com.google.android.material.internal.try$long:
com.google.android.material.internal.NavigationMenuView -> com.google.android.material.internal.NavigationMenuView:
    void initialize(androidx.appcompat.view.menu.MenuBuilder) -> do
com.google.android.material.internal.NavigationSubMenu -> com.google.android.material.internal.byte:
    void onItemsChanged(boolean) -> if
com.google.android.material.internal.ParcelableSparseArray -> com.google.android.material.internal.case:
com.google.android.material.internal.ParcelableSparseArray$1 -> com.google.android.material.internal.case$do:
com.google.android.material.internal.ScrimInsetsFrameLayout -> com.google.android.material.internal.char:
    android.graphics.Rect tempRect -> int
    android.graphics.drawable.Drawable insetForeground -> if
    android.graphics.Rect insets -> for
    boolean drawTopInsetForeground -> new
    boolean drawBottomInsetForeground -> try
    void onInsetsChanged(androidx.core.view.WindowInsetsCompat) -> do
com.google.android.material.internal.ScrimInsetsFrameLayout$1 -> com.google.android.material.internal.char$do:
    com.google.android.material.internal.ScrimInsetsFrameLayout this$0 -> do
    androidx.core.view.WindowInsetsCompat onApplyWindowInsets(android.view.View,androidx.core.view.WindowInsetsCompat) -> do
com.google.android.material.internal.StateListAnimator -> com.google.android.material.internal.else:
    java.util.ArrayList tuples -> do
    android.animation.ValueAnimator runningAnimator -> for
    android.animation.Animator$AnimatorListener animationListener -> int
    com.google.android.material.internal.StateListAnimator$Tuple lastMatch -> if
    void addState(int[],android.animation.ValueAnimator) -> do
    void jumpToCurrentState() -> do
    void setState(int[]) -> do
    void start(com.google.android.material.internal.StateListAnimator$Tuple) -> do
    void cancel() -> if
com.google.android.material.internal.StateListAnimator$1 -> com.google.android.material.internal.else$do:
    com.google.android.material.internal.StateListAnimator this$0 -> do
com.google.android.material.internal.StateListAnimator$Tuple -> com.google.android.material.internal.else$if:
    android.animation.ValueAnimator animator -> if
    int[] specs -> do
com.google.android.material.internal.TextDrawableHelper -> com.google.android.material.internal.goto:
    com.google.android.material.resources.TextAppearanceFontCallback fontCallback -> if
    float textWidth -> for
    boolean textWidthDirty -> int
    com.google.android.material.resources.TextAppearance textAppearance -> try
    android.text.TextPaint textPaint -> do
    java.lang.ref.WeakReference delegate -> new
    boolean access$002(com.google.android.material.internal.TextDrawableHelper,boolean) -> do
    java.lang.ref.WeakReference access$100(com.google.android.material.internal.TextDrawableHelper) -> do
    float calculateTextWidth(java.lang.CharSequence) -> do
    com.google.android.material.resources.TextAppearance getTextAppearance() -> do
    float getTextWidth(java.lang.String) -> do
    void setDelegate(com.google.android.material.internal.TextDrawableHelper$TextDrawableDelegate) -> do
    void setTextAppearance(com.google.android.material.resources.TextAppearance,android.content.Context) -> do
    void setTextWidthDirty(boolean) -> do
    void updateTextPaintDrawState(android.content.Context) -> do
    android.text.TextPaint getTextPaint() -> if
com.google.android.material.internal.TextDrawableHelper$1 -> com.google.android.material.internal.goto$do:
    com.google.android.material.internal.TextDrawableHelper this$0 -> do
    void onFontRetrievalFailed(int) -> do
    void onFontRetrieved(android.graphics.Typeface,boolean) -> do
com.google.android.material.internal.TextDrawableHelper$TextDrawableDelegate -> com.google.android.material.internal.goto$if:
    void onTextSizeChange() -> do
com.google.android.material.internal.ThemeEnforcement -> com.google.android.material.internal.long:
    int[] ANDROID_THEME_OVERLAY_ATTRS -> for
    int[] MATERIAL_CHECK_ATTRS -> if
    int[] APPCOMPAT_CHECK_ATTRS -> do
    int[] MATERIAL_THEME_OVERLAY_ATTR -> int
    void checkAppCompatTheme(android.content.Context) -> do
    void checkCompatibleTheme(android.content.Context,android.util.AttributeSet,int,int) -> do
    void checkTextAppearance(android.content.Context,android.util.AttributeSet,int[],int,int,int[]) -> do
    void checkTheme(android.content.Context,int[],java.lang.String) -> do
    boolean isTheme(android.content.Context,int[]) -> do
    int obtainAndroidThemeOverlayId(android.content.Context,android.util.AttributeSet) -> do
    int obtainMaterialThemeOverlayId(android.content.Context,android.util.AttributeSet,int,int) -> for
    android.content.res.TypedArray obtainStyledAttributes(android.content.Context,android.util.AttributeSet,int[],int,int,int[]) -> for
    void checkMaterialTheme(android.content.Context) -> if
    android.content.Context createThemedContext(android.content.Context,android.util.AttributeSet,int,int) -> if
    boolean isCustomTextAppearanceValid(android.content.Context,android.util.AttributeSet,int[],int,int,int[]) -> if
    androidx.appcompat.widget.TintTypedArray obtainTintedStyledAttributes(android.content.Context,android.util.AttributeSet,int[],int,int,int[]) -> int
com.google.android.material.internal.ViewUtils -> com.google.android.material.internal.this:
    float dpToPx(android.content.Context,int) -> do
    float getParentAbsoluteElevation(android.view.View) -> do
    android.graphics.PorterDuff$Mode parseTintMode(int,android.graphics.PorterDuff$Mode) -> do
com.google.android.material.internal.VisibilityAwareImageButton -> com.google.android.material.internal.void:
    int userSetVisibility -> if
    void internalSetVisibility(int,boolean) -> do
com.google.android.material.math.MathUtils -> for.if.do.do.short.do:
    float dist(float,float,float,float) -> do
    float distanceToFurthestCorner(float,float,float,float,float,float) -> do
    float lerp(float,float,float) -> do
    float max(float,float,float,float) -> if
com.google.android.material.navigation.NavigationView -> com.google.android.material.navigation.NavigationView:
    android.view.MenuInflater menuInflater -> long
    com.google.android.material.internal.NavigationMenuPresenter presenter -> case
    android.view.ViewTreeObserver$OnGlobalLayoutListener onGlobalLayoutListener -> this
    int[] CHECKED_STATE_SET -> void
    com.google.android.material.internal.NavigationMenu menu -> byte
    int maxWidth -> else
    int[] tmpLocation -> goto
    com.google.android.material.navigation.NavigationView$OnNavigationItemSelectedListener listener -> char
    int[] DISABLED_STATE_SET -> break
    int[] access$000(com.google.android.material.navigation.NavigationView) -> do
    android.graphics.drawable.Drawable createDefaultItemBackground(androidx.appcompat.widget.TintTypedArray) -> do
    android.view.View inflateHeaderView(int) -> do
    void onInsetsChanged(androidx.core.view.WindowInsetsCompat) -> do
    void setupInsetScrimsListener() -> do
    android.content.res.ColorStateList createDefaultColorStateList(int) -> for
    com.google.android.material.internal.NavigationMenuPresenter access$100(com.google.android.material.navigation.NavigationView) -> if
    boolean hasShapeAppearance(androidx.appcompat.widget.TintTypedArray) -> if
    void inflateMenu(int) -> if
com.google.android.material.navigation.NavigationView$1 -> com.google.android.material.navigation.NavigationView$do:
    com.google.android.material.navigation.NavigationView this$0 -> if
    boolean onMenuItemSelected(androidx.appcompat.view.menu.MenuBuilder,android.view.MenuItem) -> do
    void onMenuModeChange(androidx.appcompat.view.menu.MenuBuilder) -> do
com.google.android.material.navigation.NavigationView$2 -> com.google.android.material.navigation.NavigationView$if:
    com.google.android.material.navigation.NavigationView this$0 -> if
com.google.android.material.navigation.NavigationView$OnNavigationItemSelectedListener -> com.google.android.material.navigation.NavigationView$for:
    boolean onNavigationItemSelected(android.view.MenuItem) -> do
com.google.android.material.navigation.NavigationView$SavedState -> com.google.android.material.navigation.NavigationView$int:
    android.os.Bundle menuState -> int
com.google.android.material.navigation.NavigationView$SavedState$1 -> com.google.android.material.navigation.NavigationView$int$do:
com.google.android.material.radiobutton.MaterialRadioButton -> for.if.do.do.super.do:
    int[][] ENABLED_CHECKED_STATES -> case
    int DEF_STYLE_RES -> byte
    boolean useMaterialThemeColors -> try
    android.content.res.ColorStateList materialThemeColorsTintList -> new
com.google.android.material.resources.CancelableFontCallback -> for.if.do.do.throw.do:
    boolean cancelled -> for
    com.google.android.material.resources.CancelableFontCallback$ApplyFont applyFont -> if
    android.graphics.Typeface fallbackFont -> do
    void cancel() -> do
    void onFontRetrievalFailed(int) -> do
    void onFontRetrieved(android.graphics.Typeface,boolean) -> do
    void updateIfNotCancelled(android.graphics.Typeface) -> do
com.google.android.material.resources.CancelableFontCallback$ApplyFont -> for.if.do.do.throw.do$do:
    void apply(android.graphics.Typeface) -> do
com.google.android.material.resources.MaterialAttributes -> for.if.do.do.throw.if:
    android.util.TypedValue resolve(android.content.Context,int) -> do
    boolean resolveBoolean(android.content.Context,int,boolean) -> do
    int resolveOrThrow(android.content.Context,int,java.lang.String) -> do
    int resolveOrThrow(android.view.View,int) -> do
com.google.android.material.resources.MaterialResources -> for.if.do.do.throw.for:
    android.content.res.ColorStateList getColorStateList(android.content.Context,android.content.res.TypedArray,int) -> do
    android.content.res.ColorStateList getColorStateList(android.content.Context,androidx.appcompat.widget.TintTypedArray,int) -> do
    int getDimensionPixelSize(android.content.Context,android.content.res.TypedArray,int,int) -> do
    int getIndexWithValue(android.content.res.TypedArray,int,int) -> do
    com.google.android.material.resources.TextAppearance getTextAppearance(android.content.Context,android.content.res.TypedArray,int) -> for
    android.graphics.drawable.Drawable getDrawable(android.content.Context,android.content.res.TypedArray,int) -> if
com.google.android.material.resources.TextAppearance -> for.if.do.do.throw.int:
    float textSize -> do
    int typeface -> int
    java.lang.String fontFamily -> new
    float shadowRadius -> char
    int fontFamilyResourceId -> else
    int textStyle -> for
    android.content.res.ColorStateList shadowColor -> try
    float shadowDx -> byte
    float shadowDy -> case
    android.content.res.ColorStateList textColor -> if
    boolean fontResolved -> goto
    android.graphics.Typeface font -> long
    android.graphics.Typeface access$000(com.google.android.material.resources.TextAppearance) -> do
    android.graphics.Typeface access$002(com.google.android.material.resources.TextAppearance,android.graphics.Typeface) -> do
    boolean access$102(com.google.android.material.resources.TextAppearance,boolean) -> do
    android.graphics.Typeface getFallbackFont() -> do
    android.graphics.Typeface getFont(android.content.Context) -> do
    void getFontAsync(android.content.Context,android.text.TextPaint,com.google.android.material.resources.TextAppearanceFontCallback) -> do
    void getFontAsync(android.content.Context,com.google.android.material.resources.TextAppearanceFontCallback) -> do
    void updateTextPaintMeasureState(android.text.TextPaint,android.graphics.Typeface) -> do
    void updateMeasureState(android.content.Context,android.text.TextPaint,com.google.android.material.resources.TextAppearanceFontCallback) -> for
    void createFallbackFont() -> if
    void updateDrawState(android.content.Context,android.text.TextPaint,com.google.android.material.resources.TextAppearanceFontCallback) -> if
com.google.android.material.resources.TextAppearance$1 -> for.if.do.do.throw.int$do:
    com.google.android.material.resources.TextAppearanceFontCallback val$callback -> do
    com.google.android.material.resources.TextAppearance this$0 -> if
    void onFontRetrievalFailed(int) -> do
    void onFontRetrieved(android.graphics.Typeface) -> do
com.google.android.material.resources.TextAppearance$2 -> for.if.do.do.throw.int$if:
    com.google.android.material.resources.TextAppearanceFontCallback val$callback -> if
    com.google.android.material.resources.TextAppearance this$0 -> for
    android.text.TextPaint val$textPaint -> do
    void onFontRetrievalFailed(int) -> do
    void onFontRetrieved(android.graphics.Typeface,boolean) -> do
com.google.android.material.resources.TextAppearanceConfig -> for.if.do.do.throw.new:
    boolean shouldLoadFontSynchronously -> do
    boolean shouldLoadFontSynchronously() -> do
com.google.android.material.resources.TextAppearanceFontCallback -> for.if.do.do.throw.try:
    void onFontRetrievalFailed(int) -> do
    void onFontRetrieved(android.graphics.Typeface,boolean) -> do
com.google.android.material.ripple.RippleDrawableCompat -> for.if.do.do.while.do:
    com.google.android.material.ripple.RippleDrawableCompat$RippleDrawableCompatState drawableState -> if
com.google.android.material.ripple.RippleDrawableCompat$1 -> for.if.do.do.while.do$do:
com.google.android.material.ripple.RippleDrawableCompat$RippleDrawableCompatState -> for.if.do.do.while.do$if:
    com.google.android.material.shape.MaterialShapeDrawable delegate -> do
    boolean shouldDrawDelegate -> if
com.google.android.material.ripple.RippleUtils -> for.if.do.do.while.if:
    boolean USE_FRAMEWORK_RIPPLE -> do
    java.lang.String LOG_TAG -> for
    int[] ENABLED_PRESSED_STATE_SET -> if
    android.content.res.ColorStateList sanitizeRippleDrawableColor(android.content.res.ColorStateList) -> do
    boolean shouldDrawRippleCompat(int[]) -> do
com.google.android.material.shadow.ShadowRenderer -> for.if.do.do.double.do:
    android.graphics.Paint edgeShadowPaint -> for
    int shadowStartColor -> int
    int[] cornerColors -> else
    android.graphics.Path scratch -> byte
    int shadowMiddleColor -> new
    float[] cornerPositions -> goto
    float[] edgePositions -> char
    int shadowEndColor -> try
    int[] edgeColors -> case
    android.graphics.Paint shadowPaint -> do
    android.graphics.Paint cornerShadowPaint -> if
    void drawCornerShadow(android.graphics.Canvas,android.graphics.Matrix,android.graphics.RectF,int,float,float) -> do
    void drawEdgeShadow(android.graphics.Canvas,android.graphics.Matrix,android.graphics.RectF,int) -> do
    android.graphics.Paint getShadowPaint() -> do
    void setShadowColor(int) -> do
com.google.android.material.shadow.ShadowViewDelegate -> for.if.do.do.double.if:
    boolean isCompatPaddingEnabled() -> do
    void setBackgroundDrawable(android.graphics.drawable.Drawable) -> do
    void setShadowPadding(int,int,int,int) -> do
com.google.android.material.shape.AbsoluteCornerSize -> for.if.do.do.import.do:
    float size -> do
    float getCornerSize(android.graphics.RectF) -> do
com.google.android.material.shape.AdjustedCornerSize -> for.if.do.do.import.if:
    com.google.android.material.shape.CornerSize other -> do
    float adjustment -> if
    float getCornerSize(android.graphics.RectF) -> do
com.google.android.material.shape.CornerSize -> for.if.do.do.import.for:
    float getCornerSize(android.graphics.RectF) -> do
com.google.android.material.shape.CornerTreatment -> for.if.do.do.import.int:
    void getCornerPath(com.google.android.material.shape.ShapePath,float,float,float) -> do
    void getCornerPath(com.google.android.material.shape.ShapePath,float,float,android.graphics.RectF,com.google.android.material.shape.CornerSize) -> do
com.google.android.material.shape.CutCornerTreatment -> for.if.do.do.import.new:
    float size -> do
    void getCornerPath(com.google.android.material.shape.ShapePath,float,float,float) -> do
com.google.android.material.shape.EdgeTreatment -> for.if.do.do.import.try:
    void getEdgePath(float,float,float,com.google.android.material.shape.ShapePath) -> do
com.google.android.material.shape.MaterialShapeDrawable -> for.if.do.do.import.byte:
    android.graphics.Region transparentRegion -> goto
    android.graphics.RectF pathBounds -> super
    android.graphics.RectF insetRectF -> else
    boolean pathDirty -> new
    android.graphics.Region scratchRegion -> long
    com.google.android.material.shape.ShapeAppearancePathProvider pathProvider -> const
    android.graphics.Path path -> byte
    android.graphics.PorterDuffColorFilter tintFilter -> final
    android.graphics.PorterDuffColorFilter strokeTintFilter -> float
    com.google.android.material.shape.ShapePath$ShadowCompatOperation[] cornerShadowOperation -> for
    android.graphics.RectF rectF -> char
    android.graphics.Paint strokePaint -> break
    android.graphics.Path pathInsetByStroke -> case
    com.google.android.material.shadow.ShadowRenderer shadowRenderer -> catch
    android.graphics.Paint clearPaint -> throw
    android.graphics.Paint fillPaint -> void
    com.google.android.material.shape.ShapePath$ShadowCompatOperation[] edgeShadowOperation -> int
    android.graphics.Rect padding -> short
    com.google.android.material.shape.MaterialShapeDrawable$MaterialShapeDrawableState drawableState -> if
    android.graphics.Matrix matrix -> try
    com.google.android.material.shape.ShapeAppearancePathProvider$PathListener pathShadowListener -> class
    com.google.android.material.shape.ShapeAppearanceModel strokeShapeAppearance -> this
    float getTranslationZ() -> break
    float getParentAbsoluteElevation() -> byte
    int getShadowOffsetX() -> case
    float getZ() -> catch
    int getShadowOffsetY() -> char
    boolean isElevationOverlayEnabled() -> class
    boolean isRoundRect() -> const
    com.google.android.material.shape.ShapePath$ShadowCompatOperation[] access$000(com.google.android.material.shape.MaterialShapeDrawable) -> do
    boolean access$302(com.google.android.material.shape.MaterialShapeDrawable,boolean) -> do
    android.graphics.PorterDuffColorFilter calculatePaintColorTintFilter(android.graphics.Paint,boolean) -> do
    void calculatePathForSize(android.graphics.RectF,android.graphics.Path) -> do
    android.graphics.PorterDuffColorFilter calculateTintColorTintFilter(android.content.res.ColorStateList,android.graphics.PorterDuff$Mode,boolean) -> do
    android.graphics.PorterDuffColorFilter calculateTintFilter(android.content.res.ColorStateList,android.graphics.PorterDuff$Mode,android.graphics.Paint,boolean) -> do
    com.google.android.material.shape.MaterialShapeDrawable createWithElevationOverlay(android.content.Context,float) -> do
    void drawCompatShadow(android.graphics.Canvas) -> do
    void drawShape(android.graphics.Canvas,android.graphics.Paint,android.graphics.Path,android.graphics.RectF) -> do
    void drawShape(android.graphics.Canvas,android.graphics.Paint,android.graphics.Path,com.google.android.material.shape.ShapeAppearanceModel,android.graphics.RectF) -> do
    void initializeElevationOverlay(android.content.Context) -> do
    int modulateAlpha(int,int) -> do
    void setElevation(float) -> do
    void setFillColor(android.content.res.ColorStateList) -> do
    void setPadding(int,int,int,int) -> do
    void setShadowCompatRotation(int) -> do
    void setStroke(float,int) -> do
    void setStroke(float,android.content.res.ColorStateList) -> do
    boolean updateColorsForState(int[]) -> do
    void invalidateSelfIgnoreShape() -> double
    int getShadowRadius() -> else
    void calculateStrokePath() -> final
    android.graphics.RectF getBoundsInsetByStroke() -> float
    void drawStrokeShape(android.graphics.Canvas) -> for
    float getBottomRightCornerResolvedSize() -> for
    void setParentAbsoluteElevation(float) -> for
    com.google.android.material.shape.ShapeAppearanceModel getShapeAppearanceModel() -> goto
    com.google.android.material.shape.ShapePath$ShadowCompatOperation[] access$100(com.google.android.material.shape.MaterialShapeDrawable) -> if
    void calculatePath(android.graphics.RectF,android.graphics.Path) -> if
    int compositeElevationOverlayIfNeeded(int) -> if
    void drawFillShape(android.graphics.Canvas) -> if
    float getBottomLeftCornerResolvedSize() -> if
    void setInterpolation(float) -> if
    void setStrokeColor(android.content.res.ColorStateList) -> if
    boolean requiresCompatShadow() -> import
    android.graphics.RectF getBoundsAsRectF() -> int
    void prepareCanvasForShadow(android.graphics.Canvas) -> int
    void setStrokeWidth(float) -> int
    android.content.res.ColorStateList getTintList() -> long
    boolean updateTintFilter() -> native
    float getElevation() -> new
    void updateZ() -> public
    float getStrokeInsetLength() -> short
    boolean hasCompatShadow() -> super
    float getTopLeftCornerResolvedSize() -> this
    boolean hasFill() -> throw
    android.content.res.ColorStateList getFillColor() -> try
    float getTopRightCornerResolvedSize() -> void
    boolean hasStroke() -> while
com.google.android.material.shape.MaterialShapeDrawable$1 -> for.if.do.do.import.byte$do:
    com.google.android.material.shape.MaterialShapeDrawable this$0 -> do
    void onCornerPathCreated(com.google.android.material.shape.ShapePath,android.graphics.Matrix,int) -> do
    void onEdgePathCreated(com.google.android.material.shape.ShapePath,android.graphics.Matrix,int) -> if
com.google.android.material.shape.MaterialShapeDrawable$2 -> for.if.do.do.import.byte$if:
    float val$strokeInsetLength -> do
    com.google.android.material.shape.CornerSize apply(com.google.android.material.shape.CornerSize) -> do
com.google.android.material.shape.MaterialShapeDrawable$MaterialShapeDrawableState -> for.if.do.do.import.byte$for:
    int alpha -> this
    int shadowCompatMode -> class
    int shadowCompatRotation -> float
    android.content.res.ColorStateList strokeTintList -> try
    android.graphics.ColorFilter colorFilter -> for
    boolean useTintColorForShadow -> short
    float parentAbsoluteElevation -> void
    float translationZ -> catch
    int shadowCompatRadius -> const
    android.content.res.ColorStateList fillColor -> int
    float scale -> else
    int shadowCompatOffset -> final
    com.google.android.material.elevation.ElevationOverlayProvider elevationOverlayProvider -> if
    float interpolation -> goto
    float strokeWidth -> long
    android.graphics.Paint$Style paintStyle -> super
    com.google.android.material.shape.ShapeAppearanceModel shapeAppearanceModel -> do
    android.content.res.ColorStateList tintList -> byte
    float elevation -> break
    android.content.res.ColorStateList strokeColor -> new
    android.graphics.PorterDuff$Mode tintMode -> case
    android.graphics.Rect padding -> char
com.google.android.material.shape.MaterialShapeUtils -> for.if.do.do.import.case:
    com.google.android.material.shape.CornerTreatment createCornerTreatment(int) -> do
    com.google.android.material.shape.CornerTreatment createDefaultCornerTreatment() -> do
    void setElevation(android.view.View,float) -> do
    void setParentAbsoluteElevation(android.view.View) -> do
    void setParentAbsoluteElevation(android.view.View,com.google.android.material.shape.MaterialShapeDrawable) -> do
    com.google.android.material.shape.EdgeTreatment createDefaultEdgeTreatment() -> if
com.google.android.material.shape.RelativeCornerSize -> for.if.do.do.import.char:
    float percent -> do
    float getCornerSize(android.graphics.RectF) -> do
com.google.android.material.shape.RoundedCornerTreatment -> for.if.do.do.import.else:
    float radius -> do
    void getCornerPath(com.google.android.material.shape.ShapePath,float,float,float) -> do
com.google.android.material.shape.ShapeAppearanceModel -> for.if.do.do.import.goto:
    com.google.android.material.shape.CornerTreatment topRightCorner -> if
    com.google.android.material.shape.CornerTreatment topLeftCorner -> do
    com.google.android.material.shape.EdgeTreatment bottomEdge -> goto
    com.google.android.material.shape.EdgeTreatment topEdge -> char
    com.google.android.material.shape.CornerTreatment bottomRightCorner -> for
    com.google.android.material.shape.CornerSize topRightCornerSize -> try
    com.google.android.material.shape.CornerSize bottomLeftCornerSize -> case
    com.google.android.material.shape.CornerSize bottomRightCornerSize -> byte
    com.google.android.material.shape.EdgeTreatment leftEdge -> long
    com.google.android.material.shape.CornerTreatment bottomLeftCorner -> int
    com.google.android.material.shape.CornerSize topLeftCornerSize -> new
    com.google.android.material.shape.EdgeTreatment rightEdge -> else
    com.google.android.material.shape.EdgeTreatment getRightEdge() -> byte
    com.google.android.material.shape.EdgeTreatment getTopEdge() -> case
    com.google.android.material.shape.CornerTreatment getTopLeftCorner() -> char
    com.google.android.material.shape.ShapeAppearanceModel$Builder builder(android.content.Context,int,int) -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder builder(android.content.Context,int,int,int) -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder builder(android.content.Context,int,int,com.google.android.material.shape.CornerSize) -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder builder(android.content.Context,android.util.AttributeSet,int,int) -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder builder(android.content.Context,android.util.AttributeSet,int,int,int) -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder builder(android.content.Context,android.util.AttributeSet,int,int,com.google.android.material.shape.CornerSize) -> do
    com.google.android.material.shape.EdgeTreatment getBottomEdge() -> do
    com.google.android.material.shape.CornerSize getCornerSize(android.content.res.TypedArray,int,com.google.android.material.shape.CornerSize) -> do
    boolean isRoundRect(android.graphics.RectF) -> do
    com.google.android.material.shape.ShapeAppearanceModel withCornerSize(float) -> do
    com.google.android.material.shape.ShapeAppearanceModel withTransformedCornerSizes(com.google.android.material.shape.ShapeAppearanceModel$CornerSizeUnaryOperator) -> do
    com.google.android.material.shape.CornerSize getTopLeftCornerSize() -> else
    com.google.android.material.shape.CornerSize getBottomLeftCornerSize() -> for
    com.google.android.material.shape.CornerTreatment getTopRightCorner() -> goto
    com.google.android.material.shape.CornerTreatment getBottomLeftCorner() -> if
    com.google.android.material.shape.CornerTreatment getBottomRightCorner() -> int
    com.google.android.material.shape.CornerSize getTopRightCornerSize() -> long
    com.google.android.material.shape.CornerSize getBottomRightCornerSize() -> new
    com.google.android.material.shape.ShapeAppearanceModel$Builder toBuilder() -> this
    com.google.android.material.shape.EdgeTreatment getLeftEdge() -> try
    com.google.android.material.shape.ShapeAppearanceModel$Builder builder() -> void
com.google.android.material.shape.ShapeAppearanceModel$1 -> for.if.do.do.import.goto$do:
com.google.android.material.shape.ShapeAppearanceModel$Builder -> for.if.do.do.import.goto$if:
    com.google.android.material.shape.CornerTreatment topRightCorner -> if
    com.google.android.material.shape.CornerTreatment topLeftCorner -> do
    com.google.android.material.shape.EdgeTreatment bottomEdge -> goto
    com.google.android.material.shape.EdgeTreatment topEdge -> char
    com.google.android.material.shape.CornerTreatment bottomRightCorner -> for
    com.google.android.material.shape.CornerSize topRightCornerSize -> try
    com.google.android.material.shape.CornerSize bottomLeftCornerSize -> case
    com.google.android.material.shape.CornerSize bottomRightCornerSize -> byte
    com.google.android.material.shape.EdgeTreatment leftEdge -> long
    com.google.android.material.shape.CornerTreatment bottomLeftCorner -> int
    com.google.android.material.shape.CornerSize topLeftCornerSize -> new
    com.google.android.material.shape.EdgeTreatment rightEdge -> else
    com.google.android.material.shape.CornerTreatment access$400(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> byte
    com.google.android.material.shape.CornerSize access$500(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> case
    com.google.android.material.shape.CornerSize access$600(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> char
    com.google.android.material.shape.CornerTreatment access$100(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> do
    com.google.android.material.shape.ShapeAppearanceModel build() -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder setAllCornerSizes(float) -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder setBottomLeftCorner(int,com.google.android.material.shape.CornerSize) -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder setBottomLeftCorner(com.google.android.material.shape.CornerTreatment) -> do
    com.google.android.material.shape.ShapeAppearanceModel$Builder setBottomLeftCornerSize(com.google.android.material.shape.CornerSize) -> do
    com.google.android.material.shape.CornerSize access$700(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> else
    com.google.android.material.shape.EdgeTreatment access$1100(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> for
    com.google.android.material.shape.ShapeAppearanceModel$Builder setBottomRightCornerSize(float) -> for
    com.google.android.material.shape.ShapeAppearanceModel$Builder setTopLeftCorner(int,com.google.android.material.shape.CornerSize) -> for
    com.google.android.material.shape.ShapeAppearanceModel$Builder setTopLeftCorner(com.google.android.material.shape.CornerTreatment) -> for
    com.google.android.material.shape.ShapeAppearanceModel$Builder setTopLeftCornerSize(com.google.android.material.shape.CornerSize) -> for
    com.google.android.material.shape.CornerSize access$800(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> goto
    com.google.android.material.shape.EdgeTreatment access$1000(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> if
    com.google.android.material.shape.ShapeAppearanceModel$Builder setBottomLeftCornerSize(float) -> if
    com.google.android.material.shape.ShapeAppearanceModel$Builder setBottomRightCorner(int,com.google.android.material.shape.CornerSize) -> if
    com.google.android.material.shape.ShapeAppearanceModel$Builder setBottomRightCorner(com.google.android.material.shape.CornerTreatment) -> if
    com.google.android.material.shape.ShapeAppearanceModel$Builder setBottomRightCornerSize(com.google.android.material.shape.CornerSize) -> if
    com.google.android.material.shape.EdgeTreatment access$1200(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> int
    com.google.android.material.shape.ShapeAppearanceModel$Builder setTopLeftCornerSize(float) -> int
    com.google.android.material.shape.ShapeAppearanceModel$Builder setTopRightCorner(int,com.google.android.material.shape.CornerSize) -> int
    com.google.android.material.shape.ShapeAppearanceModel$Builder setTopRightCorner(com.google.android.material.shape.CornerTreatment) -> int
    com.google.android.material.shape.ShapeAppearanceModel$Builder setTopRightCornerSize(com.google.android.material.shape.CornerSize) -> int
    com.google.android.material.shape.EdgeTreatment access$900(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> long
    com.google.android.material.shape.CornerTreatment access$200(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> new
    float compatCornerTreatmentSize(com.google.android.material.shape.CornerTreatment) -> new
    com.google.android.material.shape.ShapeAppearanceModel$Builder setTopRightCornerSize(float) -> new
    com.google.android.material.shape.CornerTreatment access$300(com.google.android.material.shape.ShapeAppearanceModel$Builder) -> try
com.google.android.material.shape.ShapeAppearanceModel$CornerSizeUnaryOperator -> for.if.do.do.import.goto$for:
    com.google.android.material.shape.CornerSize apply(com.google.android.material.shape.CornerSize) -> do
com.google.android.material.shape.ShapeAppearancePathProvider -> for.if.do.do.import.long:
    android.graphics.Matrix[] cornerTransforms -> if
    android.graphics.PointF pointF -> int
    float[] scratch -> try
    com.google.android.material.shape.ShapePath[] cornerPaths -> do
    android.graphics.Matrix[] edgeTransforms -> for
    float[] scratch2 -> byte
    com.google.android.material.shape.ShapePath shapePath -> new
    float angleOfEdge(int) -> do
    void appendCornerPath(com.google.android.material.shape.ShapeAppearancePathProvider$ShapeAppearancePathSpec,int) -> do
    void calculatePath(com.google.android.material.shape.ShapeAppearanceModel,float,android.graphics.RectF,android.graphics.Path) -> do
    void calculatePath(com.google.android.material.shape.ShapeAppearanceModel,float,android.graphics.RectF,com.google.android.material.shape.ShapeAppearancePathProvider$PathListener,android.graphics.Path) -> do
    void getCoordinatesOfCorner(int,android.graphics.RectF,android.graphics.PointF) -> do
    com.google.android.material.shape.CornerSize getCornerSizeForIndex(int,com.google.android.material.shape.ShapeAppearanceModel) -> do
    float getEdgeCenterForIndex(android.graphics.RectF,int) -> do
    com.google.android.material.shape.EdgeTreatment getEdgeTreatmentForIndex(int,com.google.android.material.shape.ShapeAppearanceModel) -> for
    void setCornerPathAndTransform(com.google.android.material.shape.ShapeAppearancePathProvider$ShapeAppearancePathSpec,int) -> for
    void appendEdgePath(com.google.android.material.shape.ShapeAppearancePathProvider$ShapeAppearancePathSpec,int) -> if
    com.google.android.material.shape.CornerTreatment getCornerTreatmentForIndex(int,com.google.android.material.shape.ShapeAppearanceModel) -> if
    void setEdgePathAndTransform(int) -> if
com.google.android.material.shape.ShapeAppearancePathProvider$PathListener -> for.if.do.do.import.long$do:
    void onCornerPathCreated(com.google.android.material.shape.ShapePath,android.graphics.Matrix,int) -> do
    void onEdgePathCreated(com.google.android.material.shape.ShapePath,android.graphics.Matrix,int) -> if
com.google.android.material.shape.ShapeAppearancePathProvider$ShapeAppearancePathSpec -> for.if.do.do.import.long$if:
    android.graphics.Path path -> if
    com.google.android.material.shape.ShapeAppearanceModel shapeAppearanceModel -> do
    android.graphics.RectF bounds -> for
    com.google.android.material.shape.ShapeAppearancePathProvider$PathListener pathListener -> int
    float interpolation -> new
com.google.android.material.shape.ShapePath -> for.if.do.do.import.this:
    float startX -> do
    float endX -> for
    java.util.List shadowCompatOperations -> case
    float endShadowAngle -> try
    float endY -> int
    java.util.List operations -> byte
    float startY -> if
    float currentShadowAngle -> new
    void setStartY(float) -> byte
    void addArc(float,float,float,float,float,float) -> do
    void addConnectingShadowIfNecessary(float) -> do
    void addShadowCompatOperation(com.google.android.material.shape.ShapePath$ShadowCompatOperation,float,float) -> do
    void applyToPath(android.graphics.Matrix,android.graphics.Path) -> do
    com.google.android.material.shape.ShapePath$ShadowCompatOperation createShadowCompatOperation(android.graphics.Matrix) -> do
    float getEndX() -> do
    void lineTo(float,float) -> do
    void reset(float,float,float,float) -> do
    float getStartX() -> for
    void setEndShadowAngle(float) -> for
    float getEndY() -> if
    void reset(float,float) -> if
    void setCurrentShadowAngle(float) -> if
    float getStartY() -> int
    void setEndX(float) -> int
    float getCurrentShadowAngle() -> new
    void setEndY(float) -> new
    float getEndShadowAngle() -> try
    void setStartX(float) -> try
com.google.android.material.shape.ShapePath$1 -> for.if.do.do.import.this$do:
    android.graphics.Matrix val$transform -> for
    java.util.List val$operations -> if
    void draw(android.graphics.Matrix,com.google.android.material.shadow.ShadowRenderer,int,android.graphics.Canvas) -> do
com.google.android.material.shape.ShapePath$ArcShadowOperation -> for.if.do.do.import.this$if:
    com.google.android.material.shape.ShapePath$PathArcOperation operation -> if
    void draw(android.graphics.Matrix,com.google.android.material.shadow.ShadowRenderer,int,android.graphics.Canvas) -> do
com.google.android.material.shape.ShapePath$LineShadowOperation -> for.if.do.do.import.this$for:
    float startX -> for
    com.google.android.material.shape.ShapePath$PathLineOperation operation -> if
    float startY -> int
    void draw(android.graphics.Matrix,com.google.android.material.shadow.ShadowRenderer,int,android.graphics.Canvas) -> do
    float getAngle() -> do
com.google.android.material.shape.ShapePath$PathArcOperation -> for.if.do.do.import.this$int:
    android.graphics.RectF rectF -> case
    float top -> for
    float startAngle -> try
    float sweepAngle -> byte
    float right -> int
    float left -> if
    float bottom -> new
    float access$1000(com.google.android.material.shape.ShapePath$PathArcOperation) -> do
    void access$600(com.google.android.material.shape.ShapePath$PathArcOperation,float) -> do
    void applyToPath(android.graphics.Matrix,android.graphics.Path) -> do
    float getBottom() -> do
    void setBottom(float) -> do
    float access$1200(com.google.android.material.shape.ShapePath$PathArcOperation) -> for
    float getRight() -> for
    void setRight(float) -> for
    float access$1100(com.google.android.material.shape.ShapePath$PathArcOperation) -> if
    void access$700(com.google.android.material.shape.ShapePath$PathArcOperation,float) -> if
    float getLeft() -> if
    void setLeft(float) -> if
    float access$1300(com.google.android.material.shape.ShapePath$PathArcOperation) -> int
    float getStartAngle() -> int
    void setStartAngle(float) -> int
    float access$800(com.google.android.material.shape.ShapePath$PathArcOperation) -> new
    float getSweepAngle() -> new
    void setSweepAngle(float) -> new
    float access$900(com.google.android.material.shape.ShapePath$PathArcOperation) -> try
    float getTop() -> try
    void setTop(float) -> try
com.google.android.material.shape.ShapePath$PathLineOperation -> for.if.do.do.import.this$new:
    float y -> for
    float x -> if
    float access$000(com.google.android.material.shape.ShapePath$PathLineOperation) -> do
    float access$002(com.google.android.material.shape.ShapePath$PathLineOperation,float) -> do
    void applyToPath(android.graphics.Matrix,android.graphics.Path) -> do
    float access$100(com.google.android.material.shape.ShapePath$PathLineOperation) -> if
    float access$102(com.google.android.material.shape.ShapePath$PathLineOperation,float) -> if
com.google.android.material.shape.ShapePath$PathOperation -> for.if.do.do.import.this$try:
    android.graphics.Matrix matrix -> do
    void applyToPath(android.graphics.Matrix,android.graphics.Path) -> do
com.google.android.material.shape.ShapePath$ShadowCompatOperation -> for.if.do.do.import.this$byte:
    android.graphics.Matrix IDENTITY_MATRIX -> do
    void draw(android.graphics.Matrix,com.google.android.material.shadow.ShadowRenderer,int,android.graphics.Canvas) -> do
    void draw(com.google.android.material.shadow.ShadowRenderer,int,android.graphics.Canvas) -> do
com.google.android.material.shape.Shapeable -> for.if.do.do.import.void:
com.google.android.material.snackbar.BaseTransientBottomBar -> com.google.android.material.snackbar.BaseTransientBottomBar:
    android.content.Context context -> if
    java.util.List callbacks -> break
    boolean USE_OFFSET_API -> float
    com.google.android.material.snackbar.BaseTransientBottomBar$Behavior behavior -> catch
    int extraBottomMarginGestureInset -> this
    com.google.android.material.snackbar.BaseTransientBottomBar$SnackbarBaseLayout view -> for
    java.lang.String TAG -> super
    int extraLeftMarginWindowInset -> goto
    int extraBottomMarginAnchorView -> void
    com.google.android.material.snackbar.ContentViewCallback contentViewCallback -> int
    int[] SNACKBAR_STYLE_ATTR -> short
    android.view.View anchorView -> byte
    int extraRightMarginWindowInset -> long
    int extraBottomMarginWindowInset -> else
    android.view.ViewGroup targetParent -> do
    int duration -> new
    android.view.accessibility.AccessibilityManager accessibilityManager -> class
    android.os.Handler handler -> final
    boolean gestureInsetBottomIgnored -> try
    java.lang.Runnable bottomMarginGestureInsetRunnable -> case
    com.google.android.material.snackbar.SnackbarManager$Callback managerCallback -> const
    android.graphics.Rect originalMargins -> char
    int calculateBottomMarginForAnchorView() -> break
    int access$300(com.google.android.material.snackbar.BaseTransientBottomBar) -> byte
    boolean hasSnackbarStyleAttr() -> byte
    void startSlideOutAnimation(int) -> byte
    void access$800(com.google.android.material.snackbar.BaseTransientBottomBar) -> case
    boolean isShownOrQueued() -> case
    android.graphics.drawable.Drawable createThemedBackground() -> catch
    void access$900(com.google.android.material.snackbar.BaseTransientBottomBar) -> char
    void onViewShown() -> char
    int getScreenHeight() -> class
    int getTranslationYBottom() -> const
    android.content.Context access$000(com.google.android.material.snackbar.BaseTransientBottomBar) -> do
    int access$302(com.google.android.material.snackbar.BaseTransientBottomBar,int) -> do
    void animateViewIn() -> do
    void dispatchDismiss(int) -> do
    android.animation.ValueAnimator getAlphaAnimator(float[]) -> do
    void setUpBehavior(androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams) -> do
    void updateMargins() -> double
    boolean shouldAnimate() -> else
    int getViewAbsoluteBottom() -> final
    boolean isSwipeDismissable() -> float
    void access$1100(com.google.android.material.snackbar.BaseTransientBottomBar) -> for
    int access$602(com.google.android.material.snackbar.BaseTransientBottomBar,int) -> for
    int getDuration() -> for
    void onViewHidden(int) -> for
    void show() -> goto
    int access$100(com.google.android.material.snackbar.BaseTransientBottomBar) -> if
    int access$502(com.google.android.material.snackbar.BaseTransientBottomBar,int) -> if
    void dismiss() -> if
    android.animation.ValueAnimator getScaleAnimator(float[]) -> if
    void hideView(int) -> if
    void access$1200(com.google.android.material.snackbar.BaseTransientBottomBar) -> int
    int access$702(com.google.android.material.snackbar.BaseTransientBottomBar,int) -> int
    com.google.android.material.behavior.SwipeDismissBehavior getNewBehavior() -> int
    com.google.android.material.snackbar.BaseTransientBottomBar setDuration(int) -> int
    void showView() -> long
    com.google.android.material.snackbar.ContentViewCallback access$1300(com.google.android.material.snackbar.BaseTransientBottomBar) -> new
    void animateViewOut(int) -> new
    int getSnackbarBaseLayoutResId() -> new
    boolean shouldUpdateGestureInset() -> short
    void showViewImpl() -> super
    boolean access$1400() -> this
    void startFadeInAnimation() -> throw
    int access$200(com.google.android.material.snackbar.BaseTransientBottomBar) -> try
    android.view.View getView() -> try
    void startFadeOutAnimation(int) -> try
    java.lang.String access$400() -> void
    void startSlideInAnimation() -> while
com.google.android.material.snackbar.BaseTransientBottomBar$1 -> com.google.android.material.snackbar.BaseTransientBottomBar$char:
com.google.android.material.snackbar.BaseTransientBottomBar$10 -> com.google.android.material.snackbar.BaseTransientBottomBar$do:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
com.google.android.material.snackbar.BaseTransientBottomBar$11 -> com.google.android.material.snackbar.BaseTransientBottomBar$if:
    int val$event -> do
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> if
com.google.android.material.snackbar.BaseTransientBottomBar$12 -> com.google.android.material.snackbar.BaseTransientBottomBar$for:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
com.google.android.material.snackbar.BaseTransientBottomBar$13 -> com.google.android.material.snackbar.BaseTransientBottomBar$int:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
com.google.android.material.snackbar.BaseTransientBottomBar$14 -> com.google.android.material.snackbar.BaseTransientBottomBar$new:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
com.google.android.material.snackbar.BaseTransientBottomBar$15 -> com.google.android.material.snackbar.BaseTransientBottomBar$try:
    int val$translationYBottom -> if
    int previousAnimatedIntValue -> do
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> for
com.google.android.material.snackbar.BaseTransientBottomBar$16 -> com.google.android.material.snackbar.BaseTransientBottomBar$byte:
    int val$event -> do
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> if
com.google.android.material.snackbar.BaseTransientBottomBar$17 -> com.google.android.material.snackbar.BaseTransientBottomBar$case:
    int previousAnimatedIntValue -> do
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> if
com.google.android.material.snackbar.BaseTransientBottomBar$2 -> com.google.android.material.snackbar.BaseTransientBottomBar$else:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> if
com.google.android.material.snackbar.BaseTransientBottomBar$3 -> com.google.android.material.snackbar.BaseTransientBottomBar$goto:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
    androidx.core.view.WindowInsetsCompat onApplyWindowInsets(android.view.View,androidx.core.view.WindowInsetsCompat) -> do
com.google.android.material.snackbar.BaseTransientBottomBar$4 -> com.google.android.material.snackbar.BaseTransientBottomBar$long:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> int
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> do
com.google.android.material.snackbar.BaseTransientBottomBar$5 -> com.google.android.material.snackbar.BaseTransientBottomBar$this:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
    void dismiss(int) -> do
    void show() -> if
com.google.android.material.snackbar.BaseTransientBottomBar$6 -> com.google.android.material.snackbar.BaseTransientBottomBar$void:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
com.google.android.material.snackbar.BaseTransientBottomBar$6$1 -> com.google.android.material.snackbar.BaseTransientBottomBar$void$do:
    com.google.android.material.snackbar.BaseTransientBottomBar$6 this$1 -> if
com.google.android.material.snackbar.BaseTransientBottomBar$7 -> com.google.android.material.snackbar.BaseTransientBottomBar$break:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
    void onLayoutChange(android.view.View,int,int,int,int) -> do
com.google.android.material.snackbar.BaseTransientBottomBar$8 -> com.google.android.material.snackbar.BaseTransientBottomBar$catch:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> do
    void onDismiss(android.view.View) -> do
    void onDragStateChanged(int) -> do
com.google.android.material.snackbar.BaseTransientBottomBar$9 -> com.google.android.material.snackbar.BaseTransientBottomBar$class:
    com.google.android.material.snackbar.BaseTransientBottomBar this$0 -> if
com.google.android.material.snackbar.BaseTransientBottomBar$BaseCallback -> com.google.android.material.snackbar.BaseTransientBottomBar$const:
    void onDismissed(java.lang.Object,int) -> do
    void onShown(java.lang.Object) -> do
com.google.android.material.snackbar.BaseTransientBottomBar$Behavior -> com.google.android.material.snackbar.BaseTransientBottomBar$Behavior:
    com.google.android.material.snackbar.BaseTransientBottomBar$BehaviorDelegate delegate -> goto
    void access$1000(com.google.android.material.snackbar.BaseTransientBottomBar$Behavior,com.google.android.material.snackbar.BaseTransientBottomBar) -> do
    boolean canSwipeDismissView(android.view.View) -> do
    boolean onInterceptTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> do
    void setBaseTransientBottomBar(com.google.android.material.snackbar.BaseTransientBottomBar) -> do
com.google.android.material.snackbar.BaseTransientBottomBar$BehaviorDelegate -> com.google.android.material.snackbar.BaseTransientBottomBar$final:
    com.google.android.material.snackbar.SnackbarManager$Callback managerCallback -> do
    boolean canSwipeDismissView(android.view.View) -> do
    void onInterceptTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> do
    void setBaseTransientBottomBar(com.google.android.material.snackbar.BaseTransientBottomBar) -> do
com.google.android.material.snackbar.BaseTransientBottomBar$OnAttachStateChangeListener -> com.google.android.material.snackbar.BaseTransientBottomBar$float:
com.google.android.material.snackbar.BaseTransientBottomBar$OnLayoutChangeListener -> com.google.android.material.snackbar.BaseTransientBottomBar$short:
    void onLayoutChange(android.view.View,int,int,int,int) -> do
com.google.android.material.snackbar.BaseTransientBottomBar$SnackbarBaseLayout -> com.google.android.material.snackbar.BaseTransientBottomBar$super:
    int animationMode -> int
    com.google.android.material.snackbar.BaseTransientBottomBar$OnLayoutChangeListener onLayoutChangeListener -> if
    float actionTextColorAlpha -> try
    android.view.View$OnTouchListener consumeAllTouchListener -> byte
    com.google.android.material.snackbar.BaseTransientBottomBar$OnAttachStateChangeListener onAttachStateChangeListener -> for
    float backgroundOverlayColorAlpha -> new
com.google.android.material.snackbar.BaseTransientBottomBar$SnackbarBaseLayout$1 -> com.google.android.material.snackbar.BaseTransientBottomBar$super$do:
com.google.android.material.snackbar.ContentViewCallback -> com.google.android.material.snackbar.do:
    void animateContentOut(int,int) -> do
    void animateContentIn(int,int) -> if
com.google.android.material.snackbar.Snackbar -> com.google.android.material.snackbar.Snackbar:
    boolean hasAction -> while
    int[] SNACKBAR_BUTTON_STYLE_ATTR -> double
    android.view.accessibility.AccessibilityManager accessibilityManager -> throw
    android.view.ViewGroup findSuitableParent(android.view.View) -> do
    boolean hasSnackbarButtonStyleAttr(android.content.Context) -> do
    com.google.android.material.snackbar.Snackbar make(android.view.View,java.lang.CharSequence,int) -> do
    com.google.android.material.snackbar.Snackbar setText(java.lang.CharSequence) -> do
    int getDuration() -> for
    void show() -> goto
    void dismiss() -> if
com.google.android.material.snackbar.SnackbarContentLayout -> com.google.android.material.snackbar.SnackbarContentLayout:
    android.widget.Button actionView -> for
    int maxWidth -> int
    int maxInlineActionWidth -> new
    android.widget.TextView messageView -> if
    void animateContentOut(int,int) -> do
    void updateActionTextColorAlphaIfNeeded(float) -> do
    void updateTopBottomPadding(android.view.View,int,int) -> do
    boolean updateViewsWithinLayout(int,int,int) -> do
    void animateContentIn(int,int) -> if
com.google.android.material.snackbar.SnackbarManager -> com.google.android.material.snackbar.if:
    java.lang.Object lock -> do
    com.google.android.material.snackbar.SnackbarManager$SnackbarRecord currentSnackbar -> for
    android.os.Handler handler -> if
    com.google.android.material.snackbar.SnackbarManager snackbarManager -> new
    com.google.android.material.snackbar.SnackbarManager$SnackbarRecord nextSnackbar -> int
    boolean isNextSnackbarLocked(com.google.android.material.snackbar.SnackbarManager$Callback) -> byte
    boolean cancelSnackbarLocked(com.google.android.material.snackbar.SnackbarManager$SnackbarRecord,int) -> do
    void dismiss(com.google.android.material.snackbar.SnackbarManager$Callback,int) -> do
    com.google.android.material.snackbar.SnackbarManager getInstance() -> do
    void handleTimeout(com.google.android.material.snackbar.SnackbarManager$SnackbarRecord) -> do
    boolean isCurrentOrNext(com.google.android.material.snackbar.SnackbarManager$Callback) -> do
    void show(int,com.google.android.material.snackbar.SnackbarManager$Callback) -> do
    void onShown(com.google.android.material.snackbar.SnackbarManager$Callback) -> for
    void onDismissed(com.google.android.material.snackbar.SnackbarManager$Callback) -> if
    void scheduleTimeoutLocked(com.google.android.material.snackbar.SnackbarManager$SnackbarRecord) -> if
    void showNextSnackbarLocked() -> if
    void pauseTimeout(com.google.android.material.snackbar.SnackbarManager$Callback) -> int
    void restoreTimeoutIfPaused(com.google.android.material.snackbar.SnackbarManager$Callback) -> new
    boolean isCurrentSnackbarLocked(com.google.android.material.snackbar.SnackbarManager$Callback) -> try
com.google.android.material.snackbar.SnackbarManager$1 -> com.google.android.material.snackbar.if$do:
    com.google.android.material.snackbar.SnackbarManager this$0 -> do
com.google.android.material.snackbar.SnackbarManager$Callback -> com.google.android.material.snackbar.if$if:
    void dismiss(int) -> do
    void show() -> if
com.google.android.material.snackbar.SnackbarManager$SnackbarRecord -> com.google.android.material.snackbar.if$for:
    java.lang.ref.WeakReference callback -> do
    int duration -> if
    boolean paused -> for
    boolean isSnackbar(com.google.android.material.snackbar.SnackbarManager$Callback) -> do
com.google.android.material.stateful.ExtendableSavedState -> for.if.do.do.native.do:
    androidx.collection.SimpleArrayMap extendableStates -> int
com.google.android.material.stateful.ExtendableSavedState$1 -> for.if.do.do.native.do$do:
com.google.android.material.textfield.ClearTextEndIconDelegate -> com.google.android.material.textfield.do:
    android.animation.AnimatorSet iconInAnim -> try
    com.google.android.material.textfield.TextInputLayout$OnEditTextAttachedListener clearTextOnEditTextAttachedListener -> new
    android.animation.ValueAnimator iconOutAnim -> byte
    android.text.TextWatcher clearTextEndIconTextWatcher -> int
    boolean access$000(android.text.Editable) -> do
    android.animation.ValueAnimator access$100(com.google.android.material.textfield.ClearTextEndIconDelegate) -> do
    android.animation.ValueAnimator getAlphaAnimator(float[]) -> do
    void initialize() -> do
    android.text.TextWatcher access$300(com.google.android.material.textfield.ClearTextEndIconDelegate) -> for
    android.animation.ValueAnimator getScaleAnimator() -> for
    android.animation.AnimatorSet access$200(com.google.android.material.textfield.ClearTextEndIconDelegate) -> if
    boolean hasText(android.text.Editable) -> if
    void initAnimators() -> int
com.google.android.material.textfield.ClearTextEndIconDelegate$1 -> com.google.android.material.textfield.do$do:
    com.google.android.material.textfield.ClearTextEndIconDelegate this$0 -> if
com.google.android.material.textfield.ClearTextEndIconDelegate$2 -> com.google.android.material.textfield.do$if:
    com.google.android.material.textfield.ClearTextEndIconDelegate this$0 -> do
    void onEditTextAttached(com.google.android.material.textfield.TextInputLayout) -> do
com.google.android.material.textfield.ClearTextEndIconDelegate$3 -> com.google.android.material.textfield.do$for:
    com.google.android.material.textfield.ClearTextEndIconDelegate this$0 -> if
com.google.android.material.textfield.ClearTextEndIconDelegate$4 -> com.google.android.material.textfield.do$int:
    com.google.android.material.textfield.ClearTextEndIconDelegate this$0 -> do
com.google.android.material.textfield.ClearTextEndIconDelegate$5 -> com.google.android.material.textfield.do$new:
    com.google.android.material.textfield.ClearTextEndIconDelegate this$0 -> do
com.google.android.material.textfield.ClearTextEndIconDelegate$6 -> com.google.android.material.textfield.do$try:
    com.google.android.material.textfield.ClearTextEndIconDelegate this$0 -> do
com.google.android.material.textfield.ClearTextEndIconDelegate$7 -> com.google.android.material.textfield.do$byte:
    com.google.android.material.textfield.ClearTextEndIconDelegate this$0 -> do
com.google.android.material.textfield.CustomEndIconDelegate -> com.google.android.material.textfield.if:
    void initialize() -> do
com.google.android.material.textfield.CutoutDrawable -> com.google.android.material.textfield.for:
    int savedLayer -> import
    android.graphics.Paint cutoutPaint -> while
    android.graphics.RectF cutoutBounds -> double
    void saveCanvasLayer(android.graphics.Canvas) -> byte
    void setCutout(float,float,float,float) -> do
    void setCutout(android.graphics.RectF) -> do
    boolean useHardwareLayer(android.graphics.drawable.Drawable$Callback) -> do
    void postDraw(android.graphics.Canvas) -> new
    boolean hasCutout() -> return
    void removeCutout() -> static
    void setPaintStyles() -> switch
    void preDraw(android.graphics.Canvas) -> try
com.google.android.material.textfield.DropdownMenuEndIconDelegate -> com.google.android.material.textfield.int:
    long dropdownPopupActivatedAt -> char
    android.graphics.drawable.StateListDrawable filledPopupBackground -> else
    android.animation.ValueAnimator fadeOutAnim -> this
    boolean isEndIconChecked -> case
    boolean IS_LOLLIPOP -> break
    android.animation.ValueAnimator fadeInAnim -> void
    com.google.android.material.textfield.TextInputLayout$OnEditTextAttachedListener dropdownMenuOnEditTextAttachedListener -> try
    boolean dropdownPopupDirty -> byte
    com.google.android.material.shape.MaterialShapeDrawable outlinedPopupBackground -> goto
    android.view.accessibility.AccessibilityManager accessibilityManager -> long
    android.text.TextWatcher exposedDropdownEndIconTextWatcher -> int
    com.google.android.material.textfield.TextInputLayout$AccessibilityDelegate accessibilityDelegate -> new
    android.widget.AutoCompleteTextView access$000(com.google.android.material.textfield.DropdownMenuEndIconDelegate,android.widget.EditText) -> do
    void access$100(com.google.android.material.textfield.DropdownMenuEndIconDelegate,boolean) -> do
    boolean access$1000(com.google.android.material.textfield.DropdownMenuEndIconDelegate) -> do
    long access$1102(com.google.android.material.textfield.DropdownMenuEndIconDelegate,long) -> do
    void access$400(com.google.android.material.textfield.DropdownMenuEndIconDelegate,android.widget.AutoCompleteTextView) -> do
    void addRippleEffect(android.widget.AutoCompleteTextView) -> do
    void addRippleEffectOnFilledLayout(android.widget.AutoCompleteTextView,int,int[][],com.google.android.material.shape.MaterialShapeDrawable) -> do
    android.widget.AutoCompleteTextView castAutoCompleteTextViewOrThrow(android.widget.EditText) -> do
    android.animation.ValueAnimator getAlphaAnimator(int,float[]) -> do
    com.google.android.material.shape.MaterialShapeDrawable getPopUpMaterialShapeDrawable(float,float,float,int) -> do
    void initialize() -> do
    boolean isBoxBackgroundModeSupported(int) -> do
    void setEndIconChecked(boolean) -> do
    android.animation.ValueAnimator access$1300(com.google.android.material.textfield.DropdownMenuEndIconDelegate) -> for
    void access$600(com.google.android.material.textfield.DropdownMenuEndIconDelegate,android.widget.AutoCompleteTextView) -> for
    void initAnimators() -> for
    void setUpDropdownShowHideBehavior(android.widget.AutoCompleteTextView) -> for
    boolean access$1200(com.google.android.material.textfield.DropdownMenuEndIconDelegate) -> if
    boolean access$202(com.google.android.material.textfield.DropdownMenuEndIconDelegate,boolean) -> if
    void access$500(com.google.android.material.textfield.DropdownMenuEndIconDelegate,android.widget.AutoCompleteTextView) -> if
    void addRippleEffectOnOutlinedLayout(android.widget.AutoCompleteTextView,int,int[][],com.google.android.material.shape.MaterialShapeDrawable) -> if
    void setPopupBackground(android.widget.AutoCompleteTextView) -> if
    boolean shouldTintIconOnError() -> if
    android.view.accessibility.AccessibilityManager access$300(com.google.android.material.textfield.DropdownMenuEndIconDelegate) -> int
    void access$700(com.google.android.material.textfield.DropdownMenuEndIconDelegate,android.widget.AutoCompleteTextView) -> int
    boolean isDropdownPopupActive() -> int
    void showHideDropdown(android.widget.AutoCompleteTextView) -> int
    android.text.TextWatcher access$800(com.google.android.material.textfield.DropdownMenuEndIconDelegate) -> new
    com.google.android.material.textfield.TextInputLayout$AccessibilityDelegate access$900(com.google.android.material.textfield.DropdownMenuEndIconDelegate) -> try
com.google.android.material.textfield.DropdownMenuEndIconDelegate$1 -> com.google.android.material.textfield.int$do:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> if
com.google.android.material.textfield.DropdownMenuEndIconDelegate$1$1 -> com.google.android.material.textfield.int$do$do:
    android.widget.AutoCompleteTextView val$editText -> if
    com.google.android.material.textfield.DropdownMenuEndIconDelegate$1 this$1 -> for
com.google.android.material.textfield.DropdownMenuEndIconDelegate$2 -> com.google.android.material.textfield.int$if:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> new
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> for
com.google.android.material.textfield.DropdownMenuEndIconDelegate$3 -> com.google.android.material.textfield.int$for:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> do
    void onEditTextAttached(com.google.android.material.textfield.TextInputLayout) -> do
com.google.android.material.textfield.DropdownMenuEndIconDelegate$4 -> com.google.android.material.textfield.int$int:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> if
com.google.android.material.textfield.DropdownMenuEndIconDelegate$5 -> com.google.android.material.textfield.int$new:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> for
    android.widget.AutoCompleteTextView val$editText -> if
com.google.android.material.textfield.DropdownMenuEndIconDelegate$6 -> com.google.android.material.textfield.int$try:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> if
com.google.android.material.textfield.DropdownMenuEndIconDelegate$7 -> com.google.android.material.textfield.int$byte:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> do
com.google.android.material.textfield.DropdownMenuEndIconDelegate$8 -> com.google.android.material.textfield.int$case:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> do
com.google.android.material.textfield.DropdownMenuEndIconDelegate$9 -> com.google.android.material.textfield.int$char:
    com.google.android.material.textfield.DropdownMenuEndIconDelegate this$0 -> do
com.google.android.material.textfield.EndIconDelegate -> com.google.android.material.textfield.new:
    android.content.Context context -> if
    com.google.android.material.internal.CheckableImageButton endIconView -> for
    com.google.android.material.textfield.TextInputLayout textInputLayout -> do
    void initialize() -> do
    boolean isBoxBackgroundModeSupported(int) -> do
    boolean shouldTintIconOnError() -> if
com.google.android.material.textfield.IndicatorViewController -> com.google.android.material.textfield.try:
    android.content.res.ColorStateList helperTextViewTextColor -> float
    android.content.res.ColorStateList errorViewTextColor -> break
    java.lang.CharSequence errorText -> goto
    com.google.android.material.textfield.TextInputLayout textInputView -> if
    android.content.Context context -> do
    int captionViewsAdded -> try
    boolean errorEnabled -> long
    int errorTextAppearance -> void
    android.animation.Animator captionAnimator -> byte
    int indicatorsAdded -> int
    int helperTextTextAppearance -> final
    int captionToShow -> else
    android.widget.TextView helperTextView -> const
    android.widget.LinearLayout indicatorArea -> for
    android.graphics.Typeface typeface -> short
    boolean helperTextEnabled -> class
    android.widget.FrameLayout captionArea -> new
    int captionDisplayed -> char
    java.lang.CharSequence helperText -> catch
    float captionTranslationYPx -> case
    android.widget.TextView errorView -> this
    java.lang.CharSequence getHelperText() -> byte
    int getHelperTextViewCurrentTextColor() -> case
    void hideError() -> char
    int access$002(com.google.android.material.textfield.IndicatorViewController,int) -> do
    android.animation.Animator access$102(com.google.android.material.textfield.IndicatorViewController,android.animation.Animator) -> do
    android.widget.TextView access$200(com.google.android.material.textfield.IndicatorViewController) -> do
    void addIndicator(android.widget.TextView,int) -> do
    void adjustIndicatorPadding() -> do
    void createCaptionAnimators(java.util.List,boolean,android.widget.TextView,int,int,int) -> do
    android.animation.ObjectAnimator createCaptionOpacityAnimator(android.widget.TextView,boolean) -> do
    android.animation.ObjectAnimator createCaptionTranslationYAnimator(android.widget.TextView) -> do
    boolean isCaptionView(int) -> do
    void setCaptionViewVisibilities(int,int) -> do
    void setErrorEnabled(boolean) -> do
    void setErrorViewTextColor(android.content.res.ColorStateList) -> do
    void setTextViewTypeface(android.widget.TextView,android.graphics.Typeface) -> do
    void setTypefaces(android.graphics.Typeface) -> do
    void setViewGroupGoneIfEmpty(android.view.ViewGroup,int) -> do
    boolean shouldAnimateCaptionView(android.widget.TextView,java.lang.CharSequence) -> do
    void showError(java.lang.CharSequence) -> do
    void updateCaptionViewsVisibility(int,int,boolean) -> do
    void hideHelperText() -> else
    boolean errorShouldBeShown() -> for
    void setHelperTextAppearance(int) -> for
    boolean isErrorEnabled() -> goto
    void cancelCaptionAnimator() -> if
    void removeIndicator(android.widget.TextView,int) -> if
    void setErrorTextAppearance(int) -> if
    void setHelperTextEnabled(boolean) -> if
    void setHelperTextViewTextColor(android.content.res.ColorStateList) -> if
    void showHelper(java.lang.CharSequence) -> if
    android.widget.TextView getCaptionViewFromDisplayState(int) -> int
    java.lang.CharSequence getErrorText() -> int
    boolean isHelperTextEnabled() -> long
    int getErrorViewCurrentTextColor() -> new
    boolean isCaptionStateError(int) -> new
    boolean canAdjustIndicatorPadding() -> this
    android.content.res.ColorStateList getErrorViewTextColors() -> try
com.google.android.material.textfield.IndicatorViewController$1 -> com.google.android.material.textfield.try$do:
    android.widget.TextView val$captionViewToShow -> int
    int val$captionToShow -> do
    int val$captionToHide -> for
    com.google.android.material.textfield.IndicatorViewController this$0 -> new
    android.widget.TextView val$captionViewToHide -> if
com.google.android.material.textfield.NoEndIconDelegate -> com.google.android.material.textfield.byte:
    void initialize() -> do
com.google.android.material.textfield.PasswordToggleEndIconDelegate -> com.google.android.material.textfield.case:
    com.google.android.material.textfield.TextInputLayout$OnEndIconChangedListener onEndIconChangedListener -> try
    com.google.android.material.textfield.TextInputLayout$OnEditTextAttachedListener onEditTextAttachedListener -> new
    android.text.TextWatcher textWatcher -> int
    boolean access$000(com.google.android.material.textfield.PasswordToggleEndIconDelegate) -> do
    void initialize() -> do
    boolean hasPasswordTransformation() -> for
    android.text.TextWatcher access$100(com.google.android.material.textfield.PasswordToggleEndIconDelegate) -> if
com.google.android.material.textfield.PasswordToggleEndIconDelegate$1 -> com.google.android.material.textfield.case$do:
    com.google.android.material.textfield.PasswordToggleEndIconDelegate this$0 -> if
com.google.android.material.textfield.PasswordToggleEndIconDelegate$2 -> com.google.android.material.textfield.case$if:
    com.google.android.material.textfield.PasswordToggleEndIconDelegate this$0 -> do
    void onEditTextAttached(com.google.android.material.textfield.TextInputLayout) -> do
com.google.android.material.textfield.PasswordToggleEndIconDelegate$3 -> com.google.android.material.textfield.case$for:
    void onEndIconChanged(com.google.android.material.textfield.TextInputLayout,int) -> do
com.google.android.material.textfield.PasswordToggleEndIconDelegate$4 -> com.google.android.material.textfield.case$int:
    com.google.android.material.textfield.PasswordToggleEndIconDelegate this$0 -> if
com.google.android.material.textfield.TextInputLayout -> com.google.android.material.textfield.TextInputLayout:
    android.content.res.ColorStateList counterTextColor -> this
    int hoveredFilledBackgroundColor -> ˏ
    boolean hintEnabled -> break
    int defaultFilledBackgroundColor -> ˋ
    java.lang.CharSequence originalHint -> new
    android.widget.FrameLayout inputFrame -> if
    android.view.View$OnLongClickListener startIconOnLongClickListener -> abstract
    int counterOverflowTextAppearance -> goto
    android.graphics.drawable.Drawable startIconDummyDrawable -> private
    boolean hasEndIconTintList -> implements
    android.graphics.RectF tmpRectF -> switch
    android.util.SparseArray endIconDelegates -> volatile
    android.content.res.ColorStateList endIconTintList -> transient
    android.content.res.ColorStateList focusedTextColor -> ˆ
    java.lang.CharSequence hint -> catch
    android.widget.EditText editText -> int
    int counterMaxLength -> case
    int DEF_STYLE_RES -> ᵔ
    int boxStrokeWidthPx -> while
    android.view.View$OnLongClickListener endIconOnLongClickListener -> ʾ
    int boxStrokeWidthFocusedPx -> import
    int defaultStrokeColor -> ˈ
    android.graphics.drawable.Drawable endIconDummyDrawable -> ʻ
    android.content.res.ColorStateList counterOverflowTextColor -> void
    int boxCollapsedPaddingTopPx -> throw
    android.graphics.PorterDuff$Mode startIconTintMode -> finally
    android.graphics.Rect tmpBoundsRect -> static
    int boxBackgroundMode -> super
    int boxStrokeColor -> native
    android.content.res.ColorStateList defaultHintTextColor -> ʿ
    boolean hintExpanded -> י
    android.animation.ValueAnimator animator -> ᐧ
    boolean hasStartIconTintMode -> package
    int disabledColor -> ˑ
    boolean restoringSavedState -> ᵎ
    int boxStrokeWidthDefaultPx -> double
    int hoveredStrokeColor -> ˉ
    android.graphics.drawable.Drawable originalEditTextEndDrawable -> ʼ
    boolean inDrawableStateChanged -> ᴵ
    android.graphics.Typeface typeface -> throws
    com.google.android.material.internal.CheckableImageButton endIconView -> interface
    com.google.android.material.internal.CheckableImageButton startIconView -> boolean
    int counterTextAppearance -> long
    android.widget.FrameLayout endIconFrame -> for
    int endIconMode -> strictfp
    boolean counterEnabled -> byte
    boolean isProvidingHint -> class
    android.graphics.Rect tmpRect -> return
    com.google.android.material.shape.ShapeAppearanceModel shapeAppearanceModel -> float
    int boxBackgroundColor -> public
    int boxLabelCutoutPaddingPx -> short
    int disabledFilledBackgroundColor -> ˎ
    boolean hasEndIconTintMode -> synchronized
    int focusedStrokeColor -> ˊ
    android.content.res.ColorStateList startIconTintList -> default
    boolean hintAnimationEnabled -> ٴ
    com.google.android.material.internal.CheckableImageButton errorIconView -> ʽ
    com.google.android.material.shape.MaterialShapeDrawable boxBackground -> const
    boolean counterOverflowed -> char
    java.util.LinkedHashSet editTextAttachedListeners -> continue
    android.widget.TextView counterView -> else
    java.util.LinkedHashSet endIconChangedListeners -> protected
    com.google.android.material.shape.MaterialShapeDrawable boxUnderline -> final
    android.graphics.PorterDuff$Mode endIconTintMode -> instanceof
    boolean hasStartIconTintList -> extends
    com.google.android.material.textfield.IndicatorViewController indicatorViewController -> try
    com.google.android.material.internal.CollapsingTextHelper collapsingTextHelper -> ـ
    boolean canDrawStroke() -> break
    void applyBoxAttributes() -> byte
    void applyBoxUnderlineAttributes() -> case
    void closeCutout() -> catch
    void applyEndIconTint() -> char
    boolean cutoutEnabled() -> class
    void dispatchOnEditTextAttached() -> const
    boolean access$000(com.google.android.material.textfield.TextInputLayout) -> do
    void addOnEditTextAttachedListener(com.google.android.material.textfield.TextInputLayout$OnEditTextAttachedListener) -> do
    void addOnEndIconChangedListener(com.google.android.material.textfield.TextInputLayout$OnEndIconChangedListener) -> do
    void animateToExpansionFraction(float) -> do
    void applyCutoutPadding(android.graphics.RectF) -> do
    void applyIconTint(com.google.android.material.internal.CheckableImageButton,boolean,android.content.res.ColorStateList,boolean,android.graphics.PorterDuff$Mode) -> do
    android.graphics.Rect calculateCollapsedTextBounds(android.graphics.Rect) -> do
    int calculateExpandedLabelBottom(android.graphics.Rect,android.graphics.Rect,float) -> do
    int calculateExpandedLabelTop(android.graphics.Rect,float) -> do
    void drawBoxUnderline(android.graphics.Canvas) -> do
    boolean isEndIconVisible() -> do
    void recursiveSetEnabled(android.view.ViewGroup,boolean) -> do
    void setIconClickable(com.google.android.material.internal.CheckableImageButton,android.view.View$OnLongClickListener) -> do
    void setIconOnClickListener(com.google.android.material.internal.CheckableImageButton,android.view.View$OnClickListener,android.view.View$OnLongClickListener) -> do
    void setTextAppearanceCompatWithErrorFallback(android.widget.TextView,int) -> do
    void updateCounter(int) -> do
    void updateCounterContentDescription(android.content.Context,android.widget.TextView,int,int,boolean) -> do
    void updateLabelState(boolean) -> do
    void updateLabelState(boolean,boolean) -> do
    boolean shouldUseEditTextBackgroundForBoxBackground() -> double
    void applyStartIconTint() -> else
    boolean hasEndIcon() -> final
    boolean hasStartIcon() -> float
    void expandHint(boolean) -> for
    boolean isProvidingHint() -> for
    void updateBoxUnderlineBounds(android.graphics.Rect) -> for
    void assignBoxBackgroundByMode() -> goto
    com.google.android.material.internal.CheckableImageButton access$100(com.google.android.material.textfield.TextInputLayout) -> if
    android.graphics.Rect calculateExpandedTextBounds(android.graphics.Rect) -> if
    void collapseHint(boolean) -> if
    void dispatchOnEndIconChanged(int) -> if
    void drawHint(android.graphics.Canvas) -> if
    boolean isHelperTextEnabled() -> if
    void setIconOnLongClickListener(com.google.android.material.internal.CheckableImageButton,android.view.View$OnLongClickListener) -> if
    void updateCounter() -> import
    boolean isStartIconVisible() -> int
    void tintEndIconOnError(boolean) -> int
    int calculateBoxBackgroundColor() -> long
    void updateCounterTextAppearanceAndColor() -> native
    void updateEditTextBackground() -> new
    boolean updateEditTextHeightBasedOnIcon() -> public
    boolean updateIconDummyDrawables() -> return
    boolean isSingleLineFilledTextField() -> short
    void updateInputLayoutMargins() -> static
    void onApplyBoxBackgroundMode() -> super
    int calculateLabelMarginTop() -> this
    void openCutout() -> throw
    void updateTextInputBoxState() -> try
    boolean canDrawOutlineStroke() -> void
    void setEditTextBoxBackground() -> while
com.google.android.material.textfield.TextInputLayout$1 -> com.google.android.material.textfield.TextInputLayout$do:
    com.google.android.material.textfield.TextInputLayout this$0 -> if
com.google.android.material.textfield.TextInputLayout$2 -> com.google.android.material.textfield.TextInputLayout$if:
    com.google.android.material.textfield.TextInputLayout this$0 -> if
com.google.android.material.textfield.TextInputLayout$3 -> com.google.android.material.textfield.TextInputLayout$for:
    com.google.android.material.textfield.TextInputLayout this$0 -> if
com.google.android.material.textfield.TextInputLayout$4 -> com.google.android.material.textfield.TextInputLayout$int:
    com.google.android.material.textfield.TextInputLayout this$0 -> do
com.google.android.material.textfield.TextInputLayout$AccessibilityDelegate -> com.google.android.material.textfield.TextInputLayout$new:
    com.google.android.material.textfield.TextInputLayout layout -> int
    void onInitializeAccessibilityNodeInfo(android.view.View,androidx.core.view.accessibility.AccessibilityNodeInfoCompat) -> do
com.google.android.material.textfield.TextInputLayout$OnEditTextAttachedListener -> com.google.android.material.textfield.TextInputLayout$try:
    void onEditTextAttached(com.google.android.material.textfield.TextInputLayout) -> do
com.google.android.material.textfield.TextInputLayout$OnEndIconChangedListener -> com.google.android.material.textfield.TextInputLayout$byte:
    void onEndIconChanged(com.google.android.material.textfield.TextInputLayout,int) -> do
com.google.android.material.textfield.TextInputLayout$SavedState -> com.google.android.material.textfield.TextInputLayout$case:
    boolean isEndIconChecked -> new
    java.lang.CharSequence error -> int
com.google.android.material.textfield.TextInputLayout$SavedState$1 -> com.google.android.material.textfield.TextInputLayout$case$do:
com.google.android.material.textview.MaterialTextView -> com.google.android.material.textview.MaterialTextView:
    void applyLineHeightFromViewAppearance(android.content.res.Resources$Theme,int) -> do
    boolean canApplyTextAppearanceLineHeight(android.content.Context) -> do
    int findViewAppearanceResourceId(android.content.res.Resources$Theme,android.util.AttributeSet,int,int) -> do
    int readFirstAvailableDimension(android.content.Context,android.content.res.TypedArray,int[]) -> do
    boolean viewAttrsHasLineHeight(android.content.Context,android.content.res.Resources$Theme,android.util.AttributeSet,int,int) -> do
com.google.android.material.transformation.ExpandableBehavior -> com.google.android.material.transformation.ExpandableBehavior:
    int currentState -> do
    int access$000(com.google.android.material.transformation.ExpandableBehavior) -> do
    boolean didStateChange(boolean) -> do
    boolean onExpandedStateChange(android.view.View,android.view.View,boolean,boolean) -> do
    boolean onLayoutChild(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,int) -> do
    boolean onDependentViewChanged(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> if
    com.google.android.material.expandable.ExpandableWidget findExpandableWidget(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View) -> new
com.google.android.material.transformation.ExpandableBehavior$1 -> com.google.android.material.transformation.ExpandableBehavior$do:
    android.view.View val$child -> if
    int val$expectedState -> for
    com.google.android.material.transformation.ExpandableBehavior this$0 -> new
    com.google.android.material.expandable.ExpandableWidget val$dep -> int
com.google.android.material.transformation.ExpandableTransformationBehavior -> com.google.android.material.transformation.ExpandableTransformationBehavior:
    android.animation.AnimatorSet currentAnimation -> if
    android.animation.AnimatorSet access$002(com.google.android.material.transformation.ExpandableTransformationBehavior,android.animation.AnimatorSet) -> do
    boolean onExpandedStateChange(android.view.View,android.view.View,boolean,boolean) -> do
    android.animation.AnimatorSet onCreateExpandedStateChangeAnimation(android.view.View,android.view.View,boolean,boolean) -> if
com.google.android.material.transformation.ExpandableTransformationBehavior$1 -> com.google.android.material.transformation.ExpandableTransformationBehavior$do:
    com.google.android.material.transformation.ExpandableTransformationBehavior this$0 -> do
com.google.android.material.transformation.FabTransformationBehavior -> com.google.android.material.transformation.FabTransformationBehavior:
    android.graphics.RectF tmpRectF1 -> int
    android.graphics.Rect tmpRect -> for
    int[] tmpArray -> try
    float dependencyOriginalTranslationX -> byte
    android.graphics.RectF tmpRectF2 -> new
    float dependencyOriginalTranslationY -> case
    android.view.ViewGroup calculateChildContentContainer(android.view.View) -> do
    void calculateChildVisibleBoundsAtEndOfExpansion(android.view.View,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,com.google.android.material.animation.MotionTiming,com.google.android.material.animation.MotionTiming,float,float,float,float,android.graphics.RectF) -> do
    void calculateDependencyWindowBounds(android.view.View,android.graphics.RectF) -> do
    android.util.Pair calculateMotionTiming(float,float,boolean,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec) -> do
    float calculateRevealCenterX(android.view.View,android.view.View,com.google.android.material.animation.Positioning) -> do
    float calculateValueOfAnimationAtEndOfExpansion(com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,com.google.android.material.animation.MotionTiming,float,float) -> do
    void createChildrenFadeAnimation(android.view.View,android.view.View,boolean,boolean,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,java.util.List,java.util.List) -> do
    void createDependencyTranslationAnimation(android.view.View,android.view.View,boolean,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,java.util.List) -> do
    void createExpansionAnimation(android.view.View,android.view.View,boolean,boolean,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,float,float,java.util.List,java.util.List) -> do
    void createPostFillRadialExpansion(android.view.View,long,long,long,int,int,float,java.util.List) -> do
    void createPreFillRadialExpansion(android.view.View,long,int,int,float,java.util.List) -> do
    void createTranslationAnimation(android.view.View,android.view.View,boolean,boolean,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,java.util.List,java.util.List,android.graphics.RectF) -> do
    boolean layoutDependsOn(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> do
    void onAttachedToLayoutParams(androidx.coordinatorlayout.widget.CoordinatorLayout$LayoutParams) -> do
    com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec onCreateMotionSpec(android.content.Context,boolean) -> do
    float calculateTranslationX(android.view.View,android.view.View,com.google.android.material.animation.Positioning) -> for
    void createElevationAnimation(android.view.View,android.view.View,boolean,boolean,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,java.util.List,java.util.List) -> for
    android.view.ViewGroup toViewGroupOrNull(android.view.View) -> for
    float calculateRevealCenterY(android.view.View,android.view.View,com.google.android.material.animation.Positioning) -> if
    void calculateWindowBounds(android.view.View,android.graphics.RectF) -> if
    void createColorAnimation(android.view.View,android.view.View,boolean,boolean,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,java.util.List,java.util.List) -> if
    int getBackgroundTint(android.view.View) -> if
    android.animation.AnimatorSet onCreateExpandedStateChangeAnimation(android.view.View,android.view.View,boolean,boolean) -> if
    float calculateTranslationY(android.view.View,android.view.View,com.google.android.material.animation.Positioning) -> int
    void createIconFadeAnimation(android.view.View,android.view.View,boolean,boolean,com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec,java.util.List,java.util.List) -> int
com.google.android.material.transformation.FabTransformationBehavior$1 -> com.google.android.material.transformation.FabTransformationBehavior$do:
    android.view.View val$dependency -> for
    boolean val$expanded -> do
    android.view.View val$child -> if
com.google.android.material.transformation.FabTransformationBehavior$2 -> com.google.android.material.transformation.FabTransformationBehavior$if:
    android.view.View val$child -> do
com.google.android.material.transformation.FabTransformationBehavior$3 -> com.google.android.material.transformation.FabTransformationBehavior$for:
    com.google.android.material.circularreveal.CircularRevealWidget val$circularRevealChild -> do
    android.graphics.drawable.Drawable val$icon -> if
com.google.android.material.transformation.FabTransformationBehavior$4 -> com.google.android.material.transformation.FabTransformationBehavior$int:
    com.google.android.material.circularreveal.CircularRevealWidget val$circularRevealChild -> do
com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec -> com.google.android.material.transformation.FabTransformationBehavior$new:
    com.google.android.material.animation.MotionSpec timings -> do
    com.google.android.material.animation.Positioning positioning -> if
com.google.android.material.transformation.FabTransformationScrimBehavior -> com.google.android.material.transformation.FabTransformationScrimBehavior:
    com.google.android.material.animation.MotionTiming expandTiming -> for
    com.google.android.material.animation.MotionTiming collapseTiming -> int
    void createScrimAnimation(android.view.View,boolean,boolean,java.util.List,java.util.List) -> do
    boolean layoutDependsOn(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.View) -> do
    android.animation.AnimatorSet onCreateExpandedStateChangeAnimation(android.view.View,android.view.View,boolean,boolean) -> if
    boolean onTouchEvent(androidx.coordinatorlayout.widget.CoordinatorLayout,android.view.View,android.view.MotionEvent) -> if
com.google.android.material.transformation.FabTransformationScrimBehavior$1 -> com.google.android.material.transformation.FabTransformationScrimBehavior$do:
    boolean val$expanded -> do
    android.view.View val$child -> if
com.google.android.material.transformation.FabTransformationSheetBehavior -> com.google.android.material.transformation.FabTransformationSheetBehavior:
    java.util.Map importantForAccessibilityMap -> char
    com.google.android.material.transformation.FabTransformationBehavior$FabTransformationSpec onCreateMotionSpec(android.content.Context,boolean) -> do
    boolean onExpandedStateChange(android.view.View,android.view.View,boolean,boolean) -> do
    void updateImportantForAccessibility(android.view.View,boolean) -> do
com.google.android.material.transformation.TransformationChildCard -> com.google.android.material.transformation.do:
com.google.android.material.transformation.TransformationChildLayout -> com.google.android.material.transformation.if:
de.hdodenhof.circleimageview.CircleImageView -> de.hdodenhof.circleimageview.CircleImageView:
    android.graphics.RectF mDrawableRect -> if
    android.graphics.BitmapShader mBitmapShader -> long
    boolean mBorderOverlay -> float
    int mBitmapWidth -> this
    android.graphics.Paint mBorderPaint -> try
    boolean mDisableCircularTransformation -> short
    android.graphics.Paint mCircleBackgroundPaint -> byte
    float mBorderRadius -> catch
    android.graphics.Paint mBitmapPaint -> new
    android.widget.ImageView$ScaleType SCALE_TYPE -> super
    int mBitmapHeight -> void
    android.graphics.Bitmap$Config BITMAP_CONFIG -> throw
    android.graphics.Bitmap mBitmap -> goto
    int mCircleBackgroundColor -> else
    boolean mSetupPending -> final
    android.graphics.ColorFilter mColorFilter -> class
    android.graphics.RectF mBorderRect -> for
    int mBorderWidth -> char
    android.graphics.Matrix mShaderMatrix -> int
    int mBorderColor -> case
    float mDrawableRadius -> break
    boolean mReady -> const
    boolean access$100(de.hdodenhof.circleimageview.CircleImageView) -> do
    void applyColorFilter() -> do
    android.graphics.Bitmap getBitmapFromDrawable(android.graphics.drawable.Drawable) -> do
    boolean inTouchableArea(float,float) -> do
    void init() -> for
    android.graphics.RectF access$200(de.hdodenhof.circleimageview.CircleImageView) -> if
    android.graphics.RectF calculateBounds() -> if
    void initializeBitmap() -> int
    void setup() -> new
    void updateShaderMatrix() -> try
de.hdodenhof.circleimageview.CircleImageView$1 -> de.hdodenhof.circleimageview.CircleImageView$do:
de.hdodenhof.circleimageview.CircleImageView$OutlineProvider -> de.hdodenhof.circleimageview.CircleImageView$if:
    de.hdodenhof.circleimageview.CircleImageView this$0 -> do
de.hdodenhof.circleimageview.R$styleable -> de.hdodenhof.circleimageview.do:
eu.chainfire.libsuperuser.Debug -> int.do.do.do:
    boolean debug -> do
    int logTypes -> if
    boolean sanityChecks -> int
    eu.chainfire.libsuperuser.Debug$OnLogListener logListener -> for
    boolean getDebug() -> do
    void log(java.lang.String) -> do
    void logCommon(int,java.lang.String,java.lang.String) -> do
    boolean getSanityChecksEnabledEffective() -> for
    void logOutput(java.lang.String) -> for
    boolean getSanityChecksEnabled() -> if
    void logCommand(java.lang.String) -> if
    boolean onMainThread() -> int
eu.chainfire.libsuperuser.Debug$OnLogListener -> int.do.do.do$do:
    void onLog(int,java.lang.String,java.lang.String) -> do
eu.chainfire.libsuperuser.Shell -> int.do.do.if:
    java.util.List run(java.lang.String,java.lang.String[],java.lang.String[],boolean) -> do
eu.chainfire.libsuperuser.Shell$SU -> int.do.do.if$do:
    boolean isSU(java.lang.String) -> do
    java.util.List run(java.util.List) -> do
    java.util.List run(java.lang.String[]) -> do
    java.util.List run(java.lang.String) -> if
eu.chainfire.libsuperuser.ShellOnMainThreadException -> int.do.do.for:
eu.chainfire.libsuperuser.StreamGobbler -> int.do.do.int:
    java.io.BufferedReader reader -> for
    java.util.List writer -> int
    java.lang.String shell -> if
    eu.chainfire.libsuperuser.StreamGobbler$OnLineListener listener -> new
eu.chainfire.libsuperuser.StreamGobbler$OnLineListener -> int.do.do.int$do:
    void onLine(java.lang.String) -> do
per.goweii.anylayer.AnimHelper -> new.do.do.do:
    void startAlphaInAnim(android.view.View,long) -> do
    void startZoomInAnim(android.view.View,long) -> for
    void startAlphaOutAnim(android.view.View,long) -> if
    void startZoomOutAnim(android.view.View,long) -> int
per.goweii.anylayer.AnyLayer -> new.do.do.if:
    per.goweii.anylayer.ViewHolder mViewHolder -> try
    android.view.animation.Animation mBackgroundOutAnim -> class
    int mBackgroundColor -> this
    per.goweii.anylayer.AnyLayer$OnLayerShowListener mOnLayerShowListener -> double
    per.goweii.anylayer.AnyLayer$OnVisibleChangeListener mOnVisibleChangeListener -> while
    android.view.animation.Animation mContentOutAnim -> float
    int mBackgroundResource -> goto
    per.goweii.anylayer.AnyLayer$IAnim mBackgroundAnim -> break
    android.view.animation.Animation mContentInAnim -> final
    per.goweii.anylayer.LayerManager mLayerManager -> public
    android.view.LayoutInflater mInflater -> if
    per.goweii.anylayer.AnyLayer$IAnim mContentAnim -> const
    boolean mCancelableOnTouchOutside -> void
    float mBackgroundBlurRadius -> case
    android.graphics.Bitmap mBackgroundBitmap -> else
    long mBackgroundAnimDuration -> short
    per.goweii.anylayer.AnyLayer$OnLayerDismissListener mOnLayerDismissListener -> import
    per.goweii.anylayer.AnyLayer$IDataBinder mDataBinder -> throw
    android.view.View mTargetView -> for
    android.graphics.drawable.Drawable mBackgroundDrawable -> long
    android.view.View mContent -> new
    per.goweii.anylayer.AnyLayer$Direction mDirection -> native
    android.content.Context mContext -> do
    android.view.ViewGroup mRootView -> int
    long mContentAnimDuration -> super
    float mBackgroundBlurScale -> char
    int mGravity -> byte
    android.view.animation.Animation mBackgroundInAnim -> catch
    void startBackgroundOutAnim() -> break
    void show() -> byte
    long getDuration() -> case
    void startContentInAnim() -> catch
    void initBackground() -> char
    void startContentOutAnim() -> class
    per.goweii.anylayer.ViewHolder access$000(per.goweii.anylayer.AnyLayer) -> do
    per.goweii.anylayer.AnyLayer cancelableOnClickKeyBack(boolean) -> do
    per.goweii.anylayer.AnyLayer contentView(int) -> do
    long onAnimIn(android.view.View) -> do
    per.goweii.anylayer.AnyLayer onClick(int,per.goweii.anylayer.AnyLayer$OnLayerClickListener) -> do
    void onDetach() -> do
    per.goweii.anylayer.AnyLayer with(android.content.Context) -> do
    void initContainer() -> else
    android.content.Context access$200(per.goweii.anylayer.AnyLayer) -> for
    void onAttach() -> for
    void initContent() -> goto
    android.view.ViewGroup access$100(per.goweii.anylayer.AnyLayer) -> if
    per.goweii.anylayer.AnyLayer cancelableOnTouchOutside(boolean) -> if
    long onAnimOut(android.view.View) -> if
    void onRemove() -> if
    float access$300(per.goweii.anylayer.AnyLayer) -> int
    void onShow() -> int
    void initRootView() -> long
    float access$400(per.goweii.anylayer.AnyLayer) -> new
    void dismiss() -> new
    void initView() -> this
    int access$500(per.goweii.anylayer.AnyLayer) -> try
    android.view.View getContentView() -> try
    void startBackgroundInAnim() -> void
per.goweii.anylayer.AnyLayer$1 -> new.do.do.if$do:
    per.goweii.anylayer.AnyLayer this$0 -> if
per.goweii.anylayer.AnyLayer$2 -> new.do.do.if$if:
    per.goweii.anylayer.AnyLayer this$0 -> if
per.goweii.anylayer.AnyLayer$Direction -> new.do.do.if$for:
    per.goweii.anylayer.AnyLayer$Direction[] $VALUES -> try
    per.goweii.anylayer.AnyLayer$Direction BOTTOM -> for
    per.goweii.anylayer.AnyLayer$Direction LEFT -> int
    per.goweii.anylayer.AnyLayer$Direction RIGHT -> new
    per.goweii.anylayer.AnyLayer$Direction TOP -> if
per.goweii.anylayer.AnyLayer$IAnim -> new.do.do.if$int:
    long inAnim(android.view.View) -> do
    long outAnim(android.view.View) -> if
per.goweii.anylayer.AnyLayer$IDataBinder -> new.do.do.if$new:
    void bind(per.goweii.anylayer.AnyLayer) -> do
per.goweii.anylayer.AnyLayer$OnLayerClickListener -> new.do.do.if$try:
    void onClick(per.goweii.anylayer.AnyLayer,android.view.View) -> do
per.goweii.anylayer.AnyLayer$OnLayerDismissListener -> new.do.do.if$byte:
    void onDismissed(per.goweii.anylayer.AnyLayer) -> do
    void onDismissing(per.goweii.anylayer.AnyLayer) -> if
per.goweii.anylayer.AnyLayer$OnLayerShowListener -> new.do.do.if$case:
    void onShowing(per.goweii.anylayer.AnyLayer) -> do
    void onShown(per.goweii.anylayer.AnyLayer) -> if
per.goweii.anylayer.AnyLayer$OnVisibleChangeListener -> new.do.do.if$char:
    void onDismiss(per.goweii.anylayer.AnyLayer) -> do
    void onShow(per.goweii.anylayer.AnyLayer) -> if
per.goweii.anylayer.BitmapUtils -> new.do.do.for:
    android.graphics.Bitmap scale(android.graphics.Bitmap,int,int) -> do
per.goweii.anylayer.BlurUtils -> new.do.do.int:
    android.graphics.Bitmap blur(android.content.Context,android.graphics.Bitmap,float) -> do
    android.graphics.Bitmap blur(android.content.Context,android.graphics.Bitmap,float,float) -> do
per.goweii.anylayer.FastBlur -> new.do.do.new:
    android.graphics.Bitmap blur(android.graphics.Bitmap,int) -> do
    android.graphics.Bitmap blur(android.graphics.Bitmap,int,float) -> do
per.goweii.anylayer.GaussianBlur -> new.do.do.try:
    android.graphics.Bitmap blur(android.content.Context,android.graphics.Bitmap,float) -> do
    android.graphics.Bitmap blur(android.content.Context,android.graphics.Bitmap,float,float) -> do
    android.graphics.Bitmap blurIn25(android.content.Context,android.graphics.Bitmap,float) -> if
per.goweii.anylayer.LayerManager -> new.do.do.byte:
    android.view.View mChild -> for
    boolean mCancelableOnClickKeyBack -> new
    android.view.View currentKeyView -> int
    per.goweii.anylayer.LayerManager$LiveListener mLiveListener -> case
    boolean mDismissing -> byte
    android.view.ViewGroup mParent -> if
    boolean mShowing -> try
    boolean access$002(per.goweii.anylayer.LayerManager,boolean) -> do
    void access$100(per.goweii.anylayer.LayerManager) -> do
    void add() -> do
    long onAnimIn(android.view.View) -> do
    void setCancelableOnClickKeyBack(boolean) -> do
    void setLiveListener(per.goweii.anylayer.LayerManager$LiveListener) -> do
    void onAttach() -> for
    boolean access$202(per.goweii.anylayer.LayerManager,boolean) -> if
    void access$300(per.goweii.anylayer.LayerManager) -> if
    long onAnimOut(android.view.View) -> if
    void remove() -> if
    void onDetach() -> int
    void onRemove() -> new
    void onShow() -> try
per.goweii.anylayer.LayerManager$1 -> new.do.do.byte$do:
    per.goweii.anylayer.LayerManager this$0 -> if
per.goweii.anylayer.LayerManager$2 -> new.do.do.byte$if:
    per.goweii.anylayer.LayerManager this$0 -> if
per.goweii.anylayer.LayerManager$LiveListener -> new.do.do.byte$for:
    long onAnimIn(android.view.View) -> do
    void onDetach() -> do
    void onAttach() -> for
    long onAnimOut(android.view.View) -> if
    void onRemove() -> if
    void onShow() -> int
per.goweii.anylayer.R$id -> new.do.do.case:
per.goweii.anylayer.R$layout -> new.do.do.char:
per.goweii.anylayer.Utils -> new.do.do.else:
    android.app.Activity getActivity(android.content.Context) -> do
    android.graphics.Bitmap snapshot(android.view.View) -> do
per.goweii.anylayer.ViewHolder -> new.do.do.goto:
    per.goweii.anylayer.AnyLayer mAnyLayer -> do
    android.util.SparseArray onClickListeners -> try
    android.widget.FrameLayout mContentWrapper -> for
    android.widget.ImageView mBackground -> int
    android.widget.FrameLayout mContainer -> if
    android.util.SparseArray views -> new
    per.goweii.anylayer.AnyLayer access$000(per.goweii.anylayer.ViewHolder) -> do
    void addOnClickListener(per.goweii.anylayer.AnyLayer$OnLayerClickListener,int,int[]) -> do
    void bindListener() -> do
    android.view.View getView(int) -> do
    android.widget.FrameLayout getContainer() -> for
    android.widget.ImageView getBackground() -> if
    android.widget.FrameLayout getContentWrapper() -> int
    void recycle() -> new
per.goweii.anylayer.ViewHolder$1 -> new.do.do.goto$do:
    per.goweii.anylayer.ViewHolder this$0 -> for
    per.goweii.anylayer.AnyLayer$OnLayerClickListener val$listener -> if
